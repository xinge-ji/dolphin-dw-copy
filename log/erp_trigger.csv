"OWNER","TRIGGER_NAME","TABLE_NAME","TRIGGERING_EVENT","TRIGGER_TYPE","TRIGGER_DDL"
"EXFSYS","EXPFIL_ALTEREXPTAB_MAINT","","ALTER OR RENAME ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""EXFSYS"".""EXPFIL_ALTEREXPTAB_MAINT"" after alter or
        rename on database
      declare 
        objown    VARCHAR2(32); 
        objnm     VARCHAR2(32);
        dcobjnum  NUMBER := null;
        newname   VARCHAR2(32) := null;
        eccnt     NUMBER;
        CURSOR cur1 (towner VARCHAR2, tname VARCHAR2) IS 
          select exscolnm, exstabobj from exf$exprset where exsowner = 
             towner and exstabnm = tname;
      begin 
        objown := DICTIONARY_OBJ_OWNER; 
        objnm := DICTIONARY_OBJ_NAME;

        if (DICTIONARY_OBJ_OWNER = 'EXFSYS') then
          return;
        end if;

        if (DICTIONARY_OBJ_TYPE != 'TABLE') then 
          return;
        end if;

        -- would just skip the loop if no rows found => not an expr table --
        for c1 in cur1(objown, objnm) loop
          if (newname is null) then 
          begin 
            newname := sys.exf$dbms_expfil_syspack.get_tab_name(c1.exstabobj);
          exception
            when others then
              dbms_job.submit(eccnt, 
                'begin exfsys.dbms_expfil_dr.rename_table_maint('||
                   c1.exstabobj||'); end;'); 
              return; -- bug on system trigger : 2355231 --
          end;
          end if;

          if ((newname is null or                   -- not a rename tab --
               (newname is not null and newname = objnm)) and
              sys.exf$dbms_expfil_syspack.tab_column_exists(objown, objnm, 
                           c1.exscolnm) = 0) then 
            dcobjnum := c1.exstabobj;   -- indicates that the column is drpd

            -- the expression column was dropped or marked unusable. --
            -- drop the expression column (dictionary) --
            delete from exf$exprset where exsowner = objown and 
              exstabnm = objnm and exscolnm = c1.exscolnm;
          end if;                                            
        end loop;

        -- if this was a drop column and one of the expression sets was 
        -- dropped, the export dep obj dict should be maintained if this 
        -- is the last expression column in the table --
        if (dcobjnum is not null) then 
          -- Count the number of expression columns left in td  he table --
          select count(*) into eccnt from exf$exprset where
                            exsowner = objown and exstabnm = objnm;

          -- this was the last expression column in the table. 
          if (eccnt = 0) then 
            -- Clear the entry from the dependent action list --
            -- auto commit after delete from expdepact$ --
            sys.exf$dbms_expfil_syspack.clr_exp_depaction(dcobjnum);
          end if;        
        end if;
        -- if the name of the table storing expression changes, update dict
        -- accordingly --
        if (newname is not null and newname != objnm) then 
          -- could be updating 0 or 1 or more rows --
          update exf$exprset set exstabnm = newname where exsowner = objown
            and exstabnm = objnm;
          -- see if there is an index or stats etc., for this table --
          if (SQL%ROWCOUNT > 0) then 
            update exf$expsetprivs set esexptab = newname where 
              esowner = objown and esexptab = objnm;
            update exf$expsetstats set esettable = newname where 
              esetowner = objown and esettable = objnm;
            update exf$idxsecobj set idxesettab = newname where
              idxowner = objown and idxesettab = objnm;
            update exf$esetidxparam set esettabn = newname where
              esetowner = objown and esettabn = objnm;
          end if;
        end if;
        return;
      exception when others then null;
      end;
ALTER TRIGGER ""EXFSYS"".""EXPFIL_ALTEREXPTAB_MAINT"" DISABLE"
"EXFSYS","EXPFIL_DROPOBJ_MAINT","","DROP ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""EXFSYS"".""EXPFIL_DROPOBJ_MAINT"" before drop on database
      declare 
        objown VARCHAR2(32); 
        objnm  VARCHAR2(32);
        attsetc  number;
        tabobjn  number := null;
        
        CURSOR cur2 (tabown VARCHAR2) is 
          select distinct(exstabobj) tobjn from exf$exprset where 
            exsowner = tabown;
      begin 
        objown := DICTIONARY_OBJ_OWNER; 
        objnm := DICTIONARY_OBJ_NAME;

        if (DICTIONARY_OBJ_OWNER = 'EXFSYS') then 
          return;
        end if;
          exfsys.adm_rlmgr_systrig.pre_dropobj_maint(DICTIONARY_OBJ_OWNER,
                              DICTIONARY_OBJ_NAME, DICTIONARY_OBJ_TYPE); 
      
        if (DICTIONARY_OBJ_TYPE = 'TABLE') then 
          begin 
            -- only one row expected --
            select distinct(exstabobj) into tabobjn from exf$exprset where
              exsowner = objown and exstabnm = objnm;
            if (tabobjn is not null) then 
              sys.exf$dbms_expfil_syspack.clr_exp_depaction(tabobjn);
            end if;
            delete from exf$exprset where exsowner = objown and 
              exstabnm = objnm;
          exception 
            when no_data_found then 
              null;
          end;
          return;
        elsif (DICTIONARY_OBJ_TYPE = 'TYPE' or 
               DICTIONARY_OBJ_TYPE = 'TYPE BODY') then 
          if (dbms_expfil_utl.db_operation_type =
              dbms_expfil_utl.OP_DROP_USER or
              dbms_expfil_utl.db_operation_type =
              dbms_expfil_utl.EXF_MAINT_OP) then
            return;                   --- return is dropping the user ---
          end if;

          select count(*) into attsetc from exf$attrset where atsowner 
             = objown and atsname = objnm; 
          if (attsetc != 0) then 
            dbms_expfil_utl.error_out(38473);
          end if;
          return;
        elsif (DICTIONARY_OBJ_TYPE = 'USER') then
          if (objnm = 'EXFSYS') then 
            return;
          end if;
          -- set the drop user context; no error dropping types --
          dbms_expfil_utl.db_operation_type :=
                       dbms_expfil_utl.OP_DROP_USER;
        end if;
      exception when others then 
        -- recognize all the errors that are valid to throw --
        if (SQLCODE = -38473 or SQLCODE = -41657 or SQLCODE = -41701 or 
            SQLCODE = -41705) then
          raise;
        end if;
      end;
ALTER TRIGGER ""EXFSYS"".""EXPFIL_DROPOBJ_MAINT"" DISABLE"
"EXFSYS","EXPFIL_DROPUSR_MAINT","","DROP ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""EXFSYS"".""EXPFIL_DROPUSR_MAINT"" after drop on database 
      declare 
        objnm VARCHAR2(32);
        CURSOR cur1 (tabown VARCHAR2) is 
          select distinct(exstabobj) tobjn from exf$exprset where 
            exsowner = tabown and exstabnm is not null;
      begin 
        objnm := DICTIONARY_OBJ_NAME;
        if (DICTIONARY_OBJ_TYPE != 'USER') then 
          return;
        end if;

        -- user being dropped is not EXFSYS --
        if (objnm = 'EXFSYS') then
          return;
        end if;
        dbms_expfil_utl.db_operation_type := dbms_expfil_utl.NO_SIG_OPER;

        for c1 in cur1 (objnm) loop 
          sys.exf$dbms_expfil_syspack.clr_exp_depaction(c1.tobjn); 
        end loop;
        delete from exf$exprset where exsowner = objnm;
        delete from exf$attrset where atsowner = objnm;
        delete from exf$expsetprivs where esgrantee = objnm;
      exception when others then null;
      end;
ALTER TRIGGER ""EXFSYS"".""EXPFIL_DROPUSR_MAINT"" DISABLE"
"EXFSYS","EXPFIL_RESTRICT_TYPEEVOLVE","","CREATE OR ALTER ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""EXFSYS"".""EXPFIL_RESTRICT_TYPEEVOLVE"" before alter
       or create on database
      declare 
        objown VARCHAR2(32);
        objnm  VARCHAR2(32);
        attsetc  number;
      begin 
        objown := DICTIONARY_OBJ_OWNER; 
        objnm := DICTIONARY_OBJ_NAME;
 
        if (DICTIONARY_OBJ_OWNER = 'EXFSYS') then
          return;
        end if;

        if (DICTIONARY_OBJ_TYPE != 'TYPE') then
          return;
        end if;

        -- see if the ADT is used for an attribute set --
        select count(*) into attsetc from exf$attrset where atsowner
           = objown and atsname = objnm;

        -- if the type is being created because of add_elementary_attr
        -- operation, let it go --
        if (attsetc != 0 and dbms_expfil_utl.db_operation_type !=
            dbms_expfil_utl.EXF_MAINT_OP) then
          -- we are about to throw the error; just check if this 
          -- attribute set is invalid due to evolution of one of its 
          -- embedded types with INVALIDATE option. If this is the case, 
          -- the system trigger will be invoked next time the ADT is 
          -- being used with status = INVALID --
          if (sys.exf$dbms_expfil_syspack.get_typelv_status(objown,objnm) 
                  = 'VALID') then 
            dbms_expfil_utl.error_out(38476); -- no doubt; has to be error --
          end if; 
        end if;
      exception when others then 
        if (SQLCODE = -38476) then raise; end if;
      end;
ALTER TRIGGER ""EXFSYS"".""EXPFIL_RESTRICT_TYPEEVOLVE"" DISABLE"
"EXFSYS","RLMGR_TRUNCATE_MAINT","","TRUNCATE ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""EXFSYS"".""RLMGR_TRUNCATE_MAINT"" before truncate on 
        database
     declare 
        objown VARCHAR2(32);
        objnm  VARCHAR2(32);
        rcpcknm VARCHAR2(32);
        obcnt   NUMBER;
      begin 
        objown := DICTIONARY_OBJ_OWNER; 
        objnm := DICTIONARY_OBJ_NAME;
 
        if (DICTIONARY_OBJ_OWNER = 'EXFSYS') then
          return;
        end if;
        if (DICTIONARY_OBJ_TYPE = 'TABLE') then 
        begin
          select evst_name into rcpcknm from exfsys.rlm$eventstruct where
          evst_owner = objown and evst_prct = objnm; 
          select count(*) into obcnt from rlm$primevttypemap where 
             rset_owner = objown and prim_evntst = rcpcknm; 
          if (obcnt > 0) then
            dbms_rlmgr_dr.raise_error(41701); 
          end if;
        exception 
          when no_data_found then 
            null;
          when others then 
            if (SQLCODE = -01422) then
            begin
              select evst_name into rcpcknm from exfsys.rlm$eventstruct where 
                evst_owner = objown and evst_prct = objnm 
                and evst_name like 'RLM$PCTTA_%';
              dbms_rlmgr_dr.raise_error(41701);
            exception
              when no_data_found then null;
            end;
            end if;
            raise;
        end;
        begin
          select rset_pack into rcpcknm from rlm$ruleset where 
            rset_owner = objown and rset_name = objnm and 
             bitand(rset_prop, 4) = 4; 
          sys.exf$dbms_expfil_syspack.parse_proc_as_owner(objown, 
              rcpcknm, 'TRUNCATE_RCTAB', 0); 
        exception 
          when no_data_found then 
             null;
          when others then 
            raise; 
        end;
        end if;
      end;
ALTER TRIGGER ""EXFSYS"".""RLMGR_TRUNCATE_MAINT"" DISABLE"
"JXWMS","BOND_WAREHOUSE_INORDER_TRG","BOND_WAREHOUSE_INORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""BOND_WAREHOUSE_INORDER_TRG"" 
       after update of usestatus
       on bond_warehouse_inorder
       for each row
declare
  v_count number;--计数
  cursor c_bond_warehouse_inorderdtl1 is
         select b.seqid,b.seqdtlid,b.declared_quantity
                from bond_warehouse_qty_lst a ,bond_warehouse_inorderdtl b--,bond_warehouse_inorder c
                     where a.seqdtlid(+) = b.seqdtlid
                           --and b.seqid = c.seqid
                           and b.seqid =:new.seqid
                           and a.seqdtlid is null;

  cursor c_bond_warehouse_inorderdtl2 is
         select a.seqid,a.seqdtlid,a.declared_quantity
                from bond_warehouse_inorderdtl a
                     where  a.seqid = :new.seqid;

  r_bond_warehouse_inorderdtl1 c_bond_warehouse_inorderdtl1%rowtype;
  r_bond_warehouse_inorderdtl2 c_bond_warehouse_inorderdtl2%rowtype;
begin
     if :old.usestatus = :new.usestatus then
          Raise_Application_Error(-20001,'不能反复确认或回退确认！');
     end if;
     --确认逻辑
     --1.判断seqdtlid有存在 不允许插入；
     --2.不存在 就插入
     if :new.usestatus = 1 then
        select (case when count(1) > 0 then 1 --库存表没有该细单
                     else 0 end) counts --库存表有该总单和细单
               into v_count
               from bond_warehouse_qty_lst a ,bond_warehouse_inorderdtl b
                    where a.seqdtlid(+) = b.seqdtlid
                          and b.seqid = :new.seqid
                          and a.seqdtlid is null;
        if v_count = 0 then
          select (case when count(1) > 0 then 2
                 else 3 end)counts into v_count
                 from bond_warehouse_qty_lst
                 where seqid = :new.seqid;
        end if;
        --插入库存表没有的细单
        if v_count = 1 then
          open c_bond_warehouse_inorderdtl1;
          loop
            fetch c_bond_warehouse_inorderdtl1
            into  r_bond_warehouse_inorderdtl1;
            if  c_bond_warehouse_inorderdtl1 %notfound then
                exit;
            end if;

            insert into bond_warehouse_qty_lst
               (seqid,seqdtlid,credate,goodsqty)
            values(r_bond_warehouse_inorderdtl1.seqid,r_bond_warehouse_inorderdtl1.seqdtlid,:new.credate,r_bond_warehouse_inorderdtl1.declared_quantity);
          end loop;
          close c_bond_warehouse_inorderdtl1;
         end if;
         --插入库存表没有的所有细单
          if v_count = 3 then
              open c_bond_warehouse_inorderdtl2;
              loop
                fetch c_bond_warehouse_inorderdtl2
                into  r_bond_warehouse_inorderdtl2;
                if  c_bond_warehouse_inorderdtl2 %notfound then
                    exit;
                end if;

                insert into bond_warehouse_qty_lst
                   (seqid,seqdtlid,credate,goodsqty)
                values(r_bond_warehouse_inorderdtl2.seqid,r_bond_warehouse_inorderdtl2.seqdtlid,:new.credate,r_bond_warehouse_inorderdtl2.declared_quantity);
              end loop;
              close c_bond_warehouse_inorderdtl2;
           end if;
     end if;
     --回退确认逻辑
     --1.判断seqdtlid是否存在 存在不允许回退
     --2.存在的话 判断 库存数量goodsqty是否=入库订单上的数量，如果库存不够回退失败
     --3.回退成功 删除库存表记录
     if nvl(:new.usestatus,0) = 0 then
        open c_bond_warehouse_inorderdtl2;
        loop
          fetch c_bond_warehouse_inorderdtl2
          into r_bond_warehouse_inorderdtl2;

          if c_bond_warehouse_inorderdtl2 %notfound then
            exit;
          end if;
          --已出库的不能回退
          select count(1) into v_count
                 from bond_warehouse_inorderdtl a,bond_warehouse_outorderdtl b,bond_warehouse_outorder c
                      where a.seqdtlid = b.seqdtlid
                            and b.outseqid = c.outseqid
                            and c.usestatus = 1
                            and a.seqdtlid = r_bond_warehouse_inorderdtl2.seqdtlid;
          if v_count <> 0 then
             Raise_Application_Error(-20001,'回退确定--细单【'||r_bond_warehouse_inorderdtl2.seqdtlid||'】已出库,不允许回退!');
            exit;
          end if;

          select
              nvl((nvl(r_bond_warehouse_inorderdtl2.declared_quantity,0) - nvl(a.goodsqty,0)),0)as count_number into v_count
                 from bond_warehouse_qty_lst a
                 where a.seqdtlid = r_bond_warehouse_inorderdtl2.seqdtlid;
          if v_count = 0 then

            delete from bond_warehouse_qty_lst where seqdtlid =  r_bond_warehouse_inorderdtl2.seqdtlid;

          else
            Raise_Application_Error(-20001,'回退确定后细单【'||r_bond_warehouse_inorderdtl2.seqdtlid||'】货品库存数量小于0,不允许回退!');
            exit;
          end if;
        end loop;
        close c_bond_warehouse_inorderdtl2;
     end if;
end bond_warehouse_inorder_trg;



ALTER TRIGGER ""JXWMS"".""BOND_WAREHOUSE_INORDER_TRG"" ENABLE"
"JXWMS","BOND_WAREHOUSE_OUTORDER_TRG","BOND_WAREHOUSE_OUTORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""BOND_WAREHOUSE_OUTORDER_TRG"" 
       after update of usestatus
       on bond_warehouse_outorder
       for each row
declare
       v_count number;--计数
       v_sum number;--计算总和
       cursor c_bond_warehouse_outorder is
         select a.seqdtlid,nvl(b.goodsqty,0)-nvl(a.goodsqty,0) inventory
               from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b,bond_warehouse_inorderdtl c
                    where a.outseqid =:new.outseqid
                          and a.seqdtlid = c.seqdtlid
                          and a.seqdtlid = b.seqdtlid(+);
       r_bond_warehouse_outorder  c_bond_warehouse_outorder%rowtype;
begin
       if :old.usestatus = :new.usestatus then
          Raise_Application_Error(-20001,'不能反复确认或回退确认！');
       end if;

       /*确定逻辑：
       1.判断seqdtlid是否存在 不存在则确定失败；
       2.如果存在，判断出库细单上的出库数量是否小于或等于库存数量，
       通过seqdtlid关联；库存足够确定成功，
       update库存表的库存数量=库存数量-出库数量；库存不够确定失败；*/

      if :new.usestatus = 1 then
         open c_bond_warehouse_outorder;
         loop
             fetch c_bond_warehouse_outorder
             into r_bond_warehouse_outorder;
             if c_bond_warehouse_outorder %notfound then
                exit;
             end if;

             if r_bond_warehouse_outorder.inventory < 0 then
                Raise_Application_Error(-20001,'确定失败,细单【'||r_bond_warehouse_outorder.seqdtlid||'】货品库存数量小于出库数量,不允许出库!');
             elsif r_bond_warehouse_outorder.inventory = 0 then
                delete from bond_warehouse_qty_lst where seqdtlid = r_bond_warehouse_outorder.seqdtlid;
             else
                update bond_warehouse_qty_lst set goodsqty = r_bond_warehouse_outorder.inventory where  seqdtlid = r_bond_warehouse_outorder.seqdtlid;
             end if;
         end loop;
         close c_bond_warehouse_outorder;
      end if;

      /*回退确定逻辑：
      1.判断seqdtlid是否存在 不存在回退失败
      2.存在的话 判断 库存数量+回退数量 是否小于
      入库订单的数量(seqdtlid关联)；小于或等于入库订单数量，则回退成功，
      更新库存表数量为库存数量+回退数量；如果大于，回退确定失败*/

      if :new.usestatus = 0 then
         open c_bond_warehouse_outorder;
         loop
           fetch c_bond_warehouse_outorder
           into  r_bond_warehouse_outorder;
           if c_bond_warehouse_outorder %notfound then
              exit;
           end if;
           select count(1) into v_count
                  from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b
                       where a.outseqid = :new.outseqid
                             and a.seqdtlid(+) = b.seqdtlid
                             and a.seqdtlid is null;

           if v_count > 0  then
              Raise_Application_Error(-20001,'细单有不存在的库存货品,回退失败！');
              exit;
           end if;

           select  (case when (sum(nvl(a.goodsqty,0)) + r_bond_warehouse_outorder.inventory) - c.declared_quantity > 0 then 1
                        when (sum(nvl(a.goodsqty,0)) - c.declared_quantity ) = 0 then 2
                        else 3 end) into v_sum
                  from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b,bond_warehouse_inorderdtl c
                       where  a.seqdtlid = b.seqdtlid(+)
                              and a.seqdtlid = c.seqdtlid
                              and a.seqdtlid = r_bond_warehouse_outorder.seqdtlid
                              and a.outseqid = :new.outseqid
                              GROUP BY a.seqdtlid,c.declared_quantity;
           if v_sum = 1 then
              Raise_Application_Error(-20001,'库存来源ID【'||r_bond_warehouse_outorder.seqdtlid||'】回退货品数过多,回退失败！');
              exit;
           elsif v_sum = 2 then
               insert into bond_warehouse_qty_lst
                       (seqid,seqdtlid,credate,goodsqty)
                       select b.seqid,a.seqdtlid,c.credate,a.goodsqty
                               From bond_warehouse_outorderdtl a,bond_warehouse_inorderdtl b,bond_warehouse_inorder c
                               where   a.seqdtlid = b.seqdtlid
                                       and b.seqid = c.seqid
                                       and a.outseqid = :new.outseqid
                                       and a.seqdtlid = r_bond_warehouse_outorder.seqdtlid;
           else
              select a.goodsqty into v_sum from bond_warehouse_outorderdtl a where a.seqdtlid = r_bond_warehouse_outorder.seqdtlid and a.outseqid = :new.outseqid;
              update bond_warehouse_qty_lst set goodsqty = goodsqty + v_sum where  seqdtlid = r_bond_warehouse_outorder.seqdtlid;
           end if;
         end loop;
         close c_bond_warehouse_outorder;
      end if;
end bond_warehouse_outorder_trg;



ALTER TRIGGER ""JXWMS"".""BOND_WAREHOUSE_OUTORDER_TRG"" ENABLE"
"JXWMS","CDCS_UPLOADINOUTWHDA_TRG","CDCS_UPLOADINOUTWHDA","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""CDCS_UPLOADINOUTWHDA_TRG"" before insert on cdcs_uploadinoutwhda for each row
begin
select cdcs_uploadinoutwhda_seq.nextval into :new.SEQID from dual;
end;




ALTER TRIGGER ""JXWMS"".""CDCS_UPLOADINOUTWHDA_TRG"" ENABLE"
"JXWMS","GSP_APPL_MANAGE_PERMIT_TRI","GSP_APPLIANCE_MANAGE_PERMIT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""GSP_APPL_MANAGE_PERMIT_TRI"" 
  before insert or update on gsp_appliance_manage_permit  
for each row
       begin
  :new.validenddate:=to_date(to_char(:new.validenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end gsp_appl_manage_permit_tri;





ALTER TRIGGER ""JXWMS"".""GSP_APPL_MANAGE_PERMIT_TRI"" ENABLE"
"JXWMS","T610_TRI","T610","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""T610_TRI"" 
  before delete on t610
  for each row

      begin
  insert into t610_his
    (iodtlid,zxcolumn8,taxinvno,unitprice,goodsownerid,DEL_DATE)
  values
    (:old.iodtlid,
     :old.zxcolumn8,
     :old.taxinvno,
     :old.unitprice,
     :old.goodsownerid,
     sysdate);
end;




ALTER TRIGGER ""JXWMS"".""T610_TRI"" ENABLE"
"JXWMS","TRG_DPS_TO_WMS","DPS_TO_WMS","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_DPS_TO_WMS"" 
before delete
on dps_to_wms
 begin
insert into dps_to_wms_bak  select * from dps_to_wms;
end;




ALTER TRIGGER ""JXWMS"".""TRG_DPS_TO_WMS"" ENABLE"
"JXWMS","TRG_INTER_FINISH","INTER_FINISH","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_INTER_FINISH"" 
before delete
on inter_finish
 begin
insert into inter_finish_bak  select * from inter_finish;
end;




ALTER TRIGGER ""JXWMS"".""TRG_INTER_FINISH"" ENABLE"
"JXWMS","TRG_INTER_WCS_TASK","INTER_WCS_TASK","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_INTER_WCS_TASK"" 
before delete
on inter_wcs_task
 begin
insert into inter_wcs_task_bak  select * from inter_wcs_task;
end;




ALTER TRIGGER ""JXWMS"".""TRG_INTER_WCS_TASK"" ENABLE"
"JXWMS","TRG_INTER_WMS_TASK","INTER_WMS_TASK","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_INTER_WMS_TASK"" 
before delete
on inter_wms_task
 begin
insert into inter_wms_task_bak  select * from inter_wms_task;
end;




ALTER TRIGGER ""JXWMS"".""TRG_INTER_WMS_TASK"" ENABLE"
"JXWMS","TRG_T101_HIS","T101","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T101_HIS"" 
  BEFORE DELETE ON T101
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
        
BEGIN
  insert into t101_HIS
    (goodsownerid,
     goodsownid,
     barcode,
     goodsno,
     gopcode,
     gopinyin,
     poison_drug,
     goodsname,
     goodsengname,
     goodsformalname,
     goodstype,
     prodarea,
     factname,
     tradepack,
     outpack,
     outrule,
     alarmdays,
     allowindays,
     allowoutdays,
     safestock,
     addmedcheckflag,
     pasteflag,
     wholesaleprice,
     resaleprice,
     purchasetax,
     saletax,
     lotflag,
     batchflag,
     comeflag,
     memo,
     drugform,
     status,
     otcflag,
     trademark,
     storagecondition,
     approvedocno,
     qualifydocno,
     goodsclassid,
     packsize,
     dbcheck,
     storagetype,
     periodunit,
     validperiod,
     varietyname,
     varietyno,
     supplyername,
     registdocno,
     varietydescid,
     KEYCONSERVEFLAG,
     ecodeflag,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     erpfactoryid,
     erpgoodsid,
     erpgoodsdtlid,
     impflag,
     seqid,
     mah,
     udicode,
     udiflag,
     TRANSCONDITION,
     BUSISCOPENAME,
     prodlicenseno,
     print_goodsname,
     print_goodstype,
     zx_retainqty,
     cre_date,
     del_date)
  VALUES
    (:OLD.goodsownerid,
     :OLD.goodsownid,
     :OLD.barcode,
     :OLD.goodsno,
     :OLD.gopcode,
     :OLD.gopinyin,
     :OLD.poison_drug,
     :OLD.goodsname,
     :OLD.goodsengname,
     :OLD.goodsformalname,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.tradepack,
     :OLD.outpack,
     :OLD.outrule,
     :OLD.alarmdays,
     :OLD.allowindays,
     :OLD.allowoutdays,
     :OLD.safestock,
     :OLD.addmedcheckflag,
     :OLD.pasteflag,
     :OLD.wholesaleprice,
     :OLD.resaleprice,
     :OLD.purchasetax,
     :OLD.saletax,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.memo,
     :OLD.drugform,
     :OLD.status,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.storagecondition,
     :OLD.approvedocno,
     :OLD.qualifydocno,
     :OLD.goodsclassid,
     :OLD.packsize,
     :OLD.dbcheck,
     :OLD.storagetype,
     :OLD.periodunit,
     :OLD.validperiod,
     :OLD.varietyname,
     :OLD.varietyno,
     :OLD.supplyername,
     :OLD.registdocno,
     :OLD.varietydescid,
     :old.KEYCONSERVEFLAG,
     :old.ecodeflag,     
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.erpfactoryid,
     :OLD.erpgoodsid,
     :OLD.erpgoodsdtlid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.mah,
     :OLD.udicode,
     :OLD.udiflag,
     :OLD.TRANSCONDITION,
     :OLD.BUSISCOPENAME,
     :OLD.prodlicenseno,
     :OLD.print_goodsname,
     :OLD.print_goodstype,
     :old.zx_retainqty,
     :OLD.cre_date,
     SYSDATE);
END;



ALTER TRIGGER ""JXWMS"".""TRG_T101_HIS"" ENABLE"
"JXWMS","TRG_T102_HIS","T102","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T102_HIS"" 
  BEFORE DELETE ON T102
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
        BEGIN
  insert into t102_HIS
    (bank,
     goodsownerid,
     gcompanyid,
     companystyle,
     companyname,
     gopinyin,
     opcode,
     companyshortname,
     bankno,
     chiefofficer,
     connector,
     connphone,
     companytype,
     lotlimit,
     validdays,
     deliveraddr,
     province,
     credit,
     usedcredit,
     invoiceaddr,
     invoicehead,
     invoiceman,
     invoicephone,
     postcode,
     specialrequire,
     taxregistno,
     telephone,
     memo,
     addmedcheckflag,
     usestatus,
     companyno,
     station,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     erpcompanyid,
     impflag,
     seqid,
     cre_date,
     del_date)
  VALUES
    (:OLD.bank,
     :OLD.goodsownerid,
     :OLD.gcompanyid,
     :OLD.companystyle,
     :OLD.companyname,
     :OLD.gopinyin,
     :OLD.opcode,
     :OLD.companyshortname,
     :OLD.bankno,
     :OLD.chiefofficer,
     :OLD.connector,
     :OLD.connphone,
     :OLD.companytype,
     :OLD.lotlimit,
     :OLD.validdays,
     :OLD.deliveraddr,
     :OLD.province,
     :OLD.credit,
     :OLD.usedcredit,
     :OLD.invoiceaddr,
     :OLD.invoicehead,
     :OLD.invoiceman,
     :OLD.invoicephone,
     :OLD.postcode,
     :OLD.specialrequire,
     :OLD.taxregistno,
     :OLD.telephone,
     :OLD.memo,
     :OLD.addmedcheckflag,
     :OLD.usestatus,
     :OLD.companyno,
     :OLD.station,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.erpcompanyid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     SYSDATE);
END;


ALTER TRIGGER ""JXWMS"".""TRG_T102_HIS"" ENABLE"
"JXWMS","TRG_T103_HIS","T103","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T103_HIS"" 
  BEFORE DELETE ON T103
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
    
    
BEGIN
  insert into t103_HIS
    (goodsownerid,
     gocompanyid,
     transid,
     inceptaddr,
     sendrecflag,
     connector,
     connphone,
     telefax,
     postcode,
     memo,
     usestatus,
     areacode,
     areaname,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     tranposname,
     impflag,
     seqid,
     cre_date,
     TRANPOSTYPE,
     del_date,
     ybps)
  VALUES
    (:OLD.goodsownerid,
     :OLD.gocompanyid,
     :OLD.transid,
     :OLD.inceptaddr,
     :OLD.sendrecflag,
     :OLD.connector,
     :OLD.connphone,
     :OLD.telefax,
     :OLD.postcode,
     :OLD.memo,
     :OLD.usestatus,
     :OLD.areacode,
     :OLD.areaname,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.tranposname,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     :OLD.TRANPOSTYPE,
     SYSDATE,
     :OLD.ybps);
END;




ALTER TRIGGER ""JXWMS"".""TRG_T103_HIS"" ENABLE"
"JXWMS","TRG_T201_HIS","T201","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T201_HIS"" 
  BEFORE DELETE ON T201
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW


BEGIN
  insert into t201_HIS
    (goodsownerid,
     credate,
     goodsid,
     sourcecompanyid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     busiqty,
     qty,
     packsize,
     seqid,
     impflag,
     deldate
     )
  VALUES
    (
     :OLD.goodsownerid,
     :OLD.credate,
     :OLD.goodsid,
     :OLD.sourcecompanyid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.busiqty,
     :OLD.qty,
     :OLD.packsize,
     :OLD.seqid,
     :OLD.impflag,
     sysdate
     );
END;




ALTER TRIGGER ""JXWMS"".""TRG_T201_HIS"" ENABLE"
"JXWMS","TRG_T301_HIS","T301","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T301_HIS"" 
  BEFORE DELETE ON T301
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
     
BEGIN
  insert into t301_HIS
    (goodsownerid,
     porderid,
     credate,
     arrivedate,
     sourcecompanyid,
     companystyle,
     jobtype,
     operationtype,
     medicineclass,
     importflag,
     taxflag,
     dtllines,
     memo,
     porderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     lotflag,
     batchflag,
     comeflag,
     dtlmemo,
     inmode,
     fetchvaliddate,
     orderflag,
     packsize,
     sabackdate,
     sbreasonid,
     sadtlid,
     firstflag,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     packname,
     prtclass,
     bmsdocid,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     transid,
     del_date,
     NOWLFLAG,
     mulrecflag,
     AUTOFLAG,
     FROM_SALESID,
     FROM_SALESDTLID,
     autopassflag,
     to_sourcecompanyid,
     to_erpinid,
     to_erpindtlid,
     to_erpoutid,
     to_erpoutdtlid,
     agentname,
     price)
  VALUES
    (:OLD.goodsownerid,
     :OLD.porderid,
     :OLD.credate,
     :OLD.arrivedate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.importflag,
     :OLD.taxflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.porderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.dtlmemo,
     :OLD.inmode,
     :OLD.fetchvaliddate,
     :OLD.orderflag,
     :OLD.packsize,
     :OLD.sabackdate,
     :OLD.sbreasonid,
     :OLD.sadtlid,
     :OLD.firstflag,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.packname,
     :OLD.prtclass,
     :OLD.bmsdocid,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.transid,
     SYSDATE,
     :old.NOWLFLAG,
     :old.mulrecflag,
     :old.AUTOFLAG,
     :old.FROM_SALESID,
     :old.FROM_SALESDTLID,
     :old.autopassflag,
     :old.to_sourcecompanyid,
     :old.to_erpinid,
     :old.to_erpindtlid,
     :old.to_erpoutid,
     :old.to_erpoutdtlid,
     :old.agentname,
     :old.price);
END;




ALTER TRIGGER ""JXWMS"".""TRG_T301_HIS"" ENABLE"
"JXWMS","TRG_T302_HIS","T302","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T302_HIS"" 
  BEFORE DELETE ON T302
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
 
    
BEGIN
  insert into t302_HIS
    (goodsownerid,
     exporderid,
     lineno,
     credate,
     preexpdate,
     expcompanyid,
     companystyle,
     jobtype,
     addinvoiceflag,
     companytype,
     operationtype,
     medicineclass,
     receiveaddr,
     receivehead,
     receiveman,
     samelotflag,
     taxflag,
     transmodeid,
     urgenflag,
     dtllines,
     memo,
     exporderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     addmedcheckflag,
     dtlmemo,
     partexpflag,
     outmode,
     invoicetype,
     placesupplyid,
     placesupplydtlid,
     placeprice,
     resaleprice,
     placemoney,
     otcflag,
     trademark,
     qualitydocno,
     goodsclassname,
     packsize,
     isboxup,
     planarrive,
     pionarrive,
     addressid,
     spellbillno,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     orderflag,
     fixflag,
     salerid,
     salername,
     trdtlid,
     sasettledtlid,
     prtclass,
     prtorderset,
     prtgroupset,
     invno,
     packname,
     sorttype,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     transclass,
     storageid,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     lyzxcolumn1,
     lyzxcolumn2,
     lyzxcolumn3,
     lyzxcolumn4,
     lyzxcolumn5,
     lyzxcolumn6,
     lyzxcolumn7,
     lyzxcolumn8,
     lyzxcolumn9,
     lyzxcolumn10,
     lydtlzxcolumn1,
     lydtlzxcolumn2,
     lydtlzxcolumn3,
     lydtlzxcolumn4,
     lydtlzxcolumn5,
     lydtlzxcolumn6,
     lydtlzxcolumn7,
     lydtlzxcolumn8,
     lydtlzxcolumn9,
     lydtlzxcolumn10,
     lyzxcolumn11,
     lyzxcolumn12,
     lyzxcolumn13,
     lyzxcolumn14,
     lyzxcolumn15,
     lyzxcolumn16,
     lyzxcolumn17,
     lyzxcolumn18,
     lyzxcolumn19,
     lyzxcolumn20,
     del_date,
     NOWLFLAG,
     AUTOFLAG,
     FROM_SUDOCID,
     FROM_SUDTLID,
     to_transid,
     passingflag,
     autopassflag,
     to_expcompanyid,
     to_addressid,
     to_erpinid,
     to_erpoutid,
     to_erpindtlid,
     to_erpoutdtlid,
     to_printprice,
     to_printamt,
     zx_djflag,
     discount_falg,
     discount_sadtlid,
     discount_goodsid,
     discount_amt,
     discount_taxrate)
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.lineno,
     :OLD.credate,
     :OLD.preexpdate,
     :OLD.expcompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.addinvoiceflag,
     :OLD.companytype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.receiveaddr,
     :OLD.receivehead,
     :OLD.receiveman,
     :OLD.samelotflag,
     :OLD.taxflag,
     :OLD.transmodeid,
     :OLD.urgenflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.addmedcheckflag,
     :OLD.dtlmemo,
     :OLD.partexpflag,
     :OLD.outmode,
     :OLD.invoicetype,
     :OLD.placesupplyid,
     :OLD.placesupplydtlid,
     :OLD.placeprice,
     :OLD.resaleprice,
     :OLD.placemoney,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.qualitydocno,
     :OLD.goodsclassname,
     :OLD.packsize,
     :OLD.isboxup,
     :OLD.planarrive,
     :OLD.pionarrive,
     :OLD.addressid,
     :OLD.spellbillno,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.orderflag,
     :OLD.fixflag,
     :OLD.salerid,
     :OLD.salername,
     :OLD.trdtlid,
     :OLD.sasettledtlid,
     :OLD.prtclass,
     :OLD.prtorderset,
     :OLD.prtgroupset,
     :OLD.invno,
     :OLD.packname,
     :OLD.sorttype,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.transclass,
     :OLD.storageid,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.lyzxcolumn1,
     :OLD.lyzxcolumn2,
     :OLD.lyzxcolumn3,
     :OLD.lyzxcolumn4,
     :OLD.lyzxcolumn5,
     :OLD.lyzxcolumn6,
     :OLD.lyzxcolumn7,
     :OLD.lyzxcolumn8,
     :OLD.lyzxcolumn9,
     :OLD.lyzxcolumn10,
     :OLD.lydtlzxcolumn1,
     :OLD.lydtlzxcolumn2,
     :OLD.lydtlzxcolumn3,
     :OLD.lydtlzxcolumn4,
     :OLD.lydtlzxcolumn5,
     :OLD.lydtlzxcolumn6,
     :OLD.lydtlzxcolumn7,
     :OLD.lydtlzxcolumn8,
     :OLD.lydtlzxcolumn9,
     :OLD.lydtlzxcolumn10,
     :OLD.lyzxcolumn11,
     :OLD.lyzxcolumn12,
     :OLD.lyzxcolumn13,
     :OLD.lyzxcolumn14,
     :OLD.lyzxcolumn15,
     :OLD.lyzxcolumn16,
     :OLD.lyzxcolumn17,
     :OLD.lyzxcolumn18,
     :OLD.lyzxcolumn19,
     :OLD.lyzxcolumn20,
     SYSDATE,
     :old.NOWLFLAG,
     :old.AUTOFLAG,
     :old.FROM_SUDOCID,
     :old.FROM_SUDTLID,
     :old.to_transid,
     :old.passingflag,
     :old.autopassflag,
     :old.to_expcompanyid,
     :old.to_addressid,
     :old.to_erpinid,
     :old.to_erpoutid,
     :old.to_erpindtlid,
     :old.to_erpoutdtlid,
     :old.to_printprice,
     :old.to_printamt,
     :old.zx_djflag,
     :old.discount_falg,
     :old.discount_sadtlid,
     :old.discount_goodsid,
     :old.discount_amt,
     :old.discount_taxrate     
     );
END;




ALTER TRIGGER ""JXWMS"".""TRG_T302_HIS"" ENABLE"
"JXWMS","TRG_T310_HIS","T310","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T310_HIS"" 
  BEFORE DELETE ON T310
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

       BEGIN
  insert into t310_his
    (goodsownerid,
     credate,
     jobflag,
     operationtype,
     jobid,
     jobdtlid,
     memo,
     impflag,
     del_date)
  values
    (:old.goodsownerid,
     :old.credate,
     :old.jobflag,
     :old.operationtype,
     :old.jobid,
     :old.jobdtlid,
     :old.memo,
     :old.impflag,
     sysdate);
end;




ALTER TRIGGER ""JXWMS"".""TRG_T310_HIS"" ENABLE"
"JXWMS","TRG_T320_HIS","T320","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T320_HIS"" 
  BEFORE DELETE ON T320
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into t320_HIS
    (goodsownerid,
     lorderid,
     porderid,
     operationtype,
     opstatus,
     arrivedate,
     putupdate,
     sourcecompanyid,
     companystyle,
     dtllines,
     memo,
     lorderdtlid,
     porderdtlid,
     srcdtlno,
     goodsid,
     storageid,
     goodsname,
     packname,
     packsize,
     packunit,
     batchno,
     lotno,
     validdate,
     prddate,
     approvedocno,
     goodstype,
     prodarea,
     factname,
     supplyname,
     goodstatus,
     quanstatus,
     tradepack,
     realrecvqty,
     tinyid,
     tinyqty,
     dtlmemo,
     medchkrptno,
     checkdate,
     transtemp,
     importrepflag,
     passgateflag,
     registeflag,
     medcheckflag,
     eligibilityflag,
     approveno,
     impregno,
     rptno,
     backwhyid,
     checkman1,
     checkman2,
     registno,
     sectionid,
     procerrflag,
     PRINTMONTHFLAG,
     del_date)
  VALUES
    (:OLD.goodsownerid,
     :OLD.lorderid,
     :OLD.porderid,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.arrivedate,
     :OLD.putupdate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.lorderdtlid,
     :OLD.porderdtlid,
     :OLD.srcdtlno,
     :OLD.goodsid,
     :OLD.storageid,
     :OLD.goodsname,
     :OLD.packname,
     :OLD.packsize,
     :OLD.packunit,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.approvedocno,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.supplyname,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.tradepack,
     :OLD.realrecvqty,
     :OLD.tinyid,
     :OLD.tinyqty,
     :OLD.dtlmemo,
     :OLD.medchkrptno,
     :OLD.checkdate,
     :OLD.transtemp,
     :OLD.importrepflag,
     :OLD.passgateflag,
     :OLD.registeflag,
     :OLD.medcheckflag,
     :OLD.eligibilityflag,
     :OLD.approveno,
     :OLD.impregno,
     :OLD.rptno,
     :OLD.backwhyid,
     :OLD.checkman1,
     :OLD.checkman2,
     :OLD.registno,
     :OLD.sectionid,
     :OLD.procerrflag,
     :OLD.PRINTMONTHFLAG,
     SYSDATE);
END;




ALTER TRIGGER ""JXWMS"".""TRG_T320_HIS"" ENABLE"
"JXWMS","TRG_T340_HIS","T340","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T340_HIS"" 
  BEFORE DELETE ON T340
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW




BEGIN
  insert into t340_HIS
    (goodsownerid,
     exporderid,
     srcexpno,
     lineno,
     operationtype,
     opstatus,
     preexpdate,
     prearrivedate,
     ttransmode,
     transno,
     expdate,
     gcompanyid,
     detaillines,
     exportmemo,
     srcexpdtlno,
     exporderdtlid,
     goodsid,
     batchno,
     lotno,
     validdate,
     prddate,
     goodstatus,
     quanstatus,
     approvedocno,
     registno,
     tradegoodspack,
     goodsqty,
     tradegoodsqty,
     expdtlmemo,
     packsize,
     status,
     gostockid,
     procerrflag,
     wholefinpacks,
     scatterfinpacks,
     del_date
     )
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.srcexpno,
     :OLD.lineno,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.preexpdate,
     :OLD.prearrivedate,
     :OLD.ttransmode,
     :OLD.transno,
     :OLD.expdate,
     :OLD.gcompanyid,
     :OLD.detaillines,
     :OLD.exportmemo,
     :OLD.srcexpdtlno,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.registno,
     :OLD.tradegoodspack,
     :OLD.goodsqty,
     :OLD.tradegoodsqty,
     :OLD.expdtlmemo,
     :OLD.packsize,
     :OLD.status,
     :OLD.gostockid,
     :OLD.procerrflag,
     :OLD.wholefinpacks,
     :OLD.scatterfinpacks,
     SYSDATE);
END;




ALTER TRIGGER ""JXWMS"".""TRG_T340_HIS"" ENABLE"
"JXWMS","TRG_T400_HIS","T400","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T400_HIS"" 
  BEFORE DELETE ON T400
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

 
      
BEGIN
insert into T400_his
(
 goodsownerid,
       tradeid,
       tradedate,
       operationtype,
       dtllines,
       usestatus,
       tradedtlid,
       ownergoodsid,
       fromcompanyid,
       fromstorageid,
       fromgoodstatus,
       fromquanstatus,
       frombatchno,
       fromlotno,
       fromproddate,
       fromvaliddate,
       fromapproveno,
       tocompanyid,
       tostorageid,
       togoodstatus,
       toqunstatus,
       tobatchno,
       tolotno,
       toproddate,
       tovaliddate,
       toapproveno,
       tradegoodsqty,
       tradegoodspack,
       goodspackid,
       qty,
       gstorageid,
       packname,
       packsize,
       sectionid,
       fromregistno,
       toregistno,
       tosectionid,
       srcdtlid,--add by wanghuaiyu 20130714
       warehid -- add by xyue 2016-03-09
       )
       values
     (
 :old.goodsownerid,
      :old.tradeid,
       :old.tradedate,
       :old.operationtype,
       :old.dtllines,
      :old.usestatus,
       :old.tradedtlid,
       :old.ownergoodsid,
       :old.fromcompanyid,
       :old.fromstorageid,
       :old.fromgoodstatus,
       :old.fromquanstatus,
       :old.frombatchno,
       :old.fromlotno,
       :old.fromproddate,
       :old.fromvaliddate,
       :old.fromapproveno,
      :old.tocompanyid,
       :old.tostorageid,
       :old.togoodstatus,
       :old.toqunstatus,
       :old.tobatchno,
       :old.tolotno,
       :old.toproddate,
       :old.tovaliddate,
       :old.toapproveno,
       :old.tradegoodsqty,
       :old.tradegoodspack,
       :old.goodspackid,
       :old.qty,
       :old.gstorageid,
       :old.packname,
       :old.packsize,
       :old.sectionid,
       :old.fromregistno,
       :old.toregistno,
       :old.tosectionid,
       :old.srcdtlid,--add by wanghuaiyu 20130714
       :old.warehid --add by xyue 2016-03-09
       );

end;




ALTER TRIGGER ""JXWMS"".""TRG_T400_HIS"" ENABLE"
"JXWMS","TRG_T_DESTROYMESSAGE","WMS_OUT_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_DESTROYMESSAGE"" 
  after update of DESTROYSTATUS on wms_out_order
  for each row

declare queueid number;

begin

      if nvl(:old.DESTROYSTATUS,0) <> :new.DESTROYSTATUS and :new.DESTROYSTATUS=1  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 49,
                 :new.outid,
                 null,
                 null,
                 queueid);

      end if;
  end ;




ALTER TRIGGER ""JXWMS"".""TRG_T_DESTROYMESSAGE"" ENABLE"
"JXWMS","TRG_T_GSP_CONSERVE","GSP_CONSERVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_GSP_CONSERVE"" 
  after update of usestatus on gsp_conserve
  for each row
  
declare p number;
begin
    
      if nvl(:old.usestatus,0) <> :new.usestatus and :old.goodsownerid in (340,520) and :new.usestatus=2 then
      
      select tpl_edi_queue_seq.nextval into p from dual;
-- usestatus 1.临时 2.确定
        insert into tpl_edi_queue
          values (:old.goodsownerid,
                 sysdate,
                 47,
                 :old.conserveid,
                 null,
                 null,
                 p);
            
      end if;
  end ;




ALTER TRIGGER ""JXWMS"".""TRG_T_GSP_CONSERVE"" ENABLE"
"JXWMS","TRG_T_GSP_PHYSIC_QUALITY_CHECK","WMS_IN_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_GSP_PHYSIC_QUALITY_CHECK"" 
  after update of usestatus on wms_in_order
  for each row

declare queueid number;

begin

      if nvl(:old.usestatus,0) <> :new.usestatus and :old.goodsownerid in (520) and :new.usestatus=3  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 48,
                 :old.inid,
                 null,
                 null,
                 queueid);

      end if;
  end ;




ALTER TRIGGER ""JXWMS"".""TRG_T_GSP_PHYSIC_QUALITY_CHECK"" ENABLE"
"JXWMS","TRG_T_GSP_QUALITY_FEEDBACK","GSP_QUALITY_FEEDBACK","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_GSP_QUALITY_FEEDBACK"" 
  after update of usestatus on gsp_quality_feedback
  for each row

declare queueid number;

begin

      if nvl(:old.usestatus,0) <> :new.usestatus  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 45,
                 :new.FEEDBACKID,
                 null,
                 null,
                 queueid);

      end if;
  end ;




ALTER TRIGGER ""JXWMS"".""TRG_T_GSP_QUALITY_FEEDBACK"" ENABLE"
"JXWMS","TRG_T_GSP_RECHECKWMS_HIS","T_GSP_QUALITY_RECHECK_WMS","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_GSP_RECHECKWMS_HIS"" 
  BEFORE DELETE ON T_GSP_QUALITY_RECHECK_WMS
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
BEGIN
insert into T_GSP_QUALITY_RECHECK_WMS_HIS t
(
     t.feedbackid,
     t.credate,
     t.goodsownerid,
     t.wtfqualitydeptidea,
     t.wtfrelatedeptidea,
     t.dealresult,
     t.del_date,
     t.impflag
       )
       values
     (
     :old.feedbackid,
     :old.credate,
     :old.goodsownerid,
     :old.wtfqualitydeptidea,
     :old.wtfrelatedeptidea,
     :old.dealresult,
     sysdate,
     :old.impflag
       );

end;




ALTER TRIGGER ""JXWMS"".""TRG_T_GSP_RECHECKWMS_HIS"" ENABLE"
"JXWMS","TRG_T_SHGL","WMS_IN_ORDER_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_T_SHGL"" 
  after update of shdate on wms_in_order_dtl
  for each row
begin
    
      if nvl(:old.shdate,to_date('1900-01-01','yyyy-mm-dd')) <> :new.shdate  then

        insert into tpl_edi_queue
          select t.goodsownerid,
                 sysdate,
                 44,
                 :old.inid,
                 null,
                 null,
                 tpl_edi_queue_seq.nextval
            from wms_in_order t
           where t.inid = :old.inid and t.goodsownerid in (340,520) ;
      end if;
  end ;




ALTER TRIGGER ""JXWMS"".""TRG_T_SHGL"" ENABLE"
"JXWMS","TRG_WMS_GOODSGROUP_TMP_HIS","WMS_GOODSGROUP_ORDER_TMP","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_WMS_GOODSGROUP_TMP_HIS"" 
  BEFORE DELETE ON WMS_GOODSGROUP_ORDER_TMP
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into WMS_GOODSGROUP_ORDER_TMP_HIS
    (seqid,
     WAREHID,
     GOODSOWNERID,
     CREDATE,
     ERPDOCID,
     ERPDTLID,
     OPERATIONTYPE,
     INPUTMANID,
     INPUTMANNAME,
     GROUPID,
     MEMO,
     DTLLINES,
     GSTORAGEID,
     GOODSID,
     tradepackname,
     packname,
     PACKSIZE,
     BATCHNO,
     LOTNO,
     VALIDDATE,
     PRODDATE,
     APPROVEDOCNO,
     GOODSSTATUSID,
     QUANTITYSTATUS,
     GOODSQTY,
     DTLMEMO,
     IMPFLAG,
     COMPANYSTYLE,
     GCOMPANYID,
     DEL_DATE)
  VALUES
    (:OLD.seqid,
     :OLD.WAREHID,
     :OLD.GOODSOWNERID,
     :OLD.CREDATE,
     :OLD.ERPDOCID,
     :OLD.ERPDTLID,
     :OLD.OPERATIONTYPE,
     :OLD.INPUTMANID,
     :OLD.INPUTMANNAME,
     :OLD.GROUPID,
     :OLD.MEMO,
     :OLD.DTLLINES,
     :OLD.GSTORAGEID,
     :OLD.GOODSID,
     :OLD.tradepackname,
     :OLD.packname,
     :OLD.PACKSIZE,
     :OLD.BATCHNO,
     :OLD.LOTNO,
     :OLD.VALIDDATE,
     :OLD.PRODDATE,
     :OLD.APPROVEDOCNO,
     :OLD.GOODSSTATUSID,
     :OLD.QUANTITYSTATUS,
     :OLD.GOODSQTY,
     :OLD.DTLMEMO,
     :OLD.IMPFLAG,
     :OLD.COMPANYSTYLE,
     :OLD.GCOMPANYID,
     SYSDATE);
END;




ALTER TRIGGER ""JXWMS"".""TRG_WMS_GOODSGROUP_TMP_HIS"" ENABLE"
"JXWMS","TRG_WMS_HIS_PATCH","WMS_BOX_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_WMS_HIS_PATCH"" 
  after update on wms_box_dtl
  for each row
     begin
  --当修改装箱单总单时删除医院收货服务单。
  if :old.docid <> :new.docid then
    delete from wms_his_patch t
    where exists(select 1 from wms_turnbox_to_box_rel t1
                                  where t.inoutid=t1.inoutid
                                  and t1.boxdtlid = :new.dtlid );
   end if;
end trg_wms_his_patch;




ALTER TRIGGER ""JXWMS"".""TRG_WMS_HIS_PATCH"" ENABLE"
"JXWMS","TRG_WMS_LOT_MODIFY_LST","WMS_LOT_MODIFY_LST","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_WMS_LOT_MODIFY_LST"" 
after INSERT OR UPDATE
ON wms_lot_modify_lst
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
 
        declare
  num1 number;
BEGIN
  select count(*)
  into num1
  from tpl_goods a where a.waregoodsid=:new.goodsid and a.goodsownerid=2;

  if :new.usestatus=2 and num1 > 0 then
  insert into tpl_edi_queue(goodsownerid,credate,queuetype,srcid,seqid)
  values(2,sysdate,5,:new.modifyid,tpl_edi_queue_seq.nextval);
  end if;
END;




ALTER TRIGGER ""JXWMS"".""TRG_WMS_LOT_MODIFY_LST"" ENABLE"
"JXWMS","TRG_WMS_TO_DPS","WMS_TO_DPS","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_WMS_TO_DPS"" 
before delete
on wms_to_dps
 begin
insert into wms_to_dps_bak  select * from wms_to_dps;
end;




ALTER TRIGGER ""JXWMS"".""TRG_WMS_TO_DPS"" ENABLE"
"JXWMS","TRG_ZX_PURCHASE_INVNO_HIS","ZX_PURCHASE_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_ZX_PURCHASE_INVNO_HIS"" 
  BEFORE DELETE ON ZX_PURCHASE_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into ZX_PURCHASE_INVNO_his
    (goodsownerid,
     suconid,
     sucondtlid,
     invcode,
     invno,
     invdate,
     credate,
     del_date,
     seqid)
  values
    (:old.goodsownerid,
     :old.suconid,
     :old.sucondtlid,
     :old.invcode,
     :old.invno,
     :old.invdate,
     :old.credate,
     sysdate,
     :old.seqid);
end;

ALTER TRIGGER ""JXWMS"".""TRG_ZX_PURCHASE_INVNO_HIS"" ENABLE"
"JXWMS","TRG_ZX_SALES_INVNO_HIS","ZX_SALES_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_ZX_SALES_INVNO_HIS"" 
  BEFORE DELETE ON ZX_SALES_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

--change by xyue 2017-11-28 增加发票代码字段
BEGIN
  insert into ZX_SALES_INVNO_his
    (salesdtlid,
     invno,
     seqid,
     goodsownerid,
     salesid,
     INVCODE,
     invoaddress,
     cre_date,
     del_date)
  values
    (:old.salesdtlid,
     :old.invno,
     :old.seqid,
     :old.goodsownerid,
     :old.salesid,
     :old.INVCODE,
     :old.invoaddress,
     :old.cre_date,
     sysdate);
end;




ALTER TRIGGER ""JXWMS"".""TRG_ZX_SALES_INVNO_HIS"" ENABLE"
"JXWMS","TRG_ZX_SALES_INVNO_WB_HIS","ZX_SALES_INVNO_WB","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TRG_ZX_SALES_INVNO_WB_HIS"" 
  BEFORE DELETE ON ZX_SALES_INVNO_WB
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into ZX_SALES_INVNO_WB_his
    (salesdtlid,
     invno,
     seqid,
     goodsownerid,
     salesid,
     INVCODE,
     del_date,
     credate)
  values
    (:old.salesdtlid,
     :old.invno,
     :old.seqid,
     :old.goodsownerid,
     :old.salesid,
     :old.INVCODE,
     sysdate,
     :old.credate);
end;



ALTER TRIGGER ""JXWMS"".""TRG_ZX_SALES_INVNO_WB_HIS"" ENABLE"
"JXWMS","TR_GSP_QUALITY_FEEDBACK","WMS_TRADE_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TR_GSP_QUALITY_FEEDBACK"" 
  after update of usestatus
  on wms_trade_order
  for each row

begin

      if :old.usestatus <> :new.usestatus and :new.usestatus = 3 and :new.operationtype in (24, 31)
      and :old.goodsownerid = 340 then

        insert into gsp_quality_feedback a
          (a.feedbackid,
           a.goodsid,
           a.goodsqty,
           a.lotid,
           a.inputmanid,
           a.credate,
           a.goodsownerid,
           a.warehid,
           a.ownergoodsid,
           a.goodssituation,
           a.comefrom,
           a.tradeid)
          select gsp_quality_feedback_seq.nextval,
                 t.goodsid,
                 t.qty,
                 t.tolotid,
                 :new.inputmanid,
                 :new.tradedate,
                 :new.goodsownerid,
                 :new.warehid,
                 t.ownergoodsid,
                 t.dtlmemo,
                 :new.operationtype,
                 t.tradeid
            from wms_trade_dtl t
           where t.tradeid = :old.tradeid
             and t.togoodsstatusid = 8;
      end if;

end tr_gsp_quality_feedback;




ALTER TRIGGER ""JXWMS"".""TR_GSP_QUALITY_FEEDBACK"" ENABLE"
"JXWMS","TR_WMS_TRADE_ORDER_U","WMS_TRADE_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TR_WMS_TRADE_ORDER_U"" 
  after update of usestatus
  on wms_trade_order
  for each row
begin

      if :old.usestatus <> :new.usestatus and :new.usestatus = 3 and :new.operationtype in (24, 31) then
        --select * From GSP_goods_Unqualified
        --select * From wms_trade_order a,wms_trade_order_dtl
        --select * from wms_trade_dtl
        insert into gsp_goods_unqualified
          select gsp_goods_unqualified_seq.nextval,
                 goodsid,
                 t.goodspackid,
                 0,
                 t.tolotid,
                 t.toposid,
                 t.qty,
                 t.dtlmemo,
                 '',
                 '',
                 :new.goodsownerid,
                 :old.tradedate,
                 :old.inputmanid,
                 '',
                 '',
                 0,
                 '',
                 t.tradedtlid,
                 t.ownergoodsid,
                 :old.warehid,
                 t.togoodsstatusid,
                 0 usestatus
            from wms_trade_dtl t
            --wms_trade_order tt
           where t.tradeid = :old.tradeid
             --and t.tradeid = tt.tradeid
             and t.togoodsstatusid = 3;
      end if;

end tr_wms_trade_order_u;





ALTER TRIGGER ""JXWMS"".""TR_WMS_TRADE_ORDER_U"" ENABLE"
"JXWMS","TR_ZX_TWOBOXING_DEL","ZX_TWOBOXING","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TR_ZX_TWOBOXING_DEL"" 
after delete
on zx_twoboxing
FOR EACH ROW

begin
update wms_container_def t set t.usestatus = 1 where t.containerid =:new.wboxid;

end;




ALTER TRIGGER ""JXWMS"".""TR_ZX_TWOBOXING_DEL"" DISABLE"
"JXWMS","TR_ZX_TWOBOXING_UPDATE","ZX_TWOBOXING","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""TR_ZX_TWOBOXING_UPDATE"" 
after INSERT
on zx_twoboxing
FOR EACH ROW

begin
update wms_container_def t set t.usestatus = 2 where t.containerid =:new.wboxid;

end;




ALTER TRIGGER ""JXWMS"".""TR_ZX_TWOBOXING_UPDATE"" DISABLE"
"JXWMS","T_TMP_ZH_TJB","TMP_ZH_TJB","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""T_TMP_ZH_TJB"" 
before insert on  tmp_zh_tjb
for each row
begin
select tmp_zh_tjb_seq.nextval into :new.zxid from dual;
end t_tmp_zh_tjb;




ALTER TRIGGER ""JXWMS"".""T_TMP_ZH_TJB"" ENABLE"
"JXWMS","T_WCS_TO_WMS_BOXBIND_TRG","T_WCS_TO_WMS_BOXBIND","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""T_WCS_TO_WMS_BOXBIND_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_BOXBIND
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_BOXBIND_BAK
    (WAREHID,
    TASKID,
    BOXBARCODE,
    LTIME,
    DELDATE)
  VALUES
    (:OLD.WAREHID,
    :OLD.TASKID,
    :OLD.BOXBARCODE,
    :OLD.LTIME,
    SYSDATE);
END;




ALTER TRIGGER ""JXWMS"".""T_WCS_TO_WMS_BOXBIND_TRG"" ENABLE"
"JXWMS","T_WCS_TO_WMS_DZBQFINISH_TRG","T_WCS_TO_WMS_DZBQFINISH","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""T_WCS_TO_WMS_DZBQFINISH_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_DZBQFINISH
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_DZBQFINISH_BAK
    (DELDATE,
     BOXBARCODE,
     LOC,
     QTY,
     LTIME,
     WMSWORKTYPE,
     WAREHID,
     WMSSERIALKEY)
  VALUES
    (SYSDATE,
     :OLD.BOXBARCODE,
     :OLD.LOC,
     :OLD.QTY,
     :OLD.LTIME,
     :OLD.WMSWORKTYPE,
     :OLD.WAREHID,
     :OLD.WMSSERIALKEY);
END;




ALTER TRIGGER ""JXWMS"".""T_WCS_TO_WMS_DZBQFINISH_TRG"" ENABLE"
"JXWMS","T_WCS_TO_WMS_WORKFINISH_TRG","T_WCS_TO_WMS_WORKFINISH","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""T_WCS_TO_WMS_WORKFINISH_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_WORKFINISH
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_WORKFINISH_BAK
    (WAREHID,
     WMSWORKINDEX,
     WMSWORKTYPE,
     PALLETID,
     RETURNCODE,
     RETURNDESCR,
     LTIME,
     DELDATE)
  VALUES
    (:OLD.WAREHID,
     :OLD.WMSWORKINDEX,
     :OLD.WMSWORKTYPE,
     :OLD.PALLETID,
     :OLD.RETURNCODE,
     :OLD.RETURNDESCR,
     :OLD.LTIME,
     SYSDATE);
END;




ALTER TRIGGER ""JXWMS"".""T_WCS_TO_WMS_WORKFINISH_TRG"" ENABLE"
"JXWMS","WCS_DEVICE_GOODS_IN_TRG","WCS_DEVICE_GOODS_IN","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""WCS_DEVICE_GOODS_IN_TRG"" 
  after update of usestatus
  on wcs_device_goods_in
  for each row

declare
  v_count number;--计数
  v_newqty number; --更新后库存

begin
  --入库单由【临时】->【正式】,先按goodsid查库存表是否存在,存在就数量叠加,不存在就新增一条库存记录
  if :new.usestatus = 1 then 
    select count(1)
      into v_count
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_count<>0 then
      update wcs_device_goods_qty t
         set t.goodsqty = t.goodsqty + :new.goodsqty
       where t.goodsid = :new.goodsid;
    else
      insert into wcs_device_goods_qty
        (goodsid, goodsqty)
      values
        (:new.goodsid, :new.goodsqty);
    end if;
  end if;
  
  --入库单回退确定由【正式】->【临时】,先按goodsid查库存表扣减库存，扣减出现负数就报错
  --扣减完成后库存数量为0,则删除记录
  if nvl(:new.usestatus,0) = 0 then 
    select nvl(max(t.goodsqty), 0) - :new.goodsqty
      into v_newqty
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_newqty > 0 then 
      update wcs_device_goods_qty t
         set t.goodsqty = v_newqty
       where t.goodsid = :new.goodsid;
    elsif v_newqty = 0 then --更新后库存为0 删除库存表记录
      delete wcs_device_goods_qty t where t.goodsid = :new.goodsid;
    else
      Raise_Application_Error(-20001,'回退确定后该货品库存数量小于0,不允许回退!');
    end if;  
  end if;
  
end wcs_device_goods_in_trg;



ALTER TRIGGER ""JXWMS"".""WCS_DEVICE_GOODS_IN_TRG"" ENABLE"
"JXWMS","WCS_DEVICE_GOODS_OUT_TRG","WCS_DEVICE_GOODS_OUT","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""WCS_DEVICE_GOODS_OUT_TRG"" 
  after update of usestatus
  on wcs_device_goods_out
  for each row

declare
  v_count number;--计数
  v_newqty number; --更新后库存

begin
  --出库单确定由【正式】->【临时】,先按goodsid查库存表扣减库存，扣减出现负数就报错
  --扣减完成后库存数量为0,则删除记录
  if nvl(:new.usestatus,0) = 1 then 
    select nvl(max(t.goodsqty), 0) - :new.goodsqty
      into v_newqty
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_newqty > 0 then 
      update wcs_device_goods_qty t
         set t.goodsqty = v_newqty
       where t.goodsid = :new.goodsid;
    elsif v_newqty = 0 then --更新后库存为0 删除库存表记录
      delete wcs_device_goods_qty t where t.goodsid = :new.goodsid;
    else
      Raise_Application_Error(-20001,'出库单确定后该货品库存数量小于0,不允许确定!请检查库存数量!');
    end if;  
  end if;
  
  --出库单由【正式】->【临时】,先按goodsid查库存表是否存在,存在就数量叠加,不存在就新增一条库存记录
  if nvl(:new.usestatus,0) = 0 then 
    select count(1)
      into v_count
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_count<>0 then
      update wcs_device_goods_qty t
         set t.goodsqty = t.goodsqty + :new.goodsqty
       where t.goodsid = :new.goodsid;
    else
      insert into wcs_device_goods_qty
        (goodsid, goodsqty)
      values
        (:new.goodsid, :new.goodsqty);
    end if;
  end if;  
end wcs_device_goods_out_trg;



ALTER TRIGGER ""JXWMS"".""WCS_DEVICE_GOODS_OUT_TRG"" ENABLE"
"JXWMS","ZX_710030_INCEPTADDR_TRG","ZX_710030_INCEPTADDR","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_710030_INCEPTADDR_TRG"" before insert on zx_710030_inceptaddr for each row
begin
select zx_710030_inceptaddr_seq.nextval into :new.zxid from dual;
end;




ALTER TRIGGER ""JXWMS"".""ZX_710030_INCEPTADDR_TRG"" ENABLE"
"JXWMS","ZX_710030_TRG","ZX_710030","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_710030_TRG"" before insert on zx_710030 for each row
begin
select zx_710030_seq.nextval into :new.zxid from dual;
end;




ALTER TRIGGER ""JXWMS"".""ZX_710030_TRG"" ENABLE"
"JXWMS","ZX_710031_TRG","ZX_710031","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_710031_TRG"" before insert on zx_710031 for each row
begin
select zx_710031_seq.nextval into :new.zxid from dual;
end;




ALTER TRIGGER ""JXWMS"".""ZX_710031_TRG"" ENABLE"
"JXWMS","ZX_710037_TRG","ZX_710037","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_710037_TRG"" 
before insert on zx_710037  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_710037_seq.nextval into :new.zxid from dual;
end;




ALTER TRIGGER ""JXWMS"".""ZX_710037_TRG"" ENABLE"
"JXWMS","ZX_RK_WMS_TRADE_DTL_TRI","WMS_TRADE_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_RK_WMS_TRADE_DTL_TRI"" 
after UPDATE
ON WMS_Trade_Dtl
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW

    
declare
--v_prtclass varchar2(100);
p_executype number(12);
p_userstatus number(12);
p_packsize number(12);
p_wholeqty number(12);
p_exist number(2);
BEGIN
---算出上下架分开的
select t1.executetype
into p_executype
from wms_trade_order t1
where  t1.tradeid = :new.tradeid;
p_userstatus:=:new.USESTATUS;
select count(*) into p_exist from zx_WMS_Trade_Dtl where tradedtlid = :new.tradedtlid;
   --在生成整件波次出库的出入库明细时，生成10件以下的标签数

 if nvl(p_executype,0) = 2 and nvl(p_userstatus,0) = 2 and nvl(p_exist,0) = 0 then ---补货、上下架分开执行
       -----取包装大小。
       select packsize
       into p_packsize
       from tpl_pub_goods_packs
       where goodspackid = :new.goodspackid ;
       -----取出件数。
       if nvl(p_packsize,0) <> 0 then
          p_wholeqty := ceil(:new.qty/p_packsize);
       else
          p_wholeqty := 1;
       end if;

       if (nvl(p_wholeqty,0)>=1 and nvl(p_wholeqty,0)<10)then    --超过10件只打印一张，低于10件的才打印对应件数的标签数量
         for i in 1..p_wholeqty loop
         insert into zx_WMS_Trade_Dtl(ZXTRADEID,TRADEDTLID,printflag,seqno,wholeqty)
                values(zx_WMS_Trade_Dtl_SEQ.NEXTVAL,:new.tradedtlid,0,i,p_wholeqty);
 /*                  commit;*/
         end loop;
       else
                insert into zx_WMS_Trade_Dtl(ZXTRADEID,TRADEDTLID,printflag,seqno,wholeqty)
                values(zx_WMS_Trade_Dtl_SEQ.NEXTVAL,:new.tradedtlid,0,p_wholeqty,p_wholeqty);
                /* commit;*/
       end if;

 end if;


 end ;




ALTER TRIGGER ""JXWMS"".""ZX_RK_WMS_TRADE_DTL_TRI"" ENABLE"
"JXWMS","ZX_TRG_WMS_CANCEL_IN","WMS_CANCEL_JOB_LST","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_TRG_WMS_CANCEL_IN"" 
  after insert  on WMS_CANCEL_JOB_LST
for each row

begin
  if :new.goodsownerid=520 and :new.operationtype in (1,7) and :new.jobcancelstatus=2  then
      p_trg_wms_cancel_in(:new.jobid,:new.jobdtlid);
  end if;

end zx_trg_wms_cancel_in;




ALTER TRIGGER ""JXWMS"".""ZX_TRG_WMS_CANCEL_IN"" ENABLE"
"JXWMS","ZX_WMS_IN_ORDER_DTL_MF1_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF1_TRG"" 
  before update of memoflaga on wms_in_order_dtl
  for each row 
    WHEN (new.memoflaga=1) begin
  :new.memoa:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf1_trg;




ALTER TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF1_TRG"" ENABLE"
"JXWMS","ZX_WMS_IN_ORDER_DTL_MF2_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF2_TRG"" 
  before update of memoflagb on wms_in_order_dtl
  for each row     WHEN (new.memoflagb=1) begin
  :new.memob:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf2_trg;




ALTER TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF2_TRG"" ENABLE"
"JXWMS","ZX_WMS_IN_ORDER_DTL_MF3_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF3_TRG"" 
  before update of memoflagc on wms_in_order_dtl
  for each row     WHEN (new.memoflagc=1) begin
  :new.memoc:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf3_trg;




ALTER TRIGGER ""JXWMS"".""ZX_WMS_IN_ORDER_DTL_MF3_TRG"" ENABLE"
"JXWMS","ZX_WMS_OUT_ORDER_TRI","WMS_OUT_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_WMS_OUT_ORDER_TRI"" 
after update of wavedtlid
ON wms_out_order
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
   WHEN (old.autopassflag=1) begin
  if nvl(:new.wavedtlid,0)<>0 and :new.autopassflag=1 then
  update wms_wave_dtl t
     set t.autopassflag    = :new.autopassflag,
         t.togoodsownerid  = :new.togoodsownerid,
         t.to_expcompanyid = :new.to_expcompanyid,
         t.to_addressid    = :new.to_addressid
   where t.wavedtlid = :new.wavedtlid;
  end if;
end;



ALTER TRIGGER ""JXWMS"".""ZX_WMS_OUT_ORDER_TRI"" ENABLE"
"JXWMS","ZX_WMS_ST_IO_DOC_TRI","WMS_ST_IO_DOC","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""JXWMS"".""ZX_WMS_ST_IO_DOC_TRI"" 
after INSERT
ON wms_st_io_doc
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
/*************************************************************/
/*  中文名称：出入库明细                                      */
/*  功能描述：在整件出库标签的打印时货位上不同的出库件数        */
/*              打印的标签数有所不同。                         */
/*  编写人：wanghuaiyu      编写时间：20130622                  */
/*  修改人：      修改时间：                                    */
/**************************************************************/
declare
  v_autoprtparam number(1);--标签打印件数上限
  v_wholeqty number(8);--整件数量
  v_prtperpackflag number(1);--每箱打印出库标签

BEGIN
  if :new.comefrom = 3 then
    --查询出拣货工作区定义中的""标签打印件数上限""
    select nvl(b.autoprtparam,0),nvl(b.prtperpackflag, 0) 
      into v_autoprtparam,v_prtperpackflag
      from wms_pickarea b
     where b.pickareaid = nvl(:new.pickareaid,0);
    v_wholeqty := :new.wholeqty;--整件数量
    if nvl(v_wholeqty,0) > 0 then
      --如果“每箱打印出库标签”没有选上，即值不等于 1，只插入一条记录
      if(v_prtperpackflag <> 1) then
         insert into zx_out_label_print(seqid, inoutid, labelseq, wholeqty, credate)
          values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, v_wholeqty, v_wholeqty, sysdate);
      --如果选择了“每箱打印出库标签”，即值等于1
      elsif(v_prtperpackflag = 1)then
        --如果 "" 标签打印件数上限 "" 为空或 0 
        if(v_autoprtparam = 0) then
          insert into zx_out_label_print(seqid, inoutid, labelseq, wholeqty, credate)
          values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, v_wholeqty, v_wholeqty, sysdate);
        --如果 "" 标签打印件数上限 "" 不为空或者0 ，且大于整件数量，插入整件数量条记录
        elsif(v_autoprtparam >= v_wholeqty) then
          for i in 1 .. v_wholeqty loop
            insert into zx_out_label_print(seqid,inoutid,labelseq,wholeqty,credate)
            values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, i, v_wholeqty,sysdate);
          end loop;
        --如果整件数量大于"" 标签打印件数上限 "" ,插入5 条记录
        elsif(nvl(v_wholeqty, 0) > v_autoprtparam) then
        	for i in 1 .. v_autoprtparam loop
            insert into zx_out_label_print(seqid,inoutid,labelseq,wholeqty,credate)
            values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, i, v_wholeqty,sysdate);
          end loop;
        end if;
      end if;
    end if;
  end if;
end;




ALTER TRIGGER ""JXWMS"".""ZX_WMS_ST_IO_DOC_TRI"" ENABLE"
"LYERP","BMS_CERT_DOC_UPDATE_TRI","BMS_CERT_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_CERT_DOC_UPDATE_TRI"" 
  Before Update Of Usestatus On Bms_Cert_Doc
  For Each Row
Declare
  v_Count Number;
Begin
  Select Count(1)
    Into v_Count
    From (Select Certid
            From Bms_Acc_Doc t
           Where t.Certid = :Old.Certid
          Union All
          Select Certid
            From Bms_Sk_Io_Doc t
           Where t.Certid = :Old.Certid);

  If v_Count > 0 And :New.Usestatus = 0 Then
    :New.Usestatus := 1;
  End If;
End Bms_Cert_Doc_Update_Tri;


ALTER TRIGGER ""LYERP"".""BMS_CERT_DOC_UPDATE_TRI"" ENABLE"
"LYERP","BMS_CUS_DISCOUNT_DEF_TRI","BMS_CUS_DISCOUNT_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_CUS_DISCOUNT_DEF_TRI"" 
  before insert or update on bms_cus_discount_def
for each row
     begin
  :new.invalidenddate:=to_date(to_char(:new.invalidenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end bms_cus_discount_def_tri;


ALTER TRIGGER ""LYERP"".""BMS_CUS_DISCOUNT_DEF_TRI"" ENABLE"
"LYERP","BMS_DISCOUNT_FORBIDGDS_TRI","BMS_DISCOUNT_FORBIDGDS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_DISCOUNT_FORBIDGDS_TRI"" 
  before insert or update on bms_discount_forbidgds
for each row
     begin
  :new.invalidenddate:=to_date(to_char(:new.invalidenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end bms_discount_forbidgds_tri;


ALTER TRIGGER ""LYERP"".""BMS_DISCOUNT_FORBIDGDS_TRI"" ENABLE"
"LYERP","BMS_DISCTYPE_DISCOUNT_DEF_TRI","BMS_DISCTYPE_DISCOUNT_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_DISCTYPE_DISCOUNT_DEF_TRI"" 
  before insert or update on BMS_DISCTYPE_DISCOUNT_DEF
for each row
     begin
  :new.invalidenddate:=to_date(to_char(:new.invalidenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end BMS_DISCTYPE_DISCOUNT_DEF_TRI;


ALTER TRIGGER ""LYERP"".""BMS_DISCTYPE_DISCOUNT_DEF_TRI"" ENABLE"
"LYERP","BMS_MV_DTL_TRI","BMS_MV_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_MV_DTL_TRI"" 
  before insert on bms_mv_dtl for each row
declare
  v_count number(1); --判断是否是同一存货帐
  v_flag  number(1);
begin
  v_flag := 0;
  if inserting then

    select count(distinct a.stockid)
      into v_count
      from bms_sk_to_st a
     where exists (select 1
              from bms_mv_doc b
             where (a.storageid = b.fromstorageid or
                   a.storageid = b.tostorageid)
               and b.moveid = :NEW.moveid)
       and exists (select 1
              from bms_st_def t
             where a.storageid = t.storageid
               and t.entryid = 600);
    /*if (v_count = 1 and :NEW.costcalcflag=0) then
      v_flag :=1;
    end if;*/
    if (v_count = 2 and :NEW.costcalcflag = 1) then
      v_flag := 1;
    end if;

    if (v_flag = 1) then
      raise_application_error(-20001,
                              v_count || '成本计算方式选择错误，请确认！' ||
                              v_flag);
    end if;
  end if;
end bms_mv_dtl_tri;


ALTER TRIGGER ""LYERP"".""BMS_MV_DTL_TRI"" ENABLE"
"LYERP","BMS_SA_INV_INFO_TRI","BMS_SA_INV_INFO","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_SA_INV_INFO_TRI"" 
  before update or insert on bms_sa_inv_info
  for each row
declare
  v_count number(2);
  ---修改判断逻辑20220707
begin
  if inserting then
    select count(1)
      into v_count
      from dual
     where :NEW.companyfunction = 1
       and not REGEXP_LIKE(:NEW.accno, '^([0-9]+)$');
  end if;
  if updating('accno') then
    select count(1)
      into v_count
      from dual
     where :OLD.companyfunction = 1
       and not REGEXP_LIKE(:NEW.accno, '^([0-9]+)$');
  end if;
  if (v_count > 0) then
    raise_application_error(-20001, '账号存在非数字的数字！' || v_count);
  end if;

end;

ALTER TRIGGER ""LYERP"".""BMS_SA_INV_INFO_TRI"" ENABLE"
"LYERP","BMS_ST_ADJUST_TRI","BMS_ST_ADJUST","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_ST_ADJUST_TRI"" 
  Before Update On Bms_St_Adjust
  For Each Row


Begin

  If :New.Checkmanid = :New.Adjustmanid Then
    Raise_Application_Error(-20001, '复核人不能跟拆零人一样');

  End If;

End Bms_St_Adjust_Tri;


ALTER TRIGGER ""LYERP"".""BMS_ST_ADJUST_TRI"" ENABLE"
"LYERP","BMS_ST_RE_DOC_TRI","BMS_ST_RE_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_ST_RE_DOC_TRI"" 
  before update on bms_st_re_doc
  for each row
declare
  v_count number(1); --收货细单记录数
  v_count1 number(1);

begin
 --来货数量与订货数量的波动范围：1吨以下的控制在±10%以内；1吨以上5吨以下的控制在±5%以内；5吨以上控制在±2%以内
  if :OLD.entryid=64 and :NEW.usestatus=2 and :OLD.rgtype=1 then
    select count(1) into v_count
    from (select a.sucondtlid, sum(a.goodsqty) regoodsqty
            from bms_st_re_dtl a, bms_su_con_dtl b
           where a.reid = :OLD.Entryid
             and a.sucondtlid = b.sucondtlid
             and b.goodsqty > 1000
             and b.goodsqty <= 5000
           group by a.sucondtlid, b.goodsqty
          having sum(a.goodsqty) > b.goodsqty and (sum(a.goodsqty) - nvl(b.goodsqty, 0)) / nvl(b.goodsqty, 1) > 0.05);

    select count(1) into v_count1
    from (select a.sucondtlid, sum(a.goodsqty) regoodsqty
            from bms_st_re_dtl a, bms_su_con_dtl b
           where a.reid = :OLD.Entryid
             and a.sucondtlid = b.sucondtlid
             and b.goodsqty > 5000
           group by a.sucondtlid, b.goodsqty
          having sum(a.goodsqty) > b.goodsqty and (sum(a.goodsqty) - nvl(b.goodsqty, 0)) / nvl(b.goodsqty, 1) > 0.02);
--由于角色授权控制10%，所以小于1吨的不控制
    if ( v_count > 0) then
      raise_application_error(-20001, '1吨以上5吨以下的控制在±5%以内');
    end if;

    if ( v_count1 > 0) then
      raise_application_error(-20001, '5吨以上控制在±2%以内');
    end if;
  end if;

end bms_st_re_doc_tri;

ALTER TRIGGER ""LYERP"".""BMS_ST_RE_DOC_TRI"" ENABLE"
"LYERP","BMS_ST_RE_DTL_TRI","BMS_ST_RE_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_ST_RE_DTL_TRI"" 
  before insert on bms_st_re_dtl
  for each row
declare
  v_count number(1); --收货细单记录数

  v_goodsqty number(16, 6); --插入后的收货总数量

  v_fetchqty number(16, 6); --销退申请的数量
begin
  select count(1), nvl(sum(b.goodsqty), 0) + :NEW.goodsqty
    into v_count, v_goodsqty
    from bms_st_re_doc a, bms_st_re_dtl b
   where a.reid = b.reid
     --and a.entryid in(64,600,550)
     and nvl(a.rgtype,0)=2        
     and b.fetchdtlid = :NEW.fetchdtlid;

  select nvl(sum(t.goodsqty), 0)
    into v_fetchqty
    from bms_tr_fetch_dtl t
   where t.fetchdtlid = :NEW.fetchdtlid;

  if (v_fetchqty > 0 and v_goodsqty > v_fetchqty and v_count >= 1) then
    raise_application_error(-20001, '收货数量大于销退申请数量');
  end if;

end bms_st_re_dtl_tri;


ALTER TRIGGER ""LYERP"".""BMS_ST_RE_DTL_TRI"" ENABLE"
"LYERP","BMS_ST_RG_DOC_TRI","BMS_ST_RG_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_ST_RG_DOC_TRI"" 
before update on bms_st_rg_doc for each row
declare
  v_count number(5);
begin
    -- dbms_output.put_line(:NEW.usestatus);
    --去掉状态为完成，回退采购业务处理，允许回退
 if :OLD.entryid in(64) and :OLD.Usestatus<>3 then
 v_count :=0;
  select count(1) into v_count from bms_st_rg_dtl b,mpcs_gmp_std_goods o, mpcs_gmp_std p
   where o.stdid = p.stdid
   and p.usestatus = 1
   and b.goodsid = o.goodsid
   and p.entryid=:OLD.entryid
  -- and nvl(b.ifcheckflag,0)=1
   and b.GOODSQTY<>nvl(b.eligibgoodsqty,0)--modify bygkm20230620将大于修改成不等于
   and b.goodsstatusid=1--add by gkm20230620
   and :NEW.usestatus=2
   and :OLD.rgtype=1
   and :OLD.entryid in(64)
   and b.rgid=:OLD.rgid;

  if (v_count>0) then
     raise_application_error(-20001, '入库数量不等于放行数量!');
  end if;
  end if;
end;


ALTER TRIGGER ""LYERP"".""BMS_ST_RG_DOC_TRI"" ENABLE"
"LYERP","BMS_SU_CON_DTL_TRI","BMS_SU_CON_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_SU_CON_DTL_TRI"" 
  before update of usestatus on bms_su_con_dtl
  for each row
declare
  v_count number(1);
begin
  --用于防止有收货细单，还能作废。
  if :NEW.usestatus = 0 then
    select count(1)
      into v_count
      from bms_st_re_dtl t
     where t.sucondtlid = :OLD.sucondtlid;
    if v_count > 0 then
      raise_application_error(-20001, '有收货单！请先删除再作废');
    end if;
  end if;
end bms_su_con_dtl_tri;


ALTER TRIGGER ""LYERP"".""BMS_SU_CON_DTL_TRI"" ENABLE"
"LYERP","BMS_SU_PROT_GOODS_DOC_TRI","BMS_SU_PROT_GOODS_DOC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_SU_PROT_GOODS_DOC_TRI"" 
  before insert or update on bms_su_prot_goods_doc
for each row
     begin
  :new.enddate:=to_date(to_char(:new.enddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end bms_su_prot_goods_doc_tri;


ALTER TRIGGER ""LYERP"".""BMS_SU_PROT_GOODS_DOC_TRI"" ENABLE"
"LYERP","BMS_SU_PROT_TOTAL_TRI","BMS_SU_PROT_TOTAL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_SU_PROT_TOTAL_TRI"" 
  before insert or update on bms_su_prot_total
for each row
     begin
  :new.enddate:=to_date(to_char(:new.enddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end bms_su_prot_total_tri;


ALTER TRIGGER ""LYERP"".""BMS_SU_PROT_TOTAL_TRI"" ENABLE"
"LYERP","BMS_SU_SET_DOC_TRI","BMS_SU_SET_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_SU_SET_DOC_TRI"" 
  before update of printflag on bms_su_set_doc
  referencing old as old new as new
  for each row
  
declare
 pragma autonomous_transaction;
begin

  update bms_su_doc
     set printflag  = printflag + 1,
         printmanid = :new.printmanid,
         printdate  = sysdate
   where sudocid = :old.susetdocid;
 commit;
end bms_su_set_doc_tri;


ALTER TRIGGER ""LYERP"".""BMS_SU_SET_DOC_TRI"" DISABLE"
"LYERP","BMS_TRANSCONTROL_DOC_TRI","BMS_TRANSCONTROL_DOC","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_TRANSCONTROL_DOC_TRI"" 
  after update on Bms_transcontrol_doc
  for each row

begin
  --用于处理2053回退确认，5075的记录没有删除的问题
  if :NEW.usestatus=2 and :OLD.usestatus=1 then
    delete from gsp_transcontrol_record a where a.roadid=:OLD.roadid and a.entryid=:OLD.Entryid;
  end if;
end;

ALTER TRIGGER ""LYERP"".""BMS_TRANSCONTROL_DOC_TRI"" ENABLE"
"LYERP","BMS_TR_BACK_DELETE_TRI","BMS_TR_DTL","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_TR_BACK_DELETE_TRI"" 
  after delete on bms_tr_dtl
  for each row


          begin

    insert into BMS_TR_BACK_TRIGGER
      (seqid, credate, type, Trdtlid, comefrom,sourceid)
    select Bms_tr_back_seq.Nextval,sysdate,'2',:old.trdtlid,comefrom,sourceid from bms_tr_doc where trid = :old.trid;

end bms_tr_back_tri;


ALTER TRIGGER ""LYERP"".""BMS_TR_BACK_DELETE_TRI"" ENABLE"
"LYERP","BMS_TR_BACK_INSERT_TRI","BMS_TR_DTL","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_TR_BACK_INSERT_TRI"" 
  after insert on bms_tr_dtl
  for each row


          begin

    insert into BMS_TR_BACK_TRIGGER
      (seqid, credate, type, Trdtlid, comefrom,sourceid)
    select Bms_tr_back_seq.Nextval,sysdate,'1',:new.trdtlid,comefrom,sourceid from bms_tr_doc where trid = :new.trid;

end bms_tr_back_tri;


ALTER TRIGGER ""LYERP"".""BMS_TR_BACK_INSERT_TRI"" ENABLE"
"LYERP","BMS_TR_POS_DEF_TRI","BMS_TR_POS_DEF","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""BMS_TR_POS_DEF_TRI"" 
  after insert or update on bms_tr_pos_def
  for each row  WHEN (NEW.entryid=654 and NEW.tranpostype=2) declare
 ctn number(1);
begin
  select count(1) into ctn from pm_edi_queue a where a.goodsownerid=654 and a.srcid=:NEW.tranposid and a.queuetype=6;
  if ctn=0 then
    insert into pm_edi_queue(queueid,goodsownerid,credate,queuetype,srcid)
   select pm_edi_queue_seq.nextval,654,sysdate,6,:NEW.tranposid from dual;
   end if;

end;

ALTER TRIGGER ""LYERP"".""BMS_TR_POS_DEF_TRI"" ENABLE"
"LYERP","COMPANY_READINFO_TRI","PUB_COMPANY","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""COMPANY_READINFO_TRI"" 
  before update of ZX_READDATE on pub_company
  --referencing old as old new as new
  for each row

begin
  --插入读取信息
  delete from GSP_COMPANY_LICENSE_READINFO
   where licenseid = :old.COMPANYID
     and readman = :new.EMPLOYEEID and typeid=2;
  insert into GSP_COMPANY_LICENSE_READINFO
    (licenseid, READMAN, READTIME,typeid)
  values
    (:old.COMPANYID, :new.EMPLOYEEID, :new.zx_readdate,2);
  :new.EMPLOYEEID := :old.EMPLOYEEID;
end ;


ALTER TRIGGER ""LYERP"".""COMPANY_READINFO_TRI"" ENABLE"
"LYERP","GKM_11024_TRI","BMS_ST_IO_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GKM_11024_TRI"" 
  before update of sourceid on bms_st_io_doc
  for each row
declare
  --Pragma autonomous_transaction;
  v_count1 number(2);
  v_count  number(2);

begin
  --判断出库的是过账保管帐的
  --add by gkm20220117增加莆田6462
  --add by gkm20220221增加莆田5561
  --add by gkm20220413增加泉州681
  if :OLD.inoutflag = 0 and :OLD.storageid in (382, 941, 902, 708,6462,5561,681,542) then
    /*select count(1)
     into v_count
     from bms_st_io_doc a, bms_st_io_dtl b
    where a.inoutid = b.inoutid
      and a.credate between :OLD.credate-3/(24*60*60) and :OLD.credate
      and a.storageid = :OLD.storageid
     -- and a.comefrom = 75
      and a.sourcetable = 75;
     -- and a.entryid = 6;*/
    --判断是对象调拨或者总部调拨
    --业务来源18，赠品的不判断11042
    if :NEW.sourcetable=18 then
       return;
    end if;
    select count(1)
      into v_count1
      from gpcs_placesupply t
     where exists (select 1
              from gpcs_placesupplydtl_forop_v a
             where t.placesupplyid = a.PLACESUPPLYID
               and a.PLACESUPPLYDTLSTID = :OLD.placedtlid)
       and t.placemethod in (5, 9);
    if v_count1 > 0 then
      select count(1)
        into v_count
        from bms_mv_dtl a
       where exists (select 1
                from bms_mv_dtl c
               where a.goodsid = c.goodsid
                 and nvl(a.batchid, 0) = nvl(c.batchid, 0)
                 and nvl(a.lotid, 0) = nvl(c.lotid, 0)
                 and a.goodsqty = c.goodsqty
                 and c.movedtlid = :NEW.sourceid
                 and a.movedtlid <> c.movedtlid
                 and nvl(a.sendflag, 0) = nvl(c.sendflag, 0)
                 and a.movedtlid between c.movedtlid - 200 and
                     c.movedtlid + 200
              --and c.dtlmemo='门店收货自动生成'
              )
         and a.dtlmemo = '中心收配退自动生成';
      --判断调出门店是否已记账
      if (v_count = 0) then
        raise_application_error(-20001,
                                '验收入库异常，请重新点验收！' || v_count);
      end if;
    end if;
  end if;

end;

ALTER TRIGGER ""LYERP"".""GKM_11024_TRI"" DISABLE"
"LYERP","GKM_11024_TRI_NEW","BMS_ST_IO_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GKM_11024_TRI_NEW"" 
  before update of sourceid on bms_st_io_doc
  for each row
declare
  --Pragma autonomous_transaction;
  v_placereturndtlid number;
  v_count  number(2);
---修改判断逻辑20220707
begin
  --判断出库的是过账保管帐的
  if :OLD.inoutflag = 0 and
     :OLD.storageid in (382, 941, 902, 708, 6462, 5561, 681, 542) then

    --判断是对象调拨或者总部调拨
    --业务来源18，赠品的不判断11042
    if :NEW.sourcetable = 18 then
      return;
    end if;
    begin
      select b.placereturndtlid
        into v_placereturndtlid
        from gpcs_placesupplydtl_forop_v a, gpcs_allot_returntosupply b
       where a.PLACESUPPLYDTLSTID = :OLD.placedtlid
         and a.PLACESUPPLYDTLID = b.placesupplydtlid
         and exists (select 1
                from gpcs_placesupply t
               where t.placesupplyid = a.PLACESUPPLYID
                 and t.placemethod in (5, 9));
      exception
      when no_data_found then
      v_placereturndtlid:=0;
    end;
    if v_placereturndtlid > 0 then
      select count(1)
        into v_count
        from bms_st_io_doc_tmp a
       where a.placedtlid = v_placereturndtlid
         and nvl(a.comefrom, 0) = 77;
      --判断调出门店是否已记账
      if (v_count > 0) then
        raise_application_error(-20001,
                                '验收入库异常，请重新点验收！' || v_count);
      end if;
    end if;
  end if;

end;

ALTER TRIGGER ""LYERP"".""GKM_11024_TRI_NEW"" ENABLE"
"LYERP","GKM_BMS_ST_RG_DOC_TRI","BMS_ST_RG_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GKM_BMS_ST_RG_DOC_TRI"" 
before update on bms_st_rg_doc for each row
declare
  v_count number(5);
begin
  if :OLD.entryid=25 and :OLD.rgtype=1 and :NEW.usestatus=2 and :OLD.usestatus=1 then
     select count(1) into v_count from bms_st_rg_dtl where rgid=:OLD.rgid and targetsourceid is not null;

     if (v_count>0) then
        raise_application_error(-20001, '本单已入库，请重新查询!');
     end if;
  end if;
end;

ALTER TRIGGER ""LYERP"".""GKM_BMS_ST_RG_DOC_TRI"" ENABLE"
"LYERP","GKM_GSP_PHYSIC_CONSERVE_TRI","GSP_PHYSIC_CONSERVE","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GKM_GSP_PHYSIC_CONSERVE_TRI"" 
  before insert on gsp_physic_conserve
  for each row
declare
  v_goodsdtlid number(10);
begin
  if :NEW.batchid is not null then
    select max(a.goodsdetailid) into v_goodsdtlid from bms_st_qty_lst a where a.batchid=:NEW.batchid and a.goodsid=:NEW.goodsid;
    :NEW.goodsdtlid :=v_goodsdtlid;
  end if;
end gkm_gsp_physic_conserve_tri;

ALTER TRIGGER ""LYERP"".""GKM_GSP_PHYSIC_CONSERVE_TRI"" ENABLE"
"LYERP","GPCS_PLACESUPPLY_TINY_AF_TRI","GPCS_PLACESUPPLY_TINY","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GPCS_PLACESUPPLY_TINY_AF_TRI"" 
  after insert or update or delete on gpcs_placesupply_tiny
  for each row
   begin
  if inserting and nvl(:new.recieveflag,0)=0 then
    insert into gpcs_placesupply_tiny_unrec(tinyid) values(:new.placesupplytinyid);
  elsif deleting then
    delete from gpcs_placesupply_tiny_unrec a where a.tinyid=:old.placesupplytinyid;
  elsif nvl(:old.recieveflag,0)=0 and :new.recieveflag=1 then
    delete from gpcs_placesupply_tiny_unrec a where a.tinyid=:old.placesupplytinyid;
  end if;
end gpcs_placesupply_tiny_af_tri;


ALTER TRIGGER ""LYERP"".""GPCS_PLACESUPPLY_TINY_AF_TRI"" ENABLE"
"LYERP","GRESA_PRESCRIPTION_DTL_TRI","GRESA_PRESCRIPTION_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GRESA_PRESCRIPTION_DTL_TRI"" 
before insert on Gresa_Prescription_dtl for each row
begin
     insert into tmp_log(prescriptionid,prescriptiondtlid,credate)
     values(:NEW.prescriptionid,:NEW.prescriptiondtlid,sysdate);
end;


ALTER TRIGGER ""LYERP"".""GRESA_PRESCRIPTION_DTL_TRI"" DISABLE"
"LYERP","GSP_APPL_MANAGE_PERMIT_TRI","GSP_APPLIANCE_MANAGE_PERMIT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_APPL_MANAGE_PERMIT_TRI"" 
  before insert or update on gsp_appliance_manage_permit  
for each row
     begin
  :new.validenddate:=to_date(to_char(:new.validenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end gsp_appl_manage_permit_tri;



ALTER TRIGGER ""LYERP"".""GSP_APPL_MANAGE_PERMIT_TRI"" ENABLE"
"LYERP","GSP_CUSTOMER_ALTER_APPROVE_TRI","GSP_CUSTOMER_ALTER_APPROVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_CUSTOMER_ALTER_APPROVE_TRI"" 
  After Update On Gsp_Customer_Alter_Approve
  For Each Row
Begin

  If :New.Approvestatus = 3 And Nvl(:Old.Approvestatus, 0) <> 3 Then
    Insert Into t_101134
      (Seqid, Entryid, Datatype, Dataid, Content, Flag, Credate,spgs)
      Select t_101134_Seq.Nextval,
             t.Entryid,
             '客户',
             t.Customid,
             :Old.Content,
             0,
             Sysdate,
             :old.Entryid
        From Pub_Entry_Customer t
       Where t.Customid = :Old.Customid
         And t.Usestatus = 1;
  End If;

End Gsp_Customer_Alter_Approve_Tri;


ALTER TRIGGER ""LYERP"".""GSP_CUSTOMER_ALTER_APPROVE_TRI"" ENABLE"
"LYERP","GSP_ENTRY_CUSTOMER_APPROVE_TRI","GSP_ENTRY_CUSTOMER_APPROVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_ENTRY_CUSTOMER_APPROVE_TRI"" 
  After Update Of Comappstatus On Gsp_Entry_Customer_Approve
  For Each Row

Begin

  If :New.Comappstatus = 3 Then
    Insert Into Pm_Edi_Queue
      (Queueid, Goodsownerid, Credate, Queuetype, Srcid)
      Select Pm_Edi_Queue_Seq.Nextval,
             b.Goodsownerid,
             Sysdate,
             1,
             :Old.Customid
        From Pub_Entry b
       Where b.Entryid = :Old.Entryid
         And b.Goodsownerid Is Not Null;
  End If;
End Gsp_Entry_Customer_Approve_Tri;


ALTER TRIGGER ""LYERP"".""GSP_ENTRY_CUSTOMER_APPROVE_TRI"" ENABLE"
"LYERP","GSP_ENTRY_SUPPLYER_APPROVE_TRI","GSP_ENTRY_SUPPLYER_APPROVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_ENTRY_SUPPLYER_APPROVE_TRI"" 
  After Update Of Comappstatus On Gsp_Entry_Supplyer_Approve
  For Each Row

Begin

  If :New.Comappstatus = 3 Then
    Insert Into Pm_Edi_Queue
      (Queueid, Goodsownerid, Credate, Queuetype, Srcid)
      Select Pm_Edi_Queue_Seq.Nextval,
             b.Goodsownerid,
             Sysdate,
             2,
             :Old.Supplyid
        From Pub_Entry b
       Where b.Entryid = :Old.Entryid
         And b.Goodsownerid Is Not Null;
  End If;
End Gsp_Entry_Supplyer_Approve_Tri;


ALTER TRIGGER ""LYERP"".""GSP_ENTRY_SUPPLYER_APPROVE_TRI"" ENABLE"
"LYERP","GSP_GOODS_ALTER_APPROVE_TRI","GSP_GOODS_ALTER_APPROVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_GOODS_ALTER_APPROVE_TRI"" 
  After Update On Gsp_Goods_Alter_Approve
  For Each Row
Begin

  If :New.Approvestatus = 3 And Nvl(:Old.Approvestatus, 0) <> 3 Then
    Insert Into t_101134
      (Seqid, Entryid, Datatype, Dataid, Content, Flag, Credate,spgs)
      Select t_101134_Seq.Nextval,
             t.Entryid,
             '货品',
             t.Goodsid,
             :Old.Content,
             0,
             Sysdate,
             :old.Entryid
        From Pub_Entry_Goods t
       Where t.Goodsid = :Old.Goodsid
         And t.Usestatus = 1;
  End If;

End Gsp_Goods_Alter_Approve_Tri;


ALTER TRIGGER ""LYERP"".""GSP_GOODS_ALTER_APPROVE_TRI"" ENABLE"
"LYERP","GSP_GOODS_UNQUALIFIED_TRI","GSP_GOODS_UNQUALIFIED","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_GOODS_UNQUALIFIED_TRI"" 
  before update on GSP_goods_Unqualified
  for each row

begin
  --5034由于点审批的时候审批人和审批是2个不同事务，审批人更新是在C端更新，
  --可能造成审批人为空的情况下，审批标志变成已审批。
  if updating('appmanid') then

    if (nvl(:NEW.appmanid, -1) = -1) then
      raise_application_error(-20001, '审批人为空，请重新审批');
    end if;

  end if;
end;


ALTER TRIGGER ""LYERP"".""GSP_GOODS_UNQUALIFIED_TRI"" DISABLE"
"LYERP","GSP_PHYSIC_CONSERVE_TRI","GSP_PHYSIC_CONSERVE","INSERT OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_PHYSIC_CONSERVE_TRI"" 
  after insert or delete on gsp_physic_conserve
  for each row
        
begin
  if inserting then
    update bms_lot_def set conservedate = :new.credate
    where lotid = :new.lotid;

    --add by lijunjie 20070109
    If Nvl(:new.sthouseid ,0) > 0 and :new.posid<>8 Then
      Update gsp_lot_conservedate Set conservedate = :new.credate
      Where lotid = :new.lotid and sthouseid = :new.sthouseid;

    End If;
    --lijunjie 20070109 add end
    
  end if;
  if deleting then
    update bms_lot_def set conservedate = :old.lastconservedate
    where lotid = :old.lotid;
    --add by lijunjie 20070109
    If nvl(:old.sthouseid,0) > 0 Then
      UPdate gsp_lot_conservedate Set conservedate = :old.lastconservedate
      Where lotid = :old.lotid and sthouseid = :old.sthouseid;
    End If;
    --lijunjie 20070109 add end
  end if;
end gsp_physic_conserve_tri;


ALTER TRIGGER ""LYERP"".""GSP_PHYSIC_CONSERVE_TRI"" ENABLE"
"LYERP","GSP_PHYSIC_QUALITY_CHECK_TRI","GSP_PHYSIC_QUALITY_CHECK","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_PHYSIC_QUALITY_CHECK_TRI"" 
  before insert on GSP_PHYSIC_QUALITY_CHECK
  for each row
declare

  v_checkmanid   number;
  v_value        number;
  v_againchkflag number(1);

begin
  --处理5110,5023第一验收人为空的异常。是由于2022回退确定造成的。add by gkm 20190919
  --同时也处理双人复核无第二验收人的问题。
  if (:NEW.checkmanid is null) then
  
    begin
      select t.value
        into v_value
        from Sys_npbusi_config t
       where t.configname = '是否控制双人作业'
         and t.entryid = :NEW.entryid;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_value := -1;
    end;
  
    begin
      select t.againchkflag
        into v_againchkflag
        from pub_goods t
       where t.goodsid = :NEW.goodsid;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_againchkflag := -1;
    end;
  
    if (v_value = 1 and v_againchkflag = 1) then
      raise_application_error(-20001, '验收总单的第一复核人为空，请点保存按钮!!');
    end if;
  
    begin
      select t.employeeid
        into v_checkmanid
        from bms_st_rg_doc t
       where t.rgid = :NEW.rgid;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_checkmanid := 0;
    end;
  --自动根据验收总单的第一复核人维护进去。
    if (v_checkmanid = 0) then
      raise_application_error(-20001,
                              '总单第一复核人为空，请确认' || v_checkmanid);
    else
      :NEW.checkmanid := v_checkmanid;
    end if;
  end if;
end;


ALTER TRIGGER ""LYERP"".""GSP_PHYSIC_QUALITY_CHECK_TRI"" ENABLE"
"LYERP","GSP_SUPPLYER_ALTER_APPROVE_TRI","GSP_SUPPLYER_ALTER_APPROVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""GSP_SUPPLYER_ALTER_APPROVE_TRI"" 
  After Update On Gsp_Supplyer_Alter_Approve
  For Each Row
Begin

  If :New.Approvestatus = 3 And Nvl(:Old.Approvestatus, 0) <> 3 Then
    Insert Into t_101134
      (Seqid, Entryid, Datatype, Dataid, Content, Flag, Credate,spgs)
      Select t_101134_Seq.Nextval,
             t.Entryid,
             '供应商',
             t.Supplyid,
             :Old.Content,
             0,
             Sysdate,
             :old.Entryid
        From Pub_Entry_Supplyer t
       Where t.Supplyid = :Old.Supplyid
         And t.Usestatus = 1;
  End If;

End Gsp_Supplyer_Alter_Approve_Tri;


ALTER TRIGGER ""LYERP"".""GSP_SUPPLYER_ALTER_APPROVE_TRI"" ENABLE"
"LYERP","LICENSE_READINFO_TRI","GSP_COMPANY_LICENSE","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""LICENSE_READINFO_TRI"" 
  before update of ZX_READDATE on gsp_company_license
  --referencing old as old new as new
  for each row

begin
  --插入读取信息
  delete from GSP_COMPANY_LICENSE_READINFO
   where licenseid = :old.licenseid
     and readman = :new.TERM and typeid=1;
  insert into GSP_COMPANY_LICENSE_READINFO
    (licenseid, READMAN, READTIME,typeid)
  values
    (:old.licenseid, :new.TERM, :new.zx_readdate,1);
  :new.TERM := :old.TERM;
end ;


ALTER TRIGGER ""LYERP"".""LICENSE_READINFO_TRI"" ENABLE"
"LYERP","MES_BMS_STORER_POS_TRI","BMS_STORER_POS","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_BMS_STORER_POS_TRI"" 
  after insert or update or delete on bms_storer_pos
  for each row
declare
ctn number;
begin
select count(1)
  into ctn
  from mes_bms_sthouse_v a
 where a.sthouseid = nvl(:NEW.sthouseid, :OLD.sthouseid);
if ctn > 0 then
  if inserting or updating then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid)
      select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '22', :new.posid
        from dual;
  end if;
  if deleting then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid,deleted)
      select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '22', :old.posid,1
        from dual;
  end if;
end if;

end mes_bms_storer_pos_tri;

ALTER TRIGGER ""LYERP"".""MES_BMS_STORER_POS_TRI"" ENABLE"
"LYERP","MES_BMS_ST_STOREHOUSE_TRI","BMS_ST_STOREHOUSE","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_BMS_ST_STOREHOUSE_TRI"" 
  after insert or update or delete on bms_st_storehouse
  for each row
declare
  ctn number;
begin
  select count(1)
    into ctn
    from mes_entry a
   where a.entryid =
         get_entryid_by_deptid(nvl(:new.storerid, :old.storerid));
  if ctn > 0 then
    if inserting or updating then
      insert into Pm_Edi_to_mes_Tmp
        (queueid, Credate, Queuetype, srcid, Goodsownerid)
        select Pm_Edi_to_mes_Tmp_seq.Nextval,
               sysdate,
               '21',
               :new.sthouseid,
               get_entryid_by_deptid(:new.storerid)
          from dual;
    end if;
    if deleting then
      insert into Pm_Edi_to_mes_Tmp
        (queueid, Credate, Queuetype, srcid, deleted, Goodsownerid)
        select Pm_Edi_to_mes_Tmp_seq.Nextval,
               sysdate,
               '21',
               :old.sthouseid,
               1,
               get_entryid_by_deptid(:old.storerid)
          from dual;
    end if;
  end if;

end mes_bms_st_storehouse_tri;

ALTER TRIGGER ""LYERP"".""MES_BMS_ST_STOREHOUSE_TRI"" ENABLE"
"LYERP","MES_PUB_ENTRY_GOODS_TRI","PUB_ENTRY_GOODS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_PUB_ENTRY_GOODS_TRI"" 
  after update or delete on pub_entry_goods
  for each row
declare
  ctn number;

begin
  select count(1) into ctn from mes_entry a where a.entryid = :OLD.Entryid;
  if updating and ctn > 0 and :NEW.usestatus = 1 then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Goodsownerid, Credate, Queuetype, srcid)
      select Pm_Edi_to_mes_Tmp_seq.Nextval,
             :OLD.entryid,
             sysdate,
             '0',
             :OLD.goodsid
        from dual;
    --首营成功，同时插入货品明细
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid)
      select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '30', a.goodsdtlid
        from pub_goods_detail a
       where a.goodsdtlid is not null
         and a.goodsid = :OLD.goodsid;
  end if;
  if deleting and   ctn > 0 then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Goodsownerid, Credate, Queuetype, srcid,deleted)
      select Pm_Edi_to_mes_Tmp_seq.Nextval,
             :OLD.entryid,
             sysdate,
             '0',
             :OLD.goodsid,
             1
        from dual;

  end if;
end mes_pub_entry_goods_tri;

ALTER TRIGGER ""LYERP"".""MES_PUB_ENTRY_GOODS_TRI"" ENABLE"
"LYERP","MES_PUB_GOODS_DETAIL_TRI","PUB_GOODS_DETAIL","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_PUB_GOODS_DETAIL_TRI"" 
  after insert or update  on pub_goods_detail
  for each row
declare
  qty number;
begin
  select count(*)
    into qty
    from pub_entry_goods a
   where exists (select 1 from mes_entry b where a.entryid = b.entryid)
     and a.usestatus = 1
     and a.goodsid = nvl(:NEW.goodsid, :old.goodsid);
  if (inserting or updating) and qty > 0 then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid)
      select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '30', :NEW.goodsdtlid
        from dual;
  end if;
  --由于mes的接口【货品明细【UNIT】增量同步】没有实现删除，故删除不做处理
  /*if deleting then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid, deleted)
      select Pm_Edi_to_mes_Tmp_seq.Nextval,
             sysdate,
             '30',
             :old.goodsdtlid,
             1
        from dual;
  end if;*/
end mes_pub_goods_detail_tri;

ALTER TRIGGER ""LYERP"".""MES_PUB_GOODS_DETAIL_TRI"" ENABLE"
"LYERP","MES_PUB_GOODS_UNIT_TRI","PUB_GOODS_UNIT","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_PUB_GOODS_UNIT_TRI"" 
  after insert or update on pub_goods_unit
  for each row
declare
  qty number;
begin
  select count(*)
    into qty
    from pub_entry_goods a
   where exists (select 1 from mes_entry b where a.entryid = b.entryid)
     and a.usestatus = 1
     and a.goodsid = :NEW.goodsid;
  if (inserting or updating) and qty > 0 then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Credate, Queuetype, srcid)
      select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '29', :NEW.seqid
        from dual;
  end if;
  --由于mes的接口【货品明细【UNIT】增量同步】没有实现删除，故删除不做处理
end mes_pub_goods_unit_tri;

ALTER TRIGGER ""LYERP"".""MES_PUB_GOODS_UNIT_TRI"" ENABLE"
"LYERP","MES_PUB_SETTLE_ACCOUNT_TRI","PUB_SETTLE_ACCOUNT","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_PUB_SETTLE_ACCOUNT_TRI"" 
  after insert or update or delete on pub_settle_account
  for each row
declare
  ctn number;
  deleted number(1);
begin
  --dbms_output.put_line('o:'||:OLD.Entryid||'N:'||:NEW.entryid);
  select count(1) into ctn from mes_entry a where a.entryid = nvl(:OLD.Entryid,:NEW.entryid);
  if deleting then
    deleted :=1;
  else
    deleted :=0;
  end if;
  if ctn>0 then
    insert into Pm_Edi_to_mes_Tmp
      (queueid, Goodsownerid, Credate, Queuetype, srcid,deleted)
      select Pm_Edi_to_mes_Tmp_seq.Nextval,
             nvl(:OLD.Entryid,:NEW.entryid),
             sysdate,
             '31',
             nvl(:old.usemm,:new.usemm),
             deleted
        from dual;
  end if;


end mes_pub_settle_account_tri;

ALTER TRIGGER ""LYERP"".""MES_PUB_SETTLE_ACCOUNT_TRI"" ENABLE"
"LYERP","MES_PUB_STORER_TRI","PUB_STORER","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MES_PUB_STORER_TRI"" 
  after insert or update or delete on pub_storer
  for each row
    declare
 ctn number;
begin
  --有上线的独立单元才触发。
  select count(1) into ctn from mes_entry a where a.entryid=get_entryid_by_deptid(nvl(:new.storerid,:old.storerid));
  if ctn>0 then
    if inserting or updating then
      insert into Pm_Edi_to_mes_Tmp
        (queueid, Credate, Queuetype, srcid,goodsownerid)
        select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '20', :new.storerid,get_entryid_by_deptid(:new.storerid)
          from dual;
    end if;
    if deleting then
      insert into Pm_Edi_to_mes_Tmp
        (queueid, Credate, Queuetype, srcid,goodsownerid,deleted)
        select Pm_Edi_to_mes_Tmp_seq.Nextval, sysdate, '20', :old.storerid,get_entryid_by_deptid(:old.storerid),1
          from dual;
    end if;
  end if;

  end mes_pub_storer_tri;

ALTER TRIGGER ""LYERP"".""MES_PUB_STORER_TRI"" ENABLE"
"LYERP","MPCS_GMP_PASS_NOTICE_IN_TRI","MPCS_GMP_PASS_NOTICE","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_GMP_PASS_NOTICE_IN_TRI"" 
  before insert on mpcs_gmp_pass_notice
  for each row
begin
  --用于防止新增的放行通知单未保存直接审核。
  if :NEW.usestatus=1 then
    raise_application_error(-20001,'要先保存，再点审核，请删除，再重新新增！');
  end if;
end;

ALTER TRIGGER ""LYERP"".""MPCS_GMP_PASS_NOTICE_IN_TRI"" ENABLE"
"LYERP","MPCS_GMP_PASS_NOTICE_TRI","MPCS_GMP_PASS_NOTICE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_GMP_PASS_NOTICE_TRI"" 
  after update on mpcs_gmp_pass_notice
  for each row
declare

  v_rgdtlid number(10);
  v_count   number(1);

  v_count1   number(1);
  v_rgdtlcnt number;
  ctn        number;
  v_sourcetable number(1);

  cursor c_row is
    select b.rgdtlid, a.noticeid
      from bms_st_rg_dtl a, bms_st_rg_dtl b
     where a.rgdtlid = v_rgdtlid

       and a.rgid = b.rgid;
  r_row c_row%rowtype;

  ---修改判断逻辑20220707
begin
  if updating('Usestatus') then
    --放行通知单点审核or回退审核
    --异常先处理
    if :NEW.Usestatus in (1, 2) then
      begin
        select c.sourceid,nvl(c.sourcetable,0)
          into v_rgdtlid,v_sourcetable
          from MPCS_GMP_CHECK_DOC b, mpcs_gmp_askcheck c
         where b.askcheckid = c.askcheckid
           --and c.sourcetable = 2 --注释掉：20250207  2代表收货单、1代表产成品入库          
           and b.checkdocid = :OLD.checkdocid;
      exception
        when no_data_found then
          raise_application_error(-20001,
                                  '没有对应验收细单ID，不允许放行！');
      end;
      --非验收单生成的不走这个流程。 add by gkm20250207
      if v_sourcetable<>2 then
        return;
      end if;

      select count(1)
        into v_count
        from bms_st_rg_doc a, bms_st_rg_dtl b
       where a.rgid = b.rgid
         and b.rgdtlid = v_rgdtlid
         and a.rgtype = 2;
      --销退申请产生的，不走这个流程
      if v_count = 1 then
        return;
      end if;

      --修改合格数量
      if :NEW.Usestatus = 1 and :OLD.freenum > 0 then
        update bms_st_rg_dtl a
           set a.goodsqty = :OLD.freenum, a.noticeid = :OLD.Noticeid
         where a.rgdtlid = v_rgdtlid;
        --点回退审核  usestatus 0:作废 1：正常 2：临时 3：确定。审核对应1，回退审核对应2
      elsif :NEW.Usestatus = 2 then

        select count(1)
          into v_count1
          from bms_st_rg_doc a, bms_st_rg_dtl b
         where a.rgid = b.rgid
           and b.rgdtlid = v_rgdtlid
           and a.rgtype = 1
           and a.usestatus in (2, 3);
        if v_count1 >= 1 then
          raise_application_error(-20001,
                                  '验收细单ID:' || v_rgdtlid || '已收货，请先回退验收收货！');
        end if;

        update bms_st_rg_dtl a
           set a.goodsqty =
               (select b.goodsqty
                  from bms_st_re_dtl b
                 where a.redtlid = b.redtlid),
               a.noticeid = null
         where a.rgdtlid = v_rgdtlid;
      end if;

      select count(1)
        into v_rgdtlcnt
        from bms_st_rg_dtl a, bms_st_rg_dtl b
       where a.rgdtlid = v_rgdtlid
         and a.rgid = b.rgid;
      --2020多条细单
      if v_rgdtlcnt > 1 then
        select count(1)
          into ctn
          from bms_st_rg_dtl a, bms_st_rg_dtl_v b
         where a.rgdtlid = v_rgdtlid
           and a.rgid = b.rgid
           and nvl(b.ifcheckflag, 1) = 1
           and b.RGDTLID <> v_rgdtlid
           and b.noticeid is null;
        --判断是否存在应检的未检
        if ctn > 0 then
          return;
        end if;

        --多条细单，都已检并且放行通知单已审核，2020点确定
        open c_row;
        LOOP
          fetch c_row
            into r_row;
          exit when c_row%notfound;
          mpcs_rg_prod_p.p_insert_5023(r_row.rgdtlid, r_row.Noticeid);
        END LOOP;
        close c_row;

        return;
      end if;
      --合格

    end if;
    --合格，审核 
    --add dealidea 判断 检查是合格，但是浸出物临界标准，做退货 黄舒榕
    if :NEW.Usestatus = 1 and :OLD.freenum > 0 and :NEW.dealidea=1 then

    /*  update bms_st_rg_dtl a
         set a.goodsqty = :OLD.freenum
       where a.rgdtlid = v_rgdtlid;
    */
      mpcs_rg_prod_p.p_insert_5023(v_rgdtlid, :OLD.Noticeid);

      insert into GKM_T_LOG
        (credate, Logtype, Content, Mainid)
      values
        (sysdate,
         '燕来福放行自动执行',
         '验收合格数量' || :OLD.freenum,
         v_rgdtlid);

      --审核 拒绝，放行数量=0
    elsif (:NEW.Usestatus = 1 and :OLD.freenum = 0) or(:NEW.dealidea in(2,5)) then
      mpcs_rg_prod_p.p_create_su(v_rgdtlid, :OLD.Noticeid);
      insert into GKM_T_LOG
        (credate, Logtype, Content, Mainid)
      values
        (sysdate,
         '燕来福放行自动执行',
         '验收不合格数量',
         v_rgdtlid);
    end if;
  end if;
  /*Exception
      When Others Then
       -- Rollback;
        Insert Into GKM_T_LOG
          (credate, logtype, content,Mainid)
        Values
          (Sysdate,
           '燕来福放行自动执行错误',
           '验收细单id' || v_rgdtlid ||'错误代码:' || Sqlcode || substr(Sqlerrm, 1, 2600),v_rgdtlid);
       -- Commit;*/
end;

ALTER TRIGGER ""LYERP"".""MPCS_GMP_PASS_NOTICE_TRI"" ENABLE"
"LYERP","MPCS_GMP_STD_GOODS_TRI","MPCS_GMP_STD_GOODS","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_GMP_STD_GOODS_TRI"" 
  Before insert On mpcs_gmp_std_goods
  For Each Row

Begin

  If :New.entryid  is null Then
    select a.entryid into :New.entryid from mpcs_gmp_std a  where a.stdid=:NEW.stdid;
  End If;

End mpcs_gmp_std_goods_tri;

ALTER TRIGGER ""LYERP"".""MPCS_GMP_STD_GOODS_TRI"" ENABLE"
"LYERP","MPCS_MM_PROC_LABOR_TRI","MPCS_MM_PROC_LABOR","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_MM_PROC_LABOR_TRI"" 
  before insert on MPCS_MM_PROC_LABOR
  for each row
begin
  if (round(:NEW.manhour,2)<>round(:NEW.piecerate/15,2)) then
    raise_application_error(-20001, '工时不等于计件工资除以15');
  end if;

end MPCS_MM_PROC_LABOR_tri;

ALTER TRIGGER ""LYERP"".""MPCS_MM_PROC_LABOR_TRI"" DISABLE"
"LYERP","MPCS_PR_BOM_DOC_TRI","MPCS_PR_BOM_DOC","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_PR_BOM_DOC_TRI"" 
  before insert on mpcs_pr_bom_doc
  for each row
declare
  v_count number(1);
begin
if :NEW.entryid=64 then  
    select count(1)
      into v_count
      from pub_goods_unit_v t
     where t.goodsdtlid = :NEW.pgoodsdtlid
       and nvl(t.packsize, 0) <= 1
       and exists (select 1
              from pub_goods a
             where t.goodsid = a.goodsid
               and nvl(a.accflag, 0) in (1, 2));
    if v_count > 0 then
      raise_application_error(-20001,
                              '外包装大小小于等于1,不能选小于等于1的');
    end if;
  end if;
end mpcs_pr_bom_doc_tri;

ALTER TRIGGER ""LYERP"".""MPCS_PR_BOM_DOC_TRI"" ENABLE"
"LYERP","MPCS_PR_CMD_DOC_TRI","MPCS_PR_CMD_DOC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_PR_CMD_DOC_TRI"" 
  before insert or update on mpcs_pr_cmd_doc
  for each row
declare
  v_count  number(1);
  v_count1 number(1);
  v_count2 number(1);
  v_count3 number(1); --用于判断生产日期和有效期是否相等
  --  a number;
  v_count4 number(1);
  v_bzq    number(2);
begin
  v_count  := 1;
  v_count1 := 1;
  v_count2 := 1;
  v_count3 := 0;
  --add by gkm20250519 生产日期加保质期不等于有效期报错提醒
  --增加限制临时状态任务单才触发，成本对象管理也会触发。
  if :NEW.cmdtype = 1 and :NEW.Credate>to_date('2025-05-21','yyyy-mm-dd') and :NEW.Usestatus=1  then
    begin
      select a.bzq
        into v_bzq
        from zx_ypbzq a, pub_goods b
       where a.goodsname = b.goodsname
         and b.goodsid = :NEW.Pgoodsid
         and a.entryid = :NEW.entryid;
    exception
      when no_data_found then
        v_bzq := 0;
    end;
    if v_bzq > 0 then
      select count(1)
        into v_count4
        from bms_lot_def a
       where a.lotid = :NEW.lotid
         and a.goodsid = :NEW.pgoodsid
         and add_months(a.proddate, v_bzq * 12) - 1 = a.invaliddate;
      if (v_count4 = 0) then
        raise_application_error(-20001, '生产日期加保质期不等于有效期！');
      end if;
    
    end if;
  end if;
  --end by gkm20250519

  if inserting then
    select count(1)
      into v_count
      from bms_lot_def
     where lotid = :NEW.lotid
       and goodsid = :NEW.pgoodsid;
    select count(1)
      into v_count3
      from bms_lot_def
     where lotid = :NEW.lotid
       and proddate = invaliddate;
  end if;

  if nvl(:OLD.usestatus, 0) = 1 then
    if updating('pgoodsid') then
      select count(1)
        into v_count1
        from bms_lot_def a
       where a.lotid = :OLD.lotid
         and a.goodsid = :NEW.pgoodsid
         and nvl(:OLD.usestatus, 0) = 1;
    end if;
  
    if updating('lotid') then
      select count(1)
        into v_count2
        from bms_lot_def a
       where a.lotid = :NEW.lotid
         and a.goodsid = :OLD.pgoodsid
         and nvl(:OLD.usestatus, 0) = 1;
    
      --  select :OLD.lotid into a from dual;
    end if;
  end if;

  if (v_count = 0 or v_count1 = 0 or v_count2 = 0) then
    raise_application_error(-20001,
                            v_count1 || '货品id与批号id不对应，请删除总单，重新做单' ||
                            v_count2);
  end if;

  if (v_count3 = 1) then
    raise_application_error(-20001, '生产日期和有效期一样！');
  end if;
  --add by gkm20241231,增加以下限制
  if updating('usestatus') and :OLD.usestatus = 3 and :NEW.Usestatus = 2 and
     :OLD.Mescmdid is not null then
    raise_application_error(-20001,
                            'mes产生的生产任务单，不允许回退下达！');
  end if;
  --add by gkm20250331,增加以下限制
  if updating('usestatus') and :OLD.usestatus = 3 and :NEW.Usestatus = 0 and
     :OLD.Mescmdid is not null then
    raise_application_error(-20001, 'mes产生的生产任务单，不允许作废！');
  end if;
  if updating('usestatus') and :OLD.usestatus = 2 and :NEW.Usestatus = 1 and
     :OLD.Mescmdid is not null then
    raise_application_error(-20001,
                            'mes产生的生产任务单，不允许回退确定！');
  end if;

end mpcs_pr_cmd_doc_tri;

ALTER TRIGGER ""LYERP"".""MPCS_PR_CMD_DOC_TRI"" ENABLE"
"LYERP","MPCS_PR_IN_DOC_TRI","MPCS_PR_IN_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_PR_IN_DOC_TRI"" 
  before update on mpcs_pr_in_doc
  for each row
declare
  ctn  number(1);
  ctn1 number(1);
  ctn2 number(2);
  ctn3 number(2);
begin
  if nvl(:NEW.Comefrom, 0) = 1 and
     (:NEW.Tostorageid <> :OLD.Tostorageid or
      :NEW.Tocompanyid <> :OLD.Tocompanyid or
      :NEW.Finishflag <> :OLD.Finishflag or
      :NEW.Companyid <> :OLD.Companyid) then
    raise_application_error(-20001,
                            'MES产生的入库单，不允许修改总单信息！');
  end if;

  /*邹杨提出能否在“生产任务单管理”中，增加“强制分批次入库”的功能，在炮制完成时，由炮制组长根据炮制结果操作一下，
  配合包装大小8888使用，这时仓管员“入库操作”则必须“按部分完成”分批入库。
  如：炮制一批当归，完成时分成了“大片”和“小片”，炮制组长在“生产任务单管理”中按“强制分批”做标识，
  仓管员就可以知道这批当归有大小之分，须分批入库。*/
  if updating('Usestatus') then
    --71112点确定，是全部完工触发
    if :OLD.finishflag = 2 and :NEW.Usestatus = 1 then
      select count(1)
        into ctn1
        from mpcs_pr_cmd_doc a, mpcs_pr_in_dtl b
       where a.cmdid = b.cmdid
         and nvl(a.ifqzfp, 0) = 1
         and b.pdinid = :OLD.pdinid;
      select count(1)
        into ctn
        from mpcs_pr_cmd_doc a, mpcs_pr_in_dtl b
       where a.cmdid = b.cmdid
         and nvl(a.ifqzfp, 0) = 1
         and nvl(a.pgoodsinqty, 0) - b.goodsqty > 0
         and b.pdinid = :OLD.pdinid;
    
    end if;
  
    if ctn = 0 and ctn1 > 0 then
      raise_application_error(-20001, '需要分批入库，不能直接全部完工！');
    end if;
    --20241204
    if :NEW.Usestatus = 1 then
      select count(1)
        into ctn2
        from mpcs_pr_in_dtl b, mpcs_pr_cmd_doc c
       where b.cmdid = c.cmdid
         and c.pstorageid is not null
         and :OLD.tostorageid <> c.pstorageid
         and b.pdinid = :OLD.pdinid;
      --mes的生产任务单，不允许直接在ERP生成
    
      if ctn2 > 0 then
        raise_application_error(-20001,
                                '生产任务单的保管账和成品入库选择的保管账不一致！');
      end if;
    end if;
    if :NEW.Usestatus = 1 and nvl(:NEW.comefrom, 0) = 0 then
      select count(1)
        into ctn3
        from mpcs_pr_in_dtl b, mpcs_pr_cmd_doc c
       where b.cmdid = c.cmdid
         and c.mescmdid is not null
            
         and b.pdinid = :NEW.pdinid;
    
      if ctn3 > 0 then
        raise_application_error(-20001,
                                'mes的生产任务单，不允许直接在ERP生成！');
      end if;
    end if;
  end if;

end;

ALTER TRIGGER ""LYERP"".""MPCS_PR_IN_DOC_TRI"" ENABLE"
"LYERP","MPCS_PR_IN_DTL_TRI","MPCS_PR_IN_DTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""MPCS_PR_IN_DTL_TRI"" 
  before insert or update on mpcs_pr_in_dtl
  for each row
declare
  v_count number(3);
  v_ctn   number(1);
begin
  select count(1)
    into v_count
    from mpcs_pr_materialout_dtl a, mpcs_pr_materialout_doc b
   where a.cmdid = :NEW.cmdid
     and a.moid = b.moid
     and nvl(b.usestatus, 1) = 1
     and a.goodsqty > 0;
  ---用于防止无领料单，可以做产成品入库。
  if v_count = 0 then
    raise_application_error(-20001, '领料单被删除,请先领料再做入库！');
  end if;

  --20250611 增加检查，若任务单的货品明细ID不为空，则产成品入库单的货品明细ID要与任务单一致
  /*select count(1)
    into v_ctn
    from mpcs_pr_cmd_doc a
   where a.cmdid = :NEW.Cmdid
     and a.pgoodsdtlid <> :NEW.goodsdtlid
     and a.entryid=64
     and a.pgoodsdtlid is not null;
  
  if v_ctn = 1 then
    raise_application_error(-20001, '入库单与任务单的包装不一致！');
  end if;*/
  --20250613 增加检查，若任务单的货品明细的包装名称=件8 代煎，则产成品入库单的货品明细ID要与任务单一致
  select count(1)
    into v_ctn
    from mpcs_pr_cmd_doc a
   where a.cmdid = :NEW.Cmdid
     and a.pgoodsdtlid <> :NEW.goodsdtlid
     and a.entryid = 64
     and exists (select 1
            from pub_goods_detail b
           where a.pgoodsid = b.goodsid
             and b.packname = '件8')
     and a.pgoodsdtlid is not null;

  if v_ctn = 1 then
    raise_application_error(-20001, '入库单与任务单的包装不一致！');
  end if;

end;

ALTER TRIGGER ""LYERP"".""MPCS_PR_IN_DTL_TRI"" ENABLE"
"LYERP","NGPCS_PR_ALTER_DTL_TRI","NGPCS_PR_ALTER_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""NGPCS_PR_ALTER_DTL_TRI"" 
  before insert on ngpcs_pr_alter_dtl
  for each row
declare
  v_alterlevel        number(1); --判断是否是同一存货帐
  v_ctn          number(1);
  v_placepointid number(10);
  v_entryid      number(10);
  v_ctn1         number(1);
begin
  begin
    select a.alterlevel
      into v_alterlevel
      from ngpcs_pr_alter_doc a
     where a.pralterid = :NEW.pralterid
       and a.usestatus = 1;
    --and alterlevel = 3;
  exception
    when no_data_found then
      raise_application_error(-20001,
                              '调价单ID' || :NEW.pralterid ||
                              '非临时状态，或者不存在');
  end;
  if v_alterlevel = 3 then --门店调价的才检查 65000导入检查
    select count(1)
      into v_ctn
      from pub_goods a
     where a.goodsid = :NEW.goodsid
       and a.goodsunit = :NEW.priceunit;
    if v_ctn = 0 then
      raise_application_error(-20001,
                              '货品ID' || :NEW.goodsid ||
                              '的基本单位维护错误，或者货品ID不存在！');
    end if;
    begin
      select a.placepointid, b.entryid
        into v_placepointid, v_entryid
        from ngpcs_pr_alter_doc a, gpcs_placepoint b
       where a.pralterid = :NEW.pralterid
         and a.placepointid = b.placepointid;
    exception
      when no_data_found then
        raise_application_error(-20001, '总单的门店维护错误');
      
    end;
  
    select count(1)
      into v_ctn1
      from pub_entry_goods_v
     where entryid = v_entryid
       and (goodsid = :NEW.goodsid)
       and ((combinflag != 1 or combinflag is null) and
           (accflag != 5 or accflag is null) and
           (not exists
            (select 1
                from gpcs_placePoint_altergoods t
               where t.placepointID = v_placepointid) or
            goodsid in (select goodsid
                           from gpcs_placePoint_altergoods t
                          where t.placepointID = v_placepointid)) and
           usestatus = 1);
    if v_ctn1 = 0 then
      raise_application_error(-20001,
                              '货品ID' || :NEW.goodsid || '未首营或其它原因，不可定价');
    end if;
  end if;
end ngpcs_pr_alter_dtl_tri;

ALTER TRIGGER ""LYERP"".""NGPCS_PR_ALTER_DTL_TRI"" ENABLE"
"LYERP","PM_EDI_QUEUE_TO_EASTMP_TRI","PM_EDI_QUEUE","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PM_EDI_QUEUE_TO_EASTMP_TRI"" 
  After  Insert on pm_edi_queue
for each row
declare

begin
  if :new.queuetype  in (1,2,4) then
      insert into PM_EDI_QUEUE_TMP(queueid,
       goodsownerid,
       credate,
       queuetype,
       srcid,
       expdate,
       expflag,
       insertdate)
       values(:new.queueid,
       :new.goodsownerid,
       :new.credate,
       :new.queuetype,
       :new.srcid,
       :new.expdate,
       :new.expflag,
       Sysdate);
   end if;
end pm_edi_queue_to_eastmp_tri;


ALTER TRIGGER ""LYERP"".""PM_EDI_QUEUE_TO_EASTMP_TRI"" ENABLE"
"LYERP","PM_EDI_QUEUE_TRI","PM_EDI_QUEUE","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PM_EDI_QUEUE_TRI"" 
  before delete on pm_edi_queue  
for each row
declare
  -- local variables here
begin
  if :OLD.queuetype not in (1,2,3,4,5,6,45) then
      insert into pm_edi_queue_backup(queueid,credate,queuetype,srcid,expdate,expflag,goodsownerid)
       values(:old.queueid,:old.credate,:old.queuetype,:old.srcid,sysdate,1,:old.goodsownerid);
   end if;
end pm_edi_queue_tri;


ALTER TRIGGER ""LYERP"".""PM_EDI_QUEUE_TRI"" ENABLE"
"LYERP","PUB_COMPANY_INS_TRI","PUB_COMPANY","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PUB_COMPANY_INS_TRI"" 
  before insert on pub_company  
  for each row
  
begin
  if :new.parentcompanyid is null then
    :new.parentcompanyid := 0;
  end if;
  if :new.usestatus is null then
    :new.usestatus := 1;
  end if;
end;


ALTER TRIGGER ""LYERP"".""PUB_COMPANY_INS_TRI"" ENABLE"
"LYERP","PUB_CUSTOMER_IMP_TMP_TRI","PUB_CUSTOMER_IMP_TMP","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PUB_CUSTOMER_IMP_TMP_TRI"" 
  before insert on PUB_CUSTOMER_IMP_TMP
  For each row

begin
  if :new.tmpid is null then
    :new.tmpid := f_getseqid('PUB_CUSTOMER_IMP_TMP_SEQ',
                             'PUB_CUSTOMER_IMP_TMP',
                             'tmpid');
  end if;

end PUB_CUSTOMER_IMP_TMP_tri;


ALTER TRIGGER ""LYERP"".""PUB_CUSTOMER_IMP_TMP_TRI"" ENABLE"
"LYERP","PUB_SETTLE_ACCOUNT_TRI","PUB_SETTLE_ACCOUNT","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PUB_SETTLE_ACCOUNT_TRI"" 
  Before Update On PUB_SETTLE_ACCOUNT
  For Each Row
Begin
  --回退结账 设置插入标志为0
  If :New.usestatus = 1 And :Old.usestatus = 3 Then
    :New.INSFLAG := 0;
    --原来这个字段是存插入金蝶的时间，现在改成回退结账的时间，用于插入金蝶时判断 add by ybh 2022年7月22日 
    :new.Insdate := Sysdate;
  End If;
End PUB_SETTLE_ACCOUNT_tri;

ALTER TRIGGER ""LYERP"".""PUB_SETTLE_ACCOUNT_TRI"" ENABLE"
"LYERP","PUB_SUPPLYER_IMP_TMP_TRI","PUB_SUPPLYER_IMP_TMP","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""PUB_SUPPLYER_IMP_TMP_TRI"" 
  before insert on PUB_SUPPLYER_IMP_TMP
  For each row

begin
  if :new.tmpid is null then
    :new.tmpid := f_getseqid('PUB_SUPPLYER_IMP_TMP_SEQ',
                             'PUB_SUPPLYER_IMP_TMP',
                             'tmpid');
  end if;

end PUB_SUPPLYER_IMP_TMP_tri;


ALTER TRIGGER ""LYERP"".""PUB_SUPPLYER_IMP_TMP_TRI"" ENABLE"
"LYERP","RESA_GSP_BUNKER_DTL_TRI","RESA_GSP_BUNKER_DTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""RESA_GSP_BUNKER_DTL_TRI"" 
before insert or update on resa_gsp_bunker_dtl for each row
declare
  v_count number(5);
begin
select count(1)
  into v_count
  from bms_su_doc a, bms_su_dtl b
 where a.sudocid = b.sudocid
   and a.entryid = 614
   and b.sudocdtlid = :NEW.acceptdtlid;
if v_count = 1  then
  if :NEW.bunkermanid is null  then
    raise_application_error(-20001, '装斗人不允许为空！');
  end if;

  if  nvl(:NEW.checkmanid,-1)=:NEW.bunkermanid  then
    raise_application_error(-20001, '装斗人和复核人不能同一个人！');
  end if;

end if;
end;

ALTER TRIGGER ""LYERP"".""RESA_GSP_BUNKER_DTL_TRI"" ENABLE"
"LYERP","RESA_PRESENT_REPINTE_DEF_TRI","RESA_PRESENT_REPINTEGRAL_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""RESA_PRESENT_REPINTE_DEF_TRI"" 
  before insert or update on resa_present_repintegral_def
for each row
     begin
  :new.invalidenddate:=to_date(to_char(:new.invalidenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end resa_present_repinte_def_tri;


ALTER TRIGGER ""LYERP"".""RESA_PRESENT_REPINTE_DEF_TRI"" ENABLE"
"LYERP","T610_TRI","T610","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T610_TRI"" 
  before delete on t610
  for each row

     begin
  insert into t610_his
    (iodtlid,zxcolumn8,taxinvno,unitprice,goodsownerid,DEL_DATE)
  values
    (:old.iodtlid,
     :old.zxcolumn8,
     :old.taxinvno,
     :old.unitprice,
     :old.goodsownerid,
     sysdate);
end;


ALTER TRIGGER ""LYERP"".""T610_TRI"" ENABLE"
"LYERP","TG_MPCS_CA_MEACARD","MPCS_CA_MEACARD","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_CA_MEACARD"" 
before  insert or update on mpcs_ca_meacard
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_CA_MEACARD"" ENABLE"
"LYERP","TG_MPCS_EM_EQ","MPCS_EM_EQ","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_EM_EQ"" 
before  insert or update on mpcs_em_eq
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_EM_EQ"" ENABLE"
"LYERP","TG_MPCS_GMP_STD","MPCS_GMP_STD","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_GMP_STD"" 
before  insert or update on mpcs_gmp_std
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_GMP_STD"" ENABLE"
"LYERP","TG_MPCS_GMP_STDITEM","MPCS_GMP_STDITEM","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_GMP_STDITEM"" 
before  insert or update on mpcs_gmp_stditem
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_GMP_STDITEM"" ENABLE"
"LYERP","TG_MPCS_GMP_STD_GOODS","MPCS_GMP_STD_GOODS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_GMP_STD_GOODS"" 
before  insert or update on mpcs_gmp_std_goods
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_GMP_STD_GOODS"" ENABLE"
"LYERP","TG_MPCS_NM_GOODSPROC_DEF","MPCS_NM_GOODSPROC_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_DEF"" 
before  insert or update on mpcs_nm_goodsproc_def
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_DEF"" ENABLE"
"LYERP","TG_MPCS_NM_GOODSPROC_MAT","MPCS_NM_GOODSPROC_MAT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_MAT"" 
before  insert or update on mpcs_nm_goodsproc_mat
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_MAT"" ENABLE"
"LYERP","TG_MPCS_NM_GOODSPROC_PROC","MPCS_NM_GOODSPROC_PROC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_PROC"" 
before  insert or update on mpcs_nm_goodsproc_proc
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_PROC"" ENABLE"
"LYERP","TG_MPCS_NM_GOODSPROC_WKCENTER","MPCS_NM_GOODSPROC_WKCENTER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_WKCENTER"" 
before  insert or update on mpcs_nm_goodsproc_wkcenter
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_WKCENTER"" ENABLE"
"LYERP","TG_MPCS_NM_GOODSPROC_WKGROUP","MPCS_NM_GOODSPROC_WKGROUP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_WKGROUP"" 
before  insert or update on mpcs_nm_goodsproc_wkgroup
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_GOODSPROC_WKGROUP"" ENABLE"
"LYERP","TG_MPCS_NM_PROCESS_DEF","MPCS_NM_PROCESS_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_PROCESS_DEF"" 
before  insert or update on mpcs_nm_process_def
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_PROCESS_DEF"" ENABLE"
"LYERP","TG_MPCS_NM_PROCROUTE_DEF","MPCS_NM_PROCROUTE_DEF","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_DEF"" 
before  insert or update on mpcs_nm_procroute_def
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_DEF"" ENABLE"
"LYERP","TG_MPCS_NM_PROCROUTE_DEPT","MPCS_NM_PROCROUTE_DEPT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_DEPT"" 
before  insert or update on mpcs_nm_procroute_dept
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_DEPT"" ENABLE"
"LYERP","TG_MPCS_NM_PROCROUTE_GOODS","MPCS_NM_PROCROUTE_GOODS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_GOODS"" 
before  insert or update on mpcs_nm_procroute_goods
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_GOODS"" ENABLE"
"LYERP","TG_MPCS_NM_PROCROUTE_PROCESS","MPCS_NM_PROCROUTE_PROCESS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_PROCESS"" 
before  insert or update on mpcs_nm_procroute_process
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_NM_PROCROUTE_PROCESS"" ENABLE"
"LYERP","TG_MPCS_PR_BOM_DOC","MPCS_PR_BOM_DOC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_PR_BOM_DOC"" 
before  insert or update on mpcs_pr_bom_doc
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_PR_BOM_DOC"" ENABLE"
"LYERP","TG_MPCS_PR_BOM_DTL","MPCS_PR_BOM_DTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_MPCS_PR_BOM_DTL"" 
before  insert or update on mpcs_pr_bom_dtl
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_MPCS_PR_BOM_DTL"" ENABLE"
"LYERP","TG_PUB_COMPANY","PUB_COMPANY","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_COMPANY"" 
before  insert or update on pub_company
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_COMPANY"" ENABLE"
"LYERP","TG_PUB_CUSTOMER","PUB_CUSTOMER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_CUSTOMER"" 
before  insert or update on pub_customer
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_CUSTOMER"" ENABLE"
"LYERP","TG_PUB_ENTRY_CUSTOMER","PUB_ENTRY_CUSTOMER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_ENTRY_CUSTOMER"" 
before  insert or update on pub_entry_customer
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_ENTRY_CUSTOMER"" ENABLE"
"LYERP","TG_PUB_ENTRY_FACTORY","PUB_ENTRY_FACTORY","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_ENTRY_FACTORY"" 
before  insert or update on pub_entry_factory
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_ENTRY_FACTORY"" ENABLE"
"LYERP","TG_PUB_ENTRY_GOODS","PUB_ENTRY_GOODS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_ENTRY_GOODS"" 
before  insert or update on pub_entry_goods
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_ENTRY_GOODS"" ENABLE"
"LYERP","TG_PUB_ENTRY_SUPPLYER","PUB_ENTRY_SUPPLYER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_ENTRY_SUPPLYER"" 
before  insert or update on pub_entry_supplyer
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_ENTRY_SUPPLYER"" ENABLE"
"LYERP","TG_PUB_FACTORY","PUB_FACTORY","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_FACTORY"" 
before  insert or update on pub_factory
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_FACTORY"" ENABLE"
"LYERP","TG_PUB_GOODS","PUB_GOODS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_GOODS"" 
before  insert or update on pub_goods
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_GOODS"" ENABLE"
"LYERP","TG_PUB_GOODS_DETAIL","PUB_GOODS_DETAIL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_GOODS_DETAIL"" 
before  insert or update on pub_goods_detail
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_GOODS_DETAIL"" ENABLE"
"LYERP","TG_PUB_GOODS_UNIT","PUB_GOODS_UNIT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_GOODS_UNIT"" 
before  insert or update on pub_goods_unit
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_GOODS_UNIT"" ENABLE"
"LYERP","TG_PUB_SUPPLYER","PUB_SUPPLYER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TG_PUB_SUPPLYER"" 
before  insert or update on pub_supplyer
for each row

begin
:new.sys_modifydate:=sysdate;
end;


ALTER TRIGGER ""LYERP"".""TG_PUB_SUPPLYER"" ENABLE"
"LYERP","TRG_BMS_TR_POS_IN_UP","BMS_TR_POS_DEF","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_BMS_TR_POS_IN_UP"" 
AFTER INSERT OR UPDATE ON bms_tr_pos_def
FOR EACH ROW
BEGIN
   insert into pm_edi_queue
  (queueid, goodsownerid, credate, queuetype, srcid)
  select pm_edi_queue_seq.nextval as queueid,
         b.goodsownerid           as goodsownerid,
         sysdate                  as credate,
         6                        as queuetype,
         :new.tranposid              as srcid
    from pub_entry_customer a, pub_entry b
   where a.customid = :new.companyid
     and a.entryid = b.entryid
     and b.goodsownerid is not null
     and :new.usestatus = 1
     and a.usestatus = 1;
END;

ALTER TRIGGER ""LYERP"".""TRG_BMS_TR_POS_IN_UP"" ENABLE"
"LYERP","TRG_GOODSGROUP_FEEDBACK_HIS","WMS_GOODSGROUP_FEEDBACK","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_GOODSGROUP_FEEDBACK_HIS"" 
  BEFORE DELETE ON wms_goodsgroup_feedback
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into wms_goodsgroup_feedback_HIS
    (SEQID,
     GOODSOWNERID,
     CREDATE,
     ERPDOCID,
     ERPDTLID,
     GROUPID,
     OPERATIONTYPE,
     GOODSID,
     GOODSQTY,
     LOTNO,
     FINDATE,
     ERRMSG,
     DELDATE)
  VALUES
    (:OLD.SEQID,
     :OLD.GOODSOWNERID,
     :OLD.CREDATE,
     :OLD.ERPDOCID,
     :OLD.ERPDTLID,
     :OLD.GROUPID,
     :OLD.OPERATIONTYPE,
     :OLD.GOODSID,
     :OLD.GOODSQTY,
     :OLD.LOTNO,
     :OLD.FINDATE,
     :OLD.ERRMSG,
     SYSDATE);
END;


ALTER TRIGGER ""LYERP"".""TRG_GOODSGROUP_FEEDBACK_HIS"" ENABLE"
"LYERP","TRG_PUB_CUSTOM_SET_DTL_HIS","PUB_CUSTOM_SET_DTL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_PUB_CUSTOM_SET_DTL_HIS"" 
  BEFORE DELETE ON pub_custom_set_dtl
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into pub_custom_set_dtl_his
    (setid,setdtlid,customid,deldate)
  VALUES
    (:old.setid,:old.setdtlid,:old.customid,sysdate);
END;

ALTER TRIGGER ""LYERP"".""TRG_PUB_CUSTOM_SET_DTL_HIS"" ENABLE"
"LYERP","TRG_PUB_GOODS_SET_DTL_HIS","PUB_GOODS_SET_DTL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_PUB_GOODS_SET_DTL_HIS"" 
  BEFORE DELETE ON pub_goods_set_dtl
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into pub_goods_set_dtl_his
    (setid,setdtlid,goodsid,deldate)
  VALUES
    (:old.setid,:old.setdtlid,:old.goodsid,sysdate);
END;

ALTER TRIGGER ""LYERP"".""TRG_PUB_GOODS_SET_DTL_HIS"" ENABLE"
"LYERP","TRG_T101_HIS","T101","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T101_HIS"" 
  BEFORE DELETE ON T101
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
       
BEGIN
  insert into t101_HIS
    (goodsownerid,
     goodsownid,
     barcode,
     goodsno,
     gopcode,
     gopinyin,
     poison_drug,
     goodsname,
     goodsengname,
     goodsformalname,
     goodstype,
     prodarea,
     factname,
     tradepack,
     outpack,
     outrule,
     alarmdays,
     allowindays,
     allowoutdays,
     safestock,
     addmedcheckflag,
     pasteflag,
     wholesaleprice,
     resaleprice,
     purchasetax,
     saletax,
     lotflag,
     batchflag,
     comeflag,
     memo,
     drugform,
     status,
     otcflag,
     trademark,
     storagecondition,
     approvedocno,
     qualifydocno,
     goodsclassid,
     packsize,
     dbcheck,
     storagetype,
     periodunit,
     validperiod,
     varietyname,
     varietyno,
     supplyername,
     registdocno,
     varietydescid,
     KEYCONSERVEFLAG,
     ecodeflag,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     erpfactoryid,
     erpgoodsid,
     erpgoodsdtlid,
     impflag,
     seqid,
     mah,
     udicode,
     udiflag,
     TRANSCONDITION,
     BUSISCOPENAME,
     PRODLICENSENO,
     print_goodsname,
     print_goodstype, 
     zx_retainqty,   
     cre_date,
     del_date)
  VALUES
    (:OLD.goodsownerid,
     :OLD.goodsownid,
     :OLD.barcode,
     :OLD.goodsno,
     :OLD.gopcode,
     :OLD.gopinyin,
     :OLD.poison_drug,
     :OLD.goodsname,
     :OLD.goodsengname,
     :OLD.goodsformalname,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.tradepack,
     :OLD.outpack,
     :OLD.outrule,
     :OLD.alarmdays,
     :OLD.allowindays,
     :OLD.allowoutdays,
     :OLD.safestock,
     :OLD.addmedcheckflag,
     :OLD.pasteflag,
     :OLD.wholesaleprice,
     :OLD.resaleprice,
     :OLD.purchasetax,
     :OLD.saletax,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.memo,
     :OLD.drugform,
     :OLD.status,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.storagecondition,
     :OLD.approvedocno,
     :OLD.qualifydocno,
     :OLD.goodsclassid,
     :OLD.packsize,
     :OLD.dbcheck,
     :OLD.storagetype,
     :OLD.periodunit,
     :OLD.validperiod,
     :OLD.varietyname,
     :OLD.varietyno,
     :OLD.supplyername,
     :OLD.registdocno,
     :OLD.varietydescid,
     :old.KEYCONSERVEFLAG,
     :old.ecodeflag,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.erpfactoryid,
     :OLD.erpgoodsid,
     :OLD.erpgoodsdtlid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.mah,
     :OLD.udicode,
     :OLD.udiflag,
     :OLD.TRANSCONDITION,
     :OLD.BUSISCOPENAME,
     :OLD.PRODLICENSENO,
     :OLD.print_goodsname,
     :OLD.print_goodstype,
     :old.zx_retainqty, 
     :OLD.cre_date,
     SYSDATE);
END;


ALTER TRIGGER ""LYERP"".""TRG_T101_HIS"" ENABLE"
"LYERP","TRG_T102_HIS","T102","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T102_HIS"" 
  BEFORE DELETE ON T102
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
       BEGIN
  insert into t102_HIS
    (bank,
     goodsownerid,
     gcompanyid,
     companystyle,
     companyname,
     gopinyin,
     opcode,
     companyshortname,
     bankno,
     chiefofficer,
     connector,
     connphone,
     companytype,
     lotlimit,
     validdays,
     deliveraddr,
     province,
     credit,
     usedcredit,
     invoiceaddr,
     invoicehead,
     invoiceman,
     invoicephone,
     postcode,
     specialrequire,
     taxregistno,
     telephone,
     memo,
     addmedcheckflag,
     usestatus,
     companyno,
     station,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     erpcompanyid,
     impflag,
     seqid,
     cre_date,
     del_date)
  VALUES
    (:OLD.bank,
     :OLD.goodsownerid,
     :OLD.gcompanyid,
     :OLD.companystyle,
     :OLD.companyname,
     :OLD.gopinyin,
     :OLD.opcode,
     :OLD.companyshortname,
     :OLD.bankno,
     :OLD.chiefofficer,
     :OLD.connector,
     :OLD.connphone,
     :OLD.companytype,
     :OLD.lotlimit,
     :OLD.validdays,
     :OLD.deliveraddr,
     :OLD.province,
     :OLD.credit,
     :OLD.usedcredit,
     :OLD.invoiceaddr,
     :OLD.invoicehead,
     :OLD.invoiceman,
     :OLD.invoicephone,
     :OLD.postcode,
     :OLD.specialrequire,
     :OLD.taxregistno,
     :OLD.telephone,
     :OLD.memo,
     :OLD.addmedcheckflag,
     :OLD.usestatus,
     :OLD.companyno,
     :OLD.station,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.erpcompanyid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     SYSDATE);
END;


ALTER TRIGGER ""LYERP"".""TRG_T102_HIS"" ENABLE"
"LYERP","TRG_T103_HIS","T103","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T103_HIS"" 
  BEFORE DELETE ON T103
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
    
   BEGIN
  insert into t103_HIS
    (goodsownerid,
     gocompanyid,
     transid,
     inceptaddr,
     sendrecflag,
     connector,
     connphone,
     telefax,
     postcode,
     memo,
     usestatus,
     areacode,
     areaname,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     tranposname,
     impflag,
     seqid,
     cre_date,
     del_date,
     ybps)
  VALUES
    (:OLD.goodsownerid,
     :OLD.gocompanyid,
     :OLD.transid,
     :OLD.inceptaddr,
     :OLD.sendrecflag,
     :OLD.connector,
     :OLD.connphone,
     :OLD.telefax,
     :OLD.postcode,
     :OLD.memo,
     :OLD.usestatus,
     :OLD.areacode,
     :OLD.areaname,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.tranposname,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     SYSDATE,
     :OLD.ybps);
END;


ALTER TRIGGER ""LYERP"".""TRG_T103_HIS"" ENABLE"
"LYERP","TRG_T201_HIS","T201","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T201_HIS"" 
  BEFORE DELETE ON T201
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW


BEGIN
  insert into t201_HIS
    (goodsownerid,
     credate,
     goodsid,
     sourcecompanyid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     busiqty,
     qty,
     packsize,
     seqid,
     impflag,
     deldate
     )
  VALUES
    (
     :OLD.goodsownerid,
     :OLD.credate,
     :OLD.goodsid,
     :OLD.sourcecompanyid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.busiqty,
     :OLD.qty,
     :OLD.packsize,
     :OLD.seqid,
     :OLD.impflag,
     sysdate
     );
END;


ALTER TRIGGER ""LYERP"".""TRG_T201_HIS"" ENABLE"
"LYERP","TRG_T301_HIS","T301","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T301_HIS"" 
  BEFORE DELETE ON T301
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
    
BEGIN
  insert into t301_HIS
    (goodsownerid,
     porderid,
     credate,
     arrivedate,
     sourcecompanyid,
     companystyle,
     jobtype,
     operationtype,
     medicineclass,
     importflag,
     taxflag,
     dtllines,
     memo,
     porderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     lotflag,
     batchflag,
     comeflag,
     dtlmemo,
     inmode,
     fetchvaliddate,
     orderflag,
     packsize,
     sabackdate,
     sbreasonid,
     sadtlid,
     firstflag,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     packname,
     prtclass,
     bmsdocid,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     transid,
     del_date,
     NOWLFLAG,
     mulrecflag,
     AUTOFLAG,
     FROM_SALESID,
     FROM_SALESDTLID,
     autopassflag,
     to_sourcecompanyid,
     to_erpinid,
     to_erpindtlid,
     to_erpoutid,
     to_erpoutdtlid,
     agentname,
     price)
  VALUES
    (:OLD.goodsownerid,
     :OLD.porderid,
     :OLD.credate,
     :OLD.arrivedate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.importflag,
     :OLD.taxflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.porderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.dtlmemo,
     :OLD.inmode,
     :OLD.fetchvaliddate,
     :OLD.orderflag,
     :OLD.packsize,
     :OLD.sabackdate,
     :OLD.sbreasonid,
     :OLD.sadtlid,
     :OLD.firstflag,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.packname,
     :OLD.prtclass,
     :OLD.bmsdocid,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.transid,
     SYSDATE,
     :old.NOWLFLAG,
     :old.mulrecflag,
     :old.AUTOFLAG,
     :old.FROM_SALESID,
     :old.FROM_SALESDTLID,
     :old.autopassflag,
     :old.to_sourcecompanyid,
     :old.to_erpinid,
     :old.to_erpindtlid,
     :old.to_erpoutid,
     :old.to_erpoutdtlid,
     :old.agentname,
     :old.price);
END;


ALTER TRIGGER ""LYERP"".""TRG_T301_HIS"" ENABLE"
"LYERP","TRG_T302_HIS","T302","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T302_HIS"" 
  BEFORE DELETE ON T302
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
 
   
BEGIN
  insert into t302_HIS
    (goodsownerid,
     exporderid,
     lineno,
     credate,
     preexpdate,
     expcompanyid,
     companystyle,
     jobtype,
     addinvoiceflag,
     companytype,
     operationtype,
     medicineclass,
     receiveaddr,
     receivehead,
     receiveman,
     samelotflag,
     taxflag,
     transmodeid,
     urgenflag,
     dtllines,
     memo,
     exporderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     addmedcheckflag,
     dtlmemo,
     partexpflag,
     outmode,
     invoicetype,
     placesupplyid,
     placesupplydtlid,
     placeprice,
     resaleprice,
     placemoney,
     otcflag,
     trademark,
     qualitydocno,
     goodsclassname,
     packsize,
     isboxup,
     planarrive,
     pionarrive,
     addressid,
     spellbillno,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     orderflag,
     fixflag,
     salerid,
     salername,
     trdtlid,
     sasettledtlid,
     prtclass,
     prtorderset,
     prtgroupset,
     invno,
     packname,
     sorttype,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     transclass,
     storageid,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     lyzxcolumn1,
     lyzxcolumn2,
     lyzxcolumn3,
     lyzxcolumn4,
     lyzxcolumn5,
     lyzxcolumn6,
     lyzxcolumn7,
     lyzxcolumn8,
     lyzxcolumn9,
     lyzxcolumn10,
     lydtlzxcolumn1,
     lydtlzxcolumn2,
     lydtlzxcolumn3,
     lydtlzxcolumn4,
     lydtlzxcolumn5,
     lydtlzxcolumn6,
     lydtlzxcolumn7,
     lydtlzxcolumn8,
     lydtlzxcolumn9,
     lydtlzxcolumn10,
     lyzxcolumn11,
     lyzxcolumn12,
     lyzxcolumn13,
     lyzxcolumn14,
     lyzxcolumn15,
     lyzxcolumn16,
     lyzxcolumn17,
     lyzxcolumn18,
     lyzxcolumn19,
     lyzxcolumn20,
     del_date,
     NOWLFLAG,
     AUTOFLAG,
     FROM_SUDOCID,
     FROM_SUDTLID,
     to_transid,
     passingflag,
     autopassflag,
     to_expcompanyid,
     to_addressid,
     to_erpinid,
     to_erpoutid,
     to_erpindtlid,
     to_erpoutdtlid,
     to_printprice,
     to_printamt,
     zx_djflag,
     discount_falg,
     discount_sadtlid,
     discount_goodsid,
     discount_amt,
     discount_taxrate,
     ysorderflag,
     yscredate
     )
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.lineno,
     :OLD.credate,
     :OLD.preexpdate,
     :OLD.expcompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.addinvoiceflag,
     :OLD.companytype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.receiveaddr,
     :OLD.receivehead,
     :OLD.receiveman,
     :OLD.samelotflag,
     :OLD.taxflag,
     :OLD.transmodeid,
     :OLD.urgenflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.addmedcheckflag,
     :OLD.dtlmemo,
     :OLD.partexpflag,
     :OLD.outmode,
     :OLD.invoicetype,
     :OLD.placesupplyid,
     :OLD.placesupplydtlid,
     :OLD.placeprice,
     :OLD.resaleprice,
     :OLD.placemoney,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.qualitydocno,
     :OLD.goodsclassname,
     :OLD.packsize,
     :OLD.isboxup,
     :OLD.planarrive,
     :OLD.pionarrive,
     :OLD.addressid,
     :OLD.spellbillno,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.orderflag,
     :OLD.fixflag,
     :OLD.salerid,
     :OLD.salername,
     :OLD.trdtlid,
     :OLD.sasettledtlid,
     :OLD.prtclass,
     :OLD.prtorderset,
     :OLD.prtgroupset,
     :OLD.invno,
     :OLD.packname,
     :OLD.sorttype,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.transclass,
     :OLD.storageid,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.lyzxcolumn1,
     :OLD.lyzxcolumn2,
     :OLD.lyzxcolumn3,
     :OLD.lyzxcolumn4,
     :OLD.lyzxcolumn5,
     :OLD.lyzxcolumn6,
     :OLD.lyzxcolumn7,
     :OLD.lyzxcolumn8,
     :OLD.lyzxcolumn9,
     :OLD.lyzxcolumn10,
     :OLD.lydtlzxcolumn1,
     :OLD.lydtlzxcolumn2,
     :OLD.lydtlzxcolumn3,
     :OLD.lydtlzxcolumn4,
     :OLD.lydtlzxcolumn5,
     :OLD.lydtlzxcolumn6,
     :OLD.lydtlzxcolumn7,
     :OLD.lydtlzxcolumn8,
     :OLD.lydtlzxcolumn9,
     :OLD.lydtlzxcolumn10,
     :OLD.lyzxcolumn11,
     :OLD.lyzxcolumn12,
     :OLD.lyzxcolumn13,
     :OLD.lyzxcolumn14,
     :OLD.lyzxcolumn15,
     :OLD.lyzxcolumn16,
     :OLD.lyzxcolumn17,
     :OLD.lyzxcolumn18,
     :OLD.lyzxcolumn19,
     :OLD.lyzxcolumn20,
     SYSDATE,
     :old.NOWLFLAG,
     :old.AUTOFLAG,
     :old.FROM_SUDOCID,
     :old.FROM_SUDTLID,
     :old.to_transid,
     :old.passingflag,
     :old.autopassflag,
     :old.to_expcompanyid,
     :old.to_addressid,
     :old.to_erpinid,
     :old.to_erpoutid,
     :old.to_erpindtlid,
     :old.to_erpoutdtlid,
     :old.to_printprice,
     :old.to_printamt,
     :old.zx_djflag,
     :old.discount_falg,
     :old.discount_sadtlid,
     :old.discount_goodsid,
     :old.discount_amt,
     :old.discount_taxrate,
     :old.ysorderflag,
     :old.yscredate
     );
END;


ALTER TRIGGER ""LYERP"".""TRG_T302_HIS"" ENABLE"
"LYERP","TRG_T310_HIS","T310","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T310_HIS"" 
  BEFORE DELETE ON T310
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

      BEGIN
  insert into t310_his
    (goodsownerid,
     credate,
     jobflag,
     operationtype,
     jobid,
     jobdtlid,
     memo,
     impflag,
     del_date)
  values
    (:old.goodsownerid,
     :old.credate,
     :old.jobflag,
     :old.operationtype,
     :old.jobid,
     :old.jobdtlid,
     :old.memo,
     :old.impflag,
     sysdate);
end;


ALTER TRIGGER ""LYERP"".""TRG_T310_HIS"" ENABLE"
"LYERP","TRG_T320_HIS","T320","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T320_HIS"" 
  BEFORE DELETE ON T320
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
  
    
 
BEGIN
  insert into t320_HIS
    (goodsownerid,
     lorderid,
     porderid,
     operationtype,
     opstatus,
     arrivedate,
     putupdate,
     sourcecompanyid,
     companystyle,
     dtllines,
     memo,
     lorderdtlid,
     porderdtlid,
     srcdtlno,
     goodsid,
     storageid,
     goodsname,
     packname,
     packsize,
     packunit,
     batchno,
     lotno,
     validdate,
     prddate,
     approvedocno,
     goodstype,
     prodarea,
     factname,
     supplyname,
     goodstatus,
     quanstatus,
     tradepack,
     realrecvqty,
     tinyid,
     tinyqty,
     dtlmemo,
     medchkrptno,
     checkdate,
     transtemp,
     importrepflag,
     passgateflag,
     registeflag,
     medcheckflag,
     eligibilityflag,
     approveno,
     impregno,
     rptno,
     backwhyid,
     checkman1,
     checkman2,
     registno,
     sectionid,
     procerrflag,
     PRINTMONTHFLAG,
     del_date,
     INVNO,
     INVDATE,
     INVCODE,
     MAH,
     printexpireflag,
     VALIDDATE2,
     PRODMONTHFLAG)
  VALUES
    (:OLD.goodsownerid,
     :OLD.lorderid,
     :OLD.porderid,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.arrivedate,
     :OLD.putupdate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.lorderdtlid,
     :OLD.porderdtlid,
     :OLD.srcdtlno,
     :OLD.goodsid,
     :OLD.storageid,
     :OLD.goodsname,
     :OLD.packname,
     round(:OLD.packsize),
     :OLD.packunit,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.approvedocno,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.supplyname,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.tradepack,
     :OLD.realrecvqty,
     :OLD.tinyid,
     :OLD.tinyqty,
     :OLD.dtlmemo,
     :OLD.medchkrptno,
     :OLD.checkdate,
     :OLD.transtemp,
     :OLD.importrepflag,
     :OLD.passgateflag,
     :OLD.registeflag,
     :OLD.medcheckflag,
     :OLD.eligibilityflag,
     :OLD.approveno,
     :OLD.impregno,
     :OLD.rptno,
     :OLD.backwhyid,
     :OLD.checkman1,
     :OLD.checkman2,
     :OLD.registno,
     :OLD.sectionid,
     :OLD.procerrflag,
     :OLD.PRINTMONTHFLAG,
     SYSDATE,
     :OLD.INVNO,
     :OLD.INVDATE,
     :OLD.INVCODE,
     :OLD.MAH,
     :old.printexpireflag,
     :old.VALIDDATE2,
     :old.Prodmonthflag);
END;


ALTER TRIGGER ""LYERP"".""TRG_T320_HIS"" ENABLE"
"LYERP","TRG_T330_HIS","T330","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T330_HIS"" 
  BEFORE DELETE ON T330
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into t330_HIS
    (goodsownerid,
     lorderid,
     porderid,
     operationtype,
     opstatus,
     arrivedate,
     putupdate,
     sourcecompanyid,
     companystyle,
     dtllines,
     memo,
     lorderdtlid,
     porderdtlid,
     srcdtlno,
     goodsid,
     storageid,
     goodsname,
     packname,
     packsize,
     packunit,
     batchno,
     lotno,
     validdate,
     prddate,
     approvedocno,
     goodstype,
     prodarea,
     factname,
     supplyname,
     goodstatus,
     quanstatus,
     tradepack,
     realrecvqty,
     tinyid,
     tinyqty,
     dtlmemo,
     medchkrptno,
     checkdate,
     transtemp,
     importrepflag,
     passgateflag,
     registeflag,
     medcheckflag,
     eligibilityflag,
     approveno,
     impregno,
     rptno,
     backwhyid,
     checkman1,
     checkman2,
     registno,
     sectionid,
     procerrflag,
     printmonthflag,
     mah,
     printexpireflag,
     del_date,
     INVNO,
     INVDATE,
     INVCODE,
     VALIDDATE2,
     PRODMONTHFLAG)
  VALUES
    (:OLD.goodsownerid,
     :OLD.lorderid,
     :OLD.porderid,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.arrivedate,
     :OLD.putupdate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.lorderdtlid,
     :OLD.porderdtlid,
     :OLD.srcdtlno,
     :OLD.goodsid,
     :OLD.storageid,
     :OLD.goodsname,
     :OLD.packname,
     round(:OLD.packsize),
     :OLD.packunit,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.approvedocno,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.supplyname,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.tradepack,
     :OLD.realrecvqty,
     :OLD.tinyid,
     :OLD.tinyqty,
     :OLD.dtlmemo,
     :OLD.medchkrptno,
     :OLD.checkdate,
     :OLD.transtemp,
     :OLD.importrepflag,
     :OLD.passgateflag,
     :OLD.registeflag,
     :OLD.medcheckflag,
     :OLD.eligibilityflag,
     :OLD.approveno,
     :OLD.impregno,
     :OLD.rptno,
     :OLD.backwhyid,
     :OLD.checkman1,
     :OLD.checkman2,
     :OLD.registno,
     :OLD.sectionid,
     :OLD.procerrflag,
     :OLD.PRINTMONTHFLAG,
     :OLD.MAH,
     :old.printexpireflag,
     SYSDATE,
     :old.INVNO,
     :old.INVDATE,
     :old.INVCODE,
     :old.VALIDDATE2,
     :old.Prodmonthflag);
END;


ALTER TRIGGER ""LYERP"".""TRG_T330_HIS"" ENABLE"
"LYERP","TRG_T340_HIS","T340","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T340_HIS"" 
  BEFORE DELETE ON T340
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
  
    
 
 BEGIN
  insert into t340_HIS
    (goodsownerid,
     exporderid,
     srcexpno,
     lineno,
     operationtype,
     opstatus,
     preexpdate,
     prearrivedate,
     ttransmode,
     transno,
     expdate,
     gcompanyid,
     detaillines,
     exportmemo,
     srcexpdtlno,
     exporderdtlid,
     goodsid,
     batchno,
     lotno,
     validdate,
     prddate,
     goodstatus,
     quanstatus,
     approvedocno,
     registno,
     tradegoodspack,
     goodsqty,
     tradegoodsqty,
     expdtlmemo,
     packsize,
     status,
     gostockid,
     procerrflag,
     wholefinpacks,
     scatterfinpacks,
     del_date
     )
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.srcexpno,
     :OLD.lineno,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.preexpdate,
     :OLD.prearrivedate,
     :OLD.ttransmode,
     :OLD.transno,
     :OLD.expdate,
     :OLD.gcompanyid,
     :OLD.detaillines,
     :OLD.exportmemo,
     :OLD.srcexpdtlno,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.registno,
     :OLD.tradegoodspack,
     :OLD.goodsqty,
     :OLD.tradegoodsqty,
     :OLD.expdtlmemo,
     round(:OLD.packsize),
     :OLD.status,
     :OLD.gostockid,
     :OLD.procerrflag,
     :OLD.wholefinpacks,
     :OLD.scatterfinpacks,
     SYSDATE);
END;


ALTER TRIGGER ""LYERP"".""TRG_T340_HIS"" ENABLE"
"LYERP","TRG_T350_HIS","T350","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T350_HIS"" 
  BEFORE DELETE ON T350
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
  
    
 BEGIN
  insert into t350_HIS
    (goodsownerid,
     credate,
     jobflag,
     operationtype,
     jobid,
     jobdtlid,
     status,
     memo,
     cancelid,
     procerrflag,
     del_date)
  VALUES
    (:old.goodsownerid,
     :old.credate,
     :old.jobflag,
     :old.operationtype,
     :old.jobid,
     :old.jobdtlid,
     :old.status,
     :old.memo,
     :old.cancelid,
     :old.procerrflag,
     SYSDATE);
END;


ALTER TRIGGER ""LYERP"".""TRG_T350_HIS"" ENABLE"
"LYERP","TRG_T400_HIS","T400","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T400_HIS"" 
  BEFORE DELETE ON T400
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
BEGIN
insert into T400_his
  (goodsownerid,
   tradeid,
   tradedate,
   operationtype,
   dtllines,
   usestatus,
   tradedtlid,
   ownergoodsid,
   fromcompanyid,
   fromstorageid,
   fromgoodstatus,
   fromquanstatus,
   frombatchno,
   fromlotno,
   fromproddate,
   fromvaliddate,
   fromapproveno,
   tocompanyid,
   tostorageid,
   togoodstatus,
   toqunstatus,
   tobatchno,
   tolotno,
   toproddate,
   tovaliddate,
   toapproveno,
   tradegoodsqty,
   tradegoodspack,
   goodspackid,
   qty,
   gstorageid,
   packname,
   packsize,
   sectionid,
   fromregistno,
   toregistno,
   tosectionid,
   srcdtlid, --add by wanghuaiyu 20130714
   warehid, --add by xyue 2016-03-09
   mah, --add by xyue 2020-01-03
   tomah, --add by xyue 2020-01-03
   PRINTMONTHFLAG, --add by xyue 2020-11-10
   PRINTEXPIREFLAG, --add by xyue 2020-11-10
   FROMVALIDDATE2, --add by xyue 2023-08-05
   TOVALIDDATE2, --add by xyue 2023-08-05
   TOLOTNOFACTNAME,
   prodmonthflag,
   topackname,
   topacksize)
values
  (:old.goodsownerid,
   :old.tradeid,
   :old.tradedate,
   :old.operationtype,
   :old.dtllines,
   :old.usestatus,
   :old.tradedtlid,
   :old.ownergoodsid,
   :old.fromcompanyid,
   :old.fromstorageid,
   :old.fromgoodstatus,
   :old.fromquanstatus,
   :old.frombatchno,
   :old.fromlotno,
   :old.fromproddate,
   :old.fromvaliddate,
   :old.fromapproveno,
   :old.tocompanyid,
   :old.tostorageid,
   :old.togoodstatus,
   :old.toqunstatus,
   :old.tobatchno,
   :old.tolotno,
   :old.toproddate,
   :old.tovaliddate,
   :old.toapproveno,
   :old.tradegoodsqty,
   :old.tradegoodspack,
   :old.goodspackid,
   :old.qty,
   :old.gstorageid,
   :old.packname,
   :old.packsize,
   :old.sectionid,
   :old.fromregistno,
   :old.toregistno,
   :old.tosectionid,
   :old.srcdtlid, --add by wanghuaiyu 20130714
   :old.warehid, --add by xyue 2016-03-09
   :old.mah, --add by xyue 2020-01-03
   :old.tomah, --add by xyue 2020-01-03
   :old.PRINTMONTHFLAG, --add by xyue 2020-11-10
   :old.PRINTEXPIREFLAG, --add by xyue 2020-11-10
   :old.fromvaliddate2,
   :old.tovaliddate2,
   :old.tolotnofactname,
   :old.prodmonthflag,
   :old.topackname,
   :old.topacksize);
end;


ALTER TRIGGER ""LYERP"".""TRG_T400_HIS"" ENABLE"
"LYERP","TRG_T410_HIS","T410","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T410_HIS"" 
  BEFORE DELETE ON T410
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into t410_HIS
     (GOODSOWNERID,
      GOODSID,
      OLDLOTNO,
      NEWLOTNO,
      INVALIDDATE,
      PRODDATE,
      APPROVEDOCNO,
      REGISTDOCNO,
      SEQID,
      CRE_DATE,
      MODIFYID,
      MEMO,
      PRODLICENSENO,
      LOTID,
      PRINTMONTHFLAG,
      lotnofactname,--批号生产厂家 add by wanghuaiyu 2013年7月25日 18:23:00
      tolotnofactname,--调整后的批号生产厂家 add by wanghuaiyu 2013年7月25日 18:23:00
      DEL_DATE,
      killlotno,--add by xyue 2019-12-05 增加灭菌批号的修改
      tokilllotno,--add by xyue 2019-12-05 增加灭菌批号的修改
      mah,--add by xyue 2019-12-05 增加上市许可持有人的修改
      tomah,--add by xyue 2019-12-05 增加上市许可持有人的修改
      validdate2,
      tovaliddate2,
      PRINTEXPIREFLAG,
      PRODMONTHFLAG
      )
  VALUES
     (:OLD.GOODSOWNERID,
      :OLD.GOODSID,
      :OLD.OLDLOTNO,
      :OLD.NEWLOTNO,
      :OLD.INVALIDDATE,
      :OLD.PRODDATE,
      :OLD.APPROVEDOCNO,
      :OLD.REGISTDOCNO,
      :OLD.SEQID,
      :OLD.CRE_DATE,
      :OLD.MODIFYID,
      :OLD.MEMO,
      :OLD.PRODLICENSENO,
      :OLD.LOTID,
      :OLD.PRINTMONTHFLAG,
      :OLD.lotnofactname,
      :OLD.tolotnofactname,
      SYSDATE,
      :OLD.killlotno,--add by xyue 2019-12-05 增加灭菌批号的修改
      :OLD.tokilllotno,--add by xyue 2019-12-05 增加灭菌批号的修改
      :OLD.mah,--add by xyue 2019-12-05 增加上市许可持有人的修改
      :OLD.tomah,--add by xyue 2019-12-05 增加上市许可持有人的修改
      :old.validdate2,
      :old.tovaliddate2,
      :old.Printexpireflag,
      :old.Prodmonthflag
      );
END;


ALTER TRIGGER ""LYERP"".""TRG_T410_HIS"" ENABLE"
"LYERP","TRG_T800_HIS","T800","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T800_HIS"" 
  BEFORE DELETE ON T800
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
BEGIN
  insert into t800_his
    (goodsownerid,
     warehid,
     responseid,
     responsedate,
     responsetypeid,
     descr,
     inoutflag,
     operationtype,
     orderid,
     srcno,
     srcdtlno,
     getbacktime,
     getbackmemo,
     del_date)
  values
    (:old.goodsownerid,
     :old.warehid,
     :old.responseid,
     :old.responsedate,
     :old.responsetypeid,
     :old.descr,
     :old.inoutflag,
     :old.operationtype,
     :old.orderid,
     :old.srcno,
     :old.srcdtlno,
     :old.getbacktime,
     :old.getbackmemo,
     sysdate);
end;


ALTER TRIGGER ""LYERP"".""TRG_T800_HIS"" ENABLE"
"LYERP","TRG_T_OPTEST_UPDATE","T_OPTEST","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_T_OPTEST_UPDATE"" 
  Before Update On t_Optest
  For Each Row
Declare
  v_Count Number;
Begin
  
 dbms_output.put_line('sdfasd');
End;


ALTER TRIGGER ""LYERP"".""TRG_T_OPTEST_UPDATE"" ENABLE"
"LYERP","TRG_ZX111041","ZX_111041_WBZDMB","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_ZX111041"" 
BEFORE INSERT OR UPDATE ON zx_111041_wbzdmb FOR EACH ROW
BEGIN
    SELECT SYSDATE INTO :new.modify_time FROM dual;
END;


ALTER TRIGGER ""LYERP"".""TRG_ZX111041"" ENABLE"
"LYERP","TRG_ZX_PURCHASE_INVNO_HIS","ZX_PURCHASE_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_ZX_PURCHASE_INVNO_HIS"" 
  BEFORE DELETE ON ZX_PURCHASE_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into ZX_PURCHASE_INVNO_his
    (goodsownerid,
     suconid,
     sucondtlid,
     invcode,
     invno,
     invdate,
     credate,
     del_date,
     seqid)
  values
    (:old.goodsownerid,
     :old.suconid,
     :old.sucondtlid,
     :old.invcode,
     :old.invno,
     :old.invdate,
     :old.credate,
     sysdate,
     :old.seqid);
end;

ALTER TRIGGER ""LYERP"".""TRG_ZX_PURCHASE_INVNO_HIS"" ENABLE"
"LYERP","TRG_ZX_SALES_INVNO_HIS","ZX_SALES_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_ZX_SALES_INVNO_HIS"" 
  BEFORE DELETE ON ZX_SALES_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW


BEGIN
  insert into ZX_SALES_INVNO_his
    (salesdtlid,
     invno,
     seqid,
     goodsownerid,
     salesid,
     invoaddress,
     cre_date,
     del_date)
  values
    (:old.salesdtlid,
     :old.invno,
     :old.seqid,
     :old.goodsownerid,
     :old.salesid,
     :old.invoaddress,
     :old.cre_date,
     sysdate);
end;


ALTER TRIGGER ""LYERP"".""TRG_ZX_SALES_INVNO_HIS"" ENABLE"
"LYERP","TRG_ZX_SENDTMS","BMS_SA_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_ZX_SENDTMS"" 
  before update of tmsstatus on bms_sa_doc
  for each row
--erp销售发货单下传tms生成运输任务单触发器 add by xyue 2018-09-19
declare
  v_trid    number;
  v_tmstrid number;
  pragma autonomous_transaction; --自治事务
begin
  --目前只支持燕来福的订单且只下传到厦门物流中心
  if nvl(:old.tmsstatus, 0) <> nvl(:new.tmsstatus, 0) and
     :old.entryid in (64) and :new.tmsstatus = 1 then
    /*下传TMS*/
    select tms_tr_doc_seq.nextval@lywms into v_trid from dual;
  
    -- 插入运输任务单总单
    insert into tms_luyan_tr_doc@lywms
      (trid,
       warehid,
       goodsownerid,
       credate,
       tasktype,
       urgentflag,
       goodsownername,
       ROUTENAME,
       SCATTERPACKS,
       WHOLEPACKS,
       TOTALPACKS,
       comefrom, --手工录入
       sourceid, --随货同行号
       memo,
       INPUTMANID, --录入人系统管理员
       CHAINFLAG, --冷链标志
       TGFLAG, --特管标志
       province,
       city,
       district,
       poiname,
       longitude,
       latitude,
       address,
       companyname,
       printflag,
       curwarehid,
       salername,
       mobileno)
      select v_trid,
             1,
             a.entryid,
             a.credate,
             0, --任务类型，0是送货
             0, --加急标志
             d.entryname,
             e.translinename,
             a.totalpacks,
             0 WHOLEPACKS,
             a.totalpacks,
             2, --手工录入
             a.salesid, --随货同行号
             a.memo,
             0, --录入人系统管理员
             0, --冷链标志
             0, --特管标志
             c.province,
             c.city,
             c.district,
             c.poiname,
             c.longitude,
             c.latitude,
             c.province || c.city || c.district || c.addr address,
             a.customname,
             a.printflag,
             1,
             b.employeename,
             b.mobileno
        from bms_sa_doc        a,
             pub_employee      b,
             bms_tr_pos_def    c,
             pub_entry         d,
             pub_transline_def e
       where a.targetposid = c.tranposid(+)
         and a.salerid = b.employeeid
         and a.entryid = d.entryid(+)
         and c.translineid = e.translineid(+)
         and a.entryid = 64 --厦门燕来福单据
         and a.usestatus = 1 --正式状态
         and a.satypeid = 1 --销售类型
         and a.salesid = :old.salesid;
  
    -- 插入运输任务单细单
    insert into tms_luyan_tr_dtl@lywms
      (trid,
       trdtlid,
       goodsownid,
       goodsname,
       goodsengname,
       goodstype,
       goodsunit,
       prodarea,
       FACTNAME,
       lotno,
       proddate,
       VALIDDATE,
       goodsqty)
      select v_trid,
             tms_luyan_tr_dtl_seq.nextval@lywms,
             tt.goodsid goodsownid,
             tt.goodsname,
             tt.currencyname goodsengname,
             tt.goodstype,
             tt.goodsunit,
             tt.prodarea,
             tt.factoryname,
             tt.lotno,
             tt.proddate,
             tt.invaliddate VALIDDATE,
             tt.goodsqty
        from zx_tms_luyan_tr_dtl_v tt
       where tt.salesid = :old.salesid;
  
    --回填运输任务单到销售发货总单上，用于回退时候使用
    select v_trid into :new.tmstrid from dual;
    commit;
  end if;

  if nvl(:old.tmsstatus, 0) = 1 and :old.entryid in (64) and
     nvl(:new.tmsstatus, 0) = 0 then
    /*取消TMS*/
    select a.tmstrid
      into v_tmstrid
      from bms_sa_doc a
     where a.salesid = :old.salesid;
    --删除运输任务单，是否是待派车状态已经在按钮上控制
    delete tms_luyan_tr_dtl@lywms a where a.trid = v_tmstrid;
    delete tms_luyan_tr_doc@lywms a where a.trid = v_tmstrid;
    --同时清空订单上的运输任务单ID
    select null into :new.tmstrid from dual;
    commit;
  end if;

end;


ALTER TRIGGER ""LYERP"".""TRG_ZX_SENDTMS"" ENABLE"
"LYERP","TRG_ZZ_WX_SEND_REWARD_HIS","ZZ_WX_SEND_REWARD","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRG_ZZ_WX_SEND_REWARD_HIS"" 
  BEFORE DELETE ON zz_wx_send_reward
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into zz_wx_send_reward_his
    (rsadtlid,credate)
  VALUES
    (:OLD.rsadtlid,
     sysdate);
END;

ALTER TRIGGER ""LYERP"".""TRG_ZZ_WX_SEND_REWARD_HIS"" ENABLE"
"LYERP","TRI_AFUPD_BMS_ST_RG_DOC","BMS_ST_RG_DOC","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_AFUPD_BMS_ST_RG_DOC"" 
  after update on bms_st_rg_doc
  for each row
     
begin
  if :new.usestatus=1 and :old.usestatus=2 then
     --EMF 正常状态的收获明细生成RF上架任务表
    insert into emf_rflist_carryin(rggoodsdtlid,rfmanid,flag)
    select a.rgdtlid,min(b.rfmanid),0
    from bms_st_rg_dtl a,emf_rf_man b,bms_storer_pos c
    where a.posid=c.posid and c.posno like b.posmatchcode and b.carryin=1
     and a.rgid=:new.rgid
    group by a.rgdtlid;
  elsif :new.usestatus=2 and :old.usestatus=1 then
    --EMF 收货单确定后删除任务表
    delete from emf_rflist_carryin a where a.rggoodsdtlid in
    (select b.rgdtlid from bms_st_rg_dtl b where b.rgid=:new.rgid);
  end if;
end tri_afupd_bms_st_rg_doc;


ALTER TRIGGER ""LYERP"".""TRI_AFUPD_BMS_ST_RG_DOC"" ENABLE"
"LYERP","TRI_BFDEL_BMS_ST_IO_DTL_TMP","BMS_ST_IO_DTL_TMP","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_BFDEL_BMS_ST_IO_DTL_TMP"" 
BEFORE DELETE 
ON BMS_ST_IO_DTL_TMP
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW 
  begin
  --EMF删除RF拣货任务表
  delete from emf_rflist_pickup where stiodtlid=:old.iodtlid;
end tri_bfdel_bms_st_io_dtl_tmp;


ALTER TRIGGER ""LYERP"".""TRI_BFDEL_BMS_ST_IO_DTL_TMP"" ENABLE"
"LYERP","TRI_BMS_SA_INV_INFO","BMS_SA_INV_INFO","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_BMS_SA_INV_INFO"" 
  Before Update On bms_sa_inv_info
  For Each Row
Declare
  -- local variables here
Begin
  If nvl(:old.eshopflag, -1) = nvl(:new.eshopflag, -1)  Then
    :new.eshopflag := Null;
  End If;

End tri_bms_sa_inv_info;

ALTER TRIGGER ""LYERP"".""TRI_BMS_SA_INV_INFO"" ENABLE"
"LYERP","TRI_BMS_TR_POS_DEF","BMS_TR_POS_DEF","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_BMS_TR_POS_DEF"" 
  Before Update On bms_tr_pos_def
  For Each Row
Declare
  -- local variables here
Begin
  If nvl(:old.eshopflag, -1) = nvl(:new.eshopflag, -1) and nvl(:old.usestatus, -1) = nvl(:new.usestatus, -1) Then
    :new.eshopflag := Null;
  End If;

End tri_bms_tr_pos_def;

ALTER TRIGGER ""LYERP"".""TRI_BMS_TR_POS_DEF"" ENABLE"
"LYERP","TRI_ERPUPDATERECORD","ERPUPDATERECORD","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_ERPUPDATERECORD"" 
  After Insert On ERPUPDATERECORD
  For Each Row
Declare
  v_opname Varchar2(100);
Begin
  --同步插入工作日志
  If :new.gxrid = 1503 And :New.Type Not  In ('系统更新')  Then
    If :new.opid Is Not Null Then
      If :New.Systype = 'erp' Then
        If :New.Type In ('专项功能', '系统更新', '数据库') Then
          Select a.opname
            Into v_opname
            From Np_Op a
           Where a.opid = :new.opid;
        End If;
      
        If :New.Type In ('hov') Then
          Select a.hovname
            Into v_opname
            From Np_Hov a
           Where a.hovid = :new.opid;
        End If;
      
      End If;
    
      If :New.Systype = 'wms' Then
        If :New.Type In ('专项功能', '系统更新', '数据库') Then
          Select a.opname
            Into v_opname
            From Lywms.Np_Op a
           Where a.opid = :new.opid;
        End If;
      
        If :New.Type In ('hov') Then
          Select a.hovname
            Into v_opname
            From Lywms.Np_Hov a
           Where a.hovid = :new.opid;
        End If;
      
      End If;
    End If;
    Insert Into t_101128
      (seqid, credate, lx, gs, gzgc, zdr)
    Values
      (T_101128_SEQ.Nextval,
       :new.gxsj,
       2,
       :new.hfgr*8*60,
       v_opname || :new.wtms,
       :new.gxrid);
  
  End If;

End tri_ERPUPDATERECORD;

ALTER TRIGGER ""LYERP"".""TRI_ERPUPDATERECORD"" ENABLE"
"LYERP","TRI_GSP_GOODS_FACTORY_CHECK","GSP_GOODS_FACTORY_CHECK","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_GSP_GOODS_FACTORY_CHECK"" 
  before insert or update on GSP_GOODS_FACTORY_CHECK
  for each row
DECLARE
  v_count number;
  pragma autonomous_transaction; --自治事物
begin
  --只有后面新增的单子才会检测entryid lotid重复问题
 if nvl(:new.fcheckid,:old.fcheckid)>329990 then

  select count(1)
    into v_count
    from GSP_GOODS_FACTORY_CHECK t
   where nvl(t.entryid, -1) = nvl(:new.entryid, -1)
     and nvl(t.lotid, -1) = nvl(:new.lotid,-1)
     and rowid<>:new.rowid  --排除自身
     ;
  if v_count > 0 then
    RAISE_APPLICATION_ERROR(-20001, '独立单元id 批号id不能重复');
  end if;

  end if;
  --:new.c7:=replace(replace(trim(:new.c7),chr(10),''),chr(13),'');
end;


ALTER TRIGGER ""LYERP"".""TRI_GSP_GOODS_FACTORY_CHECK"" ENABLE"
"LYERP","TRI_INS_YBH_T_KHXYED_KDSP","YBH_T_KHXYED_KDSP","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_INS_YBH_T_KHXYED_KDSP"" 
  Before Insert On ybh_t_khxyed_kdsp
  For Each Row
Declare
  -- 解决错误ORA-04091
  Pragma Autonomous_Transaction;
  v_cqts               Number; --超期天数
  v_cqje               Number; --超期金额
  v_cxyed              Number; --超信誉额度
  v_yjxse              Number; --月均销售额
  v_hkje               Number; --本月累计回款金额
  v_hkje3              Number; --前三个月月均回款金额
  v_customid           Number;
  v_entryid            Number;
  v_ZX_XYEDYJHKJE_LAST Number; --上月超期款预计回款金额
  v_ZX_XYEDYJHKRQ_LAST Date; --上月超期款预计回款日期
  v_ZX_XYEDSQLY_LAST   Varchar(3000); --上月申请理由
  v_ZX_SYSJHKZE        Number; --上月实际回款总额
  v_ZX_BYLJKDJE        Number; --本月累计开单金额
Begin

  --更新 信誉情况 审批节点 避免查询速度慢 --add by ybh 2023年2月13日 
  --信誉情况
  :New.Xyqk := ybh_f_get_xyqk(:new.Salesid, Sysdate);
  --审批节点
  :New.Flow_Node := ybh_f_get_flow_node_sale(:new.Salesid);

  --记录超期天数 超期金额 超信誉额度  用于报表展示 多个取最大 --add by ybh 2023年3月28日 

  Select GREATEST(Ybh_f_khedkz5(a.salesid, '超期天数', Null),
                  Ybh_f_khedkz5(a.salesid, '超期天数', 1),
                  Ybh_f_khedkz5(a.salesid, '超期天数', 2),
                  Ybh_f_khedkz5(a.salesid, '超期天数', 3)) cqts,
         Greatest(Ybh_f_khedkz5(a.salesid, '超期金额', Null),
                  Ybh_f_khedkz5(a.salesid, '超期金额', 1),
                  Ybh_f_khedkz5(a.salesid, '超期金额', 2),
                  Ybh_f_khedkz5(a.salesid, '超期金额', 3)) cqje,
         
         Greatest(Ybh_f_khedkz5(a.salesid, '超信誉额度', Null),
                  Ybh_f_khedkz5(a.salesid, '超信誉额度', 1),
                  Ybh_f_khedkz5(a.salesid, '超信誉额度', 2),
                  Ybh_f_khedkz5(a.salesid, '超信誉额度', 3)) cxyed,
         Greatest(Ybh_f_khedkz5(a.salesid, '月均销售额', Null),
                  Ybh_f_khedkz5(a.salesid, '月均销售额', 1),
                  Ybh_f_khedkz5(a.salesid, '月均销售额', 2),
                  Ybh_f_khedkz5(a.salesid, '月均销售额', 3)) yjxse
    Into v_cqts, v_cqje, v_cxyed, v_yjxse
    From bms_sa_doc a
   Where a.salesid = :new.Salesid;

  :new.Cqts  := v_cqts;
  :new.Cqje  := v_cqje;
  :new.Cxyed := v_cxyed;
  :new.Yjxse := v_yjxse;

  Select a.customid, a.entryid
    Into v_customid, v_entryid
    From bms_sa_doc a
   Where a.salesid = :new.Salesid;

  --本月累计回款金额  --add by ybh 2023年3月28日 

  /* Select Sum(b.total_line)
    Into v_hkje
    From bms_sa_rec_doc a, bms_sa_rec_dtl b
   Where a.sarecid = b.sarecid
     And a.credate Between Trunc(Sysdate, 'mm') And Sysdate
     And a.recmethod In (3)
     And a.usestatus = 1
     And a.customid = v_customid
     And a.entryid = v_entryid
  
  ;*/

  --add by ybh 2023年5月22日 收款增加预收核销的数据
  Select Sum(a.total_line)
    Into v_hkje
    From v_cqce_sk a
   Where a.credate Between Trunc(Sysdate, 'mm') And Sysdate
     And a.customid = v_customid
     And a.entryid = v_entryid;

  --前三个月月均回款金额

  /* Select round(Sum(b.total_line) / 3, 2)
    Into v_hkje3
    From bms_sa_rec_doc a, bms_sa_rec_dtl b
   Where a.sarecid = b.sarecid
     And a.credate Between add_months(Trunc(Sysdate, 'mm'), -3) And
         Trunc(Sysdate, 'mm')
     And a.recmethod In (3)
     And a.usestatus = 1
     And a.customid = v_customid
     And a.entryid = v_entryid
  
  ;*/

  Select round(Sum(a.total_line) / 3, 2)
    Into v_hkje3
    From v_cqce_sk a
   Where a.credate Between add_months(Trunc(Sysdate, 'mm'), -3) And
         Trunc(Sysdate, 'mm')
     And a.customid = v_customid
     And a.entryid = v_entryid;

  --add by ybh 2023年6月16日  上月实际回款总额
  Select Sum(a.total_line)
    Into v_ZX_SYSJHKZE
    From v_cqce_sk a
   Where a.credate Between Trunc(add_months(Sysdate, -1), 'mm') And
         Trunc(Sysdate, 'mm')
     And a.customid = v_customid
     And a.entryid = v_entryid;

  :new.Zx_Sysjhkze := v_ZX_SYSJHKZE;

  --add by ybh 2023年7月26日 本月累计开单金额 
  Select Nvl(Sum(b.total_line), 0)
    Into v_ZX_BYLJKDJE
    From bms_sa_doc a, bms_sa_dtl b
   Where a.salesid = b.salesid
     And a.usestatus In (1)
     And a.credate Between Trunc(Sysdate, 'mm') And Sysdate
     And a.entryid = v_entryid
     And a.customid = v_customid
    
     And Nvl(a.initflag, 0) = 0;
  :new.zx_byljkdje := v_ZX_BYLJKDJE;
  
  --获取上月首次申请单申请理由  超期款预计回款金额 超期款预计回款日期  add by ybh 2023年6月16日 
  Begin
    Select a.zx_xyedsqly, a.ZX_XYEDYJHKJE, a.ZX_XYEDYJHKRQ
      Into v_ZX_XYEDSQLY_LAST, v_ZX_XYEDYJHKJE_LAST, v_ZX_XYEDYJHKRQ_LAST
      From (Select '申请日期:' || to_char(t.sqrq, 'yyyy-mm-dd') || ' ' ||
                   t.zx_xyedsqly zx_xyedsqly,
                   t.ZX_XYEDYJHKJE,
                   t.ZX_XYEDYJHKRQ
              From YBH_T_KHXYED_KDSP t
             Where t.sqrq Between Trunc(add_months(Sysdate, -1), 'mm') And
                   Trunc(Sysdate, 'mm')
               And t.entryid = v_entryid
               And t.customid = v_customid
             Order By t.sqrq) a
     Where Rownum = 1;
    :New.Zx_Xyedsqly_Last   := v_ZX_XYEDSQLY_LAST;
    :New.ZX_XYEDYJHKJE_LAST := v_ZX_XYEDYJHKJE_LAST;
    :New.ZX_XYEDYJHKRQ_LAST := v_ZX_XYEDYJHKRQ_LAST;
  
  Exception
    When Others Then
      v_ZX_XYEDSQLY_LAST := '';
  End;

  :new.Hkje  := v_hkje;
  :new.Hkje3 := v_hkje3;

  --带量信息 --add by ybh 2023年3月28日 
  :new.Lncqts := ybh_f_get_dl_gkxx(:new.Salesid, '量内超期天数');
  :new.Lwcqts := ybh_f_get_dl_gkxx(:new.Salesid, '量外超期天数');

End tri_ins_YBH_T_KHXYED_KDSP;

ALTER TRIGGER ""LYERP"".""TRI_INS_YBH_T_KHXYED_KDSP"" ENABLE"
"LYERP","TRI_NP_EMPLOYEE_ROLE","NP_EMPLOYEE_ROLE","INSERT OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_NP_EMPLOYEE_ROLE"" 
  Before Insert Or Delete On np_employee_role
  For Each Row

Declare

  v_employeeid  Number;
  v_roleid      Number;
  v_modify_info Varchar(1000); --修改人信息
  v_content     Varchar(4000);
Begin
  v_modify_info := 'ip:' || SYS_CONTEXT('USERENV', 'IP_ADDRESS') || ' 主机:' ||
                   sys_context('USERENV', 'HOST') || ' 用户名:' ||
                   sys_context('USERENV', 'OS_USER');
  v_employeeid  := nvl(:New.employeeid, :old.employeeid);
  v_roleid      := nvl(:New.roleid, :old.roleid);
  If inserting Then
    v_content := '新增人员授权 ';
  End If;

  If deleting Then
    v_content := '删除人员授权 ';
  End If;

  Insert Into t_101204
    (seqid, employeeid, roleid, content, credate, modifier)
  Values
    (t_101204_seq.nextval,
     v_employeeid,
     v_roleid,
     v_content,
     Sysdate,
     v_modify_info);

End;

ALTER TRIGGER ""LYERP"".""TRI_NP_EMPLOYEE_ROLE"" ENABLE"
"LYERP","TRI_NP_OP_AP","NP_OP_AP","INSERT OR UPDATE OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_NP_OP_AP"" 
  Before Insert Or Update Or Delete On np_op_ap
  For Each Row
Declare
  -- local variables here
  v_opid        Number;
  v_roleid      Number;
  v_modify_info Varchar(1000); --修改人信息
  v_content     Varchar(4000);
Begin
  v_modify_info := 'ip:' || SYS_CONTEXT('USERENV', 'IP_ADDRESS') || ' 主机:' ||
                   sys_context('USERENV', 'HOST') || ' 用户名:' ||
                   sys_context('USERENV', 'OS_USER');

  Select a.opid, a.roleid
    Into v_opid, v_roleid
    From np_role_op a
   Where a.roleopid = nvl(:Old.Roleopid, :new.Roleopid);
  If inserting Then
    v_content := '新增授权 aptype:' || :new.Aptype || ' apname:' || :new.Apname ||
                 ' apvalue:' || :new.Apvalue;
  End If;

  If deleting Then
    v_content := '删除授权 aptype:' || :old.Aptype || ' apname:' || :old.Apname ||
                 ' apvalue:' || :old.Apvalue;
  End If;
  If updating Then
    v_content := '修改授权 aptype由 ' || :old.aptype || ' 改成 ' || :new.aptype ||
                 ' Apname由 ' || :old.Apname || ' 改成 ' || :new.Apname ||
                 ' apvalue由 ' || :old.Apvalue || ' 改成 ' || :new.Apvalue;
  End If;

  Insert Into t_101202
    (seqid, opid, roleid, content, credate, tablename, pkvalue, modifier)
  Values
    (t_101202_seq.nextval,
     v_opid,
     v_roleid,
     v_content,
     Sysdate,
     'np_op_ap',
     nvl(:New.Apid, :old.Apid),
     v_modify_info);

End tri_np_op_ap;

ALTER TRIGGER ""LYERP"".""TRI_NP_OP_AP"" ENABLE"
"LYERP","TRI_NP_ROLE_OP","NP_ROLE_OP","INSERT OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_NP_ROLE_OP"" 
  Before Insert Or Delete On np_role_op
  For Each Row

Declare
  -- local variables here
  v_opid        Number;
  v_roleid      Number;
  v_modify_info Varchar(1000); --修改人信息
  v_content     Varchar(4000);
Begin
  v_modify_info := 'ip:' || SYS_CONTEXT('USERENV', 'IP_ADDRESS') || ' 主机:' ||
                   sys_context('USERENV', 'HOST') || ' 用户名:' ||
                   sys_context('USERENV', 'OS_USER');
  v_opid        := nvl(:New.Opid, :old.Opid);
  v_roleid      := nvl(:New.roleid, :old.roleid);
  If inserting Then
    v_content := '新增功能';
  End If;

  If deleting Then
    v_content := '删除功能';
  End If;

  Insert Into t_101202
    (seqid, opid, roleid, content, credate, tablename, pkvalue, modifier)
  Values
    (t_101202_seq.nextval,
     v_opid,
     v_roleid,
     v_content,
     Sysdate,
     'np_role_op',
     nvl(:New.Roleopid, :old.Roleopid),
     v_modify_info);

End;

ALTER TRIGGER ""LYERP"".""TRI_NP_ROLE_OP"" ENABLE"
"LYERP","TRI_PUB_EMPLOYEE_ESHOP","PUB_EMPLOYEE","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_PUB_EMPLOYEE_ESHOP"" 
  Before Update On pub_employee
  For Each Row
Declare
  -- local variables here
Begin
  If nvl(:old.eshopflag, -1) = nvl(:new.eshopflag, -1) Then
    :new.eshopflag := Null;
  End If;

End tri_pub_employee_eshop;

ALTER TRIGGER ""LYERP"".""TRI_PUB_EMPLOYEE_ESHOP"" ENABLE"
"LYERP","TRI_T_HPSKFLBM","T_HPSKFLBM","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_T_HPSKFLBM"" 
before insert or update   on T_HPSKFLBM
for each row
begin
  --解决功能101052，税控分类编码前后添加空格回车导致重复数据
  :new.skflbm:=replace(replace(trim(:new.skflbm),chr(10),''),chr(13),'');
end;


ALTER TRIGGER ""LYERP"".""TRI_T_HPSKFLBM"" ENABLE"
"LYERP","TRI_UPDATE_GRESA_SA_DOC","GRESA_SA_DOC","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_UPDATE_GRESA_SA_DOC"" 
  After Update Of usestatus On gresa_sa_doc
  For Each Row
Declare
  v_count Number;
Begin
 /* Select Count(1)
    Into v_count
    From gpcs_placepoint a
   Where a.placepointid = :new.Placepointid
     And a.entryid In (6);*/

  If :new.usestatus = 1 /*And v_count > 0*/ Then
    --modify by ybh 2022年7月11日 9:16:30  增加关联 阶梯 类型
    Insert Into zz_wx_send_reward
      (rsadtlid)
      Select b.rsadtlid
        From gresa_sa_dtl b,pub_employee c
       Where (b.getmoneylevel Like 'H%' Or b.getmoneylevel Like 'L%' Or
             b.getmoneylevel Like 'G%')
         And b.getmoneylevel Not Like 'H0'
         And b.rsaid = :New.rsaid
         and b.clerkerid=c.employeeid
         and exists (select 1 from zz_wx_clerker_userno d where d.erpid=b.clerkerid);
  
  End If;

End;

ALTER TRIGGER ""LYERP"".""TRI_UPDATE_GRESA_SA_DOC"" ENABLE"
"LYERP","TRI_YBH_T_TEST","YBH_T_TEST","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_YBH_T_TEST"" 
  Before Update   On ybh_t_test
  For Each Row
Declare
  -- local variables here
Begin
  If nvl(:old.C3, -1) = nvl(:new.C3, -1)  Then
    :new.C3 := Null;
  End If;

End tri_ybh_t_test;

ALTER TRIGGER ""LYERP"".""TRI_YBH_T_TEST"" DISABLE"
"LYERP","TRI_Y_TEST","Y_TEST","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TRI_Y_TEST"" 
  before insert or update on y_test
  for each row
DECLARE
  v_count number;
  pragma autonomous_transaction; --自治事物
begin
 --RAISE_APPLICATION_ERROR(-20001, nvl(:new.c4,-1));
 /* select count(1)
    into v_count
    from Y_TEST t
   where nvl(t.c3, 0) = nvl(:new.c3, 0)
     and nvl(t.c4, 0) = nvl(:new.c4,0)
     and rowid<>:new.rowid;
  if v_count > 0 then
    RAISE_APPLICATION_ERROR(-20001, 'sdfads');
  end if;*/
  :new.c7:=replace(replace(trim(:new.c7),chr(10),''),chr(13),'');
end;


ALTER TRIGGER ""LYERP"".""TRI_Y_TEST"" ENABLE"
"LYERP","TR_AFTINS_T_EDI_ENTRYGOODS","T_EDI_ENTRYGOODS","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_AFTINS_T_EDI_ENTRYGOODS"" 
   after insert
   ON T_EDI_ENTRYGOODS
   FOR EACH ROW
    -- declare
--PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  if :new.uploaddate is not null then
  
    p_edi_upload3@lyerp22(to_char(:new.uploaddate, 'yyyy-mm-dd'),
                          :new.entryid,
                          :new.goodsid);

  end if;
  --commit;
END;


ALTER TRIGGER ""LYERP"".""TR_AFTINS_T_EDI_ENTRYGOODS"" ENABLE"
"LYERP","TR_BMS_OF_DTL_BATCH","BMS_OF_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_BMS_OF_DTL_BATCH"" 
  before UPDATE OF lotid ON bms_of_dtl
  FOR EACH ROW
declare

  v_batchid number;
BEGIN

  select max(c.batchid)
    into v_batchid
    from bms_st_io_doc b, bms_st_io_dtl c
   where b.inoutid = c.inoutid
     and b.inoutflag = 1
     and b.storageid = :old.storageid
     and b.goodsid = :old.goodsid
     and c.lotid = :new.lotid;
  :new.batchid := v_batchid;

END;


ALTER TRIGGER ""LYERP"".""TR_BMS_OF_DTL_BATCH"" ENABLE"
"LYERP","TR_BMS_OF_DTL_BATCH1","BMS_OF_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_BMS_OF_DTL_BATCH1"" 
  before insert on bms_of_dtl
  for each row
declare

  v_batchid number;
BEGIN

  select max(c.batchid)
    into v_batchid
    from bms_st_io_doc b, bms_st_io_dtl c
   where b.inoutid = c.inoutid
     and b.inoutflag = 1
     and b.storageid = :new.storageid
     and b.goodsid = :new.goodsid
     and c.lotid = :new.lotid;
  :new.batchid := v_batchid;

END;


ALTER TRIGGER ""LYERP"".""TR_BMS_OF_DTL_BATCH1"" ENABLE"
"LYERP","TR_BMS_ST_RG_DTL","BMS_ST_RG_DTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_BMS_ST_RG_DTL"" 
BEFORE UPDATE OF posid,goodsdtlid
       OR INSERT
ON bms_st_rg_dtl
FOR EACH ROW
--WHEN (nvl(new.posid,-1) = -1)
BEGIN
  /*IF NVL(:new.posid,-1) = -1 THEN
    RAISE_APPLICATION_ERROR(-20001, '货位不能为空');
  END IF;*/
   IF NVL(:new.goodsdtlid,-1) = -1 THEN
     RAISE_APPLICATION_ERROR(-20002, '货品明细不能为空，请点击货品操作码HOV，选择包装信息');
    END IF;
END;


ALTER TRIGGER ""LYERP"".""TR_BMS_ST_RG_DTL"" ENABLE"
"LYERP","TR_BMS_ST_RG_DTL_DEL","BMS_ST_RG_DTL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_BMS_ST_RG_DTL_DEL"" 
BEFORE DELETE ON BMS_ST_RG_DTL
FOR EACH ROW
begin
  if nvl(:old.targetsourceid,-1) != -1 then
  raise_application_error(-20002, '已经生成业务单据,禁止删除!');
  END IF;
END;


ALTER TRIGGER ""LYERP"".""TR_BMS_ST_RG_DTL_DEL"" ENABLE"
"LYERP","TR_BMS_SU_CON_DTL_U","BMS_SU_CON_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_BMS_SU_CON_DTL_U"" 
before update of receiveqty1
on BMS_SU_CON_DTL
for each row
begin
  if :new.receiveqty1>0 
    and  :new.dhsj is null and   :old.dhsj   is null
    then
    select sysdate into :new.dhsj from dual;
  end if;
end;


ALTER TRIGGER ""LYERP"".""TR_BMS_SU_CON_DTL_U"" ENABLE"
"LYERP","TR_GPCS_INSIDER_INTEGRALINFO_I","GPCS_INSIDER_INTEGRALINFO","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_GPCS_INSIDER_INTEGRALINFO_I"" 
 after insert
 on gpcs_insider_integralinfo
 for each row
  /* declare
     p_openlength number;*/
begin
  /*select length(openid) into p_openlength from gpcs_insider where insiderid=:new.insiderid;
  if p_openlength>1 then
    begin*/
      insert into zz_template@lyerp22(INSIDERID,INSIDERCARDNO,INSIDERNAME,COMEFROM,DOCID,CREDATE,INTEGAL,FLAG,OPENID,PLACEPOINT)
      select a.insiderid,a.insidercardno,a.insidername,(SELECT  max(ddlname) FROM sys_ddl_all_v t WHERE t.keyword='GPCS_INSIDER_INTEINFO_COMEFROM'  AND ddlid=:new.comefrom),
      :new.docid,:new.credate,case when :new.debitintegal>0 then :new.debitintegal else :new.lenderintegal*-1 end,
      0,a.openid,(select max(placepointname) from GRESA_SA_doc_v where rsaid=:new.docid )
      from gpcs_insider a where a.insiderid=:new.insiderid;
/*    end;
  end if;*/
end;


ALTER TRIGGER ""LYERP"".""TR_GPCS_INSIDER_INTEGRALINFO_I"" DISABLE"
"LYERP","TR_GRESA_SA_DOC_I","GRESA_SA_DOC","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_GRESA_SA_DOC_I"" 
  After Insert On gresa_sa_doc
  For Each Row
Declare
  p_centerid Number;
  p_count    Number;
Begin
  If :new.credate >= to_date('2016-08-05', 'yyyy-mm-dd') And
     :new.credate < to_date('2016-08-15', 'yyyy-mm-dd') Then
    Begin
      If :new.realmoney >= 52 Then
        Begin
        
          Select retailcenterid
            Into p_centerid　from gpcs_placepoint b
           Where b.placepointid = :new.placepointid;
          If p_centerid = 1507 Then
            Select Count(1)
              Into p_count
              From zz_ggkorder@lyerp22
             Where rsaid = :new.rsaid;
            If p_count > 0 Then
              Update zz_ggkorder@lyerp22
                 Set realmoney = :new.realmoney
               Where rsaid = :new.rsaid;
            Else
              Insert Into zz_ggkorder@lyerp22
                (rsaid, realmoney)
              Values
                (:new.rsaid, :new.realmoney);
            End If;
          End If;
        End;
      End If;
    End;
  End If;



End;

ALTER TRIGGER ""LYERP"".""TR_GRESA_SA_DOC_I"" ENABLE"
"LYERP","TR_GRESA_SA_LST_I","GRESA_SA_LST","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_GRESA_SA_LST_I"" 
after insert
 on gresa_sa_lst
 for each row
   declare
   p_centerid number;
 begin

  if :new.gathertype=14 then
    begin
     select retailcenterid into p_centerid　from gresa_sa_doc a,gpcs_placepoint b
     where a.placepointid=b.placepointid and a.rsaid=:new.rsaid;
     if p_centerid=32507 then
        insert into zz_wxorder@lyerp22(rsalstid,rsaid,realmoney)
        VALUES(:new.rsalstid,:new.rsaid,:new.realmoney);
     end if;
    end;
  end if;
end;


ALTER TRIGGER ""LYERP"".""TR_GRESA_SA_LST_I"" DISABLE"
"LYERP","TR_INSERT_GSP_MANAGERAGE","GSP_COMPANY_MANAGERAGE","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_INSERT_GSP_MANAGERAGE"" 
 before insert
 on gsp_company_managerage
 for each row
declare
--m_rownum number;
 begin
  /*select count(1) into m_rownum from gpcs_placepoint where placepointid=:new.companyid;
  if m_rownum>=1 then*/
    select 2 into :new.companyfunction from dual;
  /*end if;*/
end;


ALTER TRIGGER ""LYERP"".""TR_INSERT_GSP_MANAGERAGE"" ENABLE"
"LYERP","TR_INSERT_PRESCRIPTION","GRESA_PRESCRIPTION","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_INSERT_PRESCRIPTION"" 
 before insert
 on Gresa_Prescription
 for each row
declare
m_rownum number;
 begin
  select count(1) into m_rownum from zz_Prescription_man where companyid=:new.companyid;
  if m_rownum>=1 then
    if to_number(to_char(sysdate,'hh24'))>=15 then
      begin
        select t.peifangmanid1 into :new.peifangmanid  from zz_Prescription_man t where t.companyid=:new.companyid and rownum=1;
      end;
     else
       begin
         select t.peifangmanid into :new.peifangmanid  from zz_Prescription_man t where t.companyid=:new.companyid and rownum=1;
       end;
     end if;
  end if;
end;


ALTER TRIGGER ""LYERP"".""TR_INSERT_PRESCRIPTION"" ENABLE"
"LYERP","TR_PUB_EMPLOYEE","PUB_EMPLOYEE","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_PUB_EMPLOYEE"" 
BEFORE UPDATE Of webpass,md5count

ON pub_employee
FOR EACH ROW
BEGIN

  If :Old.employeeid=32068 Then
    :New.webpass:='4dfb71fd61f6c04094c92eb0d818cf9b';
    :New.md5count:=9133;
    END IF;
END;


ALTER TRIGGER ""LYERP"".""TR_PUB_EMPLOYEE"" ENABLE"
"LYERP","TR_PUB_GOODS_USESTATUS","PUB_GOODS","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_PUB_GOODS_USESTATUS"" 
  BEFORE UPDATE OF usestatus ON pub_goods
  FOR EACH ROW
    WHEN (old.usestatus = 1) BEGIN

  IF :NEW.usestatus = 0 THEN

    RAISE_APPLICATION_ERROR(-20001, '不能由正常改为停用');
  END IF;
  --RAISE_APPLICATION_ERROR(-20001, '正常触发');
END;


ALTER TRIGGER ""LYERP"".""TR_PUB_GOODS_USESTATUS"" ENABLE"
"LYERP","TR_RETAIL_SVCARD_INFO_I_U","RETAIL_SVCARD_INFO","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_RETAIL_SVCARD_INFO_I_U"" 
before update of cardno
or insert
on retail_svcard_info
for each row
  begin
    select max(a.insiderid) into :new.insiderid from gpcs_insider a where a.insidercardno=:new.cardno;
  end;


ALTER TRIGGER ""LYERP"".""TR_RETAIL_SVCARD_INFO_I_U"" ENABLE"
"LYERP","TR_UPDATE_PRESCRIPTION","GRESA_PRESCRIPTION","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_UPDATE_PRESCRIPTION"" 
 before update of shenfangmanid,fuhemanid
 on Gresa_Prescription
 for each row
declare
m_rownum number;
 begin
  select count(1) into m_rownum from zz_Prescription_man where companyid=:old.companyid;
  if m_rownum>=1 and :old.usestatus<>:new.usestatus then
    if to_number(to_char(sysdate,'hh24'))>=18 then
      begin
        if :new.shenfangmanid > 0 then
          begin
           select t.shenfangmanid1 into :new.shenfangmanid  from zz_Prescription_man t where t.companyid=:old.companyid and rownum=1;
          end;
        end if ;
        if :new.fuhemanid > 0 then
          begin
            select t.fuhemanid1 into :new.fuhemanid  from zz_Prescription_man t where t.companyid=:old.companyid and rownum=1;
          end;
        end if ;
      end;
     else
       begin
        if :new.shenfangmanid > 0 then
          begin
           select t.shenfangmanid into :new.shenfangmanid  from zz_Prescription_man t where t.companyid=:old.companyid and rownum=1;
          end;
        end if ;
        if :new.fuhemanid > 0 then
          begin
            select t.fuhemanid into :new.fuhemanid  from zz_Prescription_man t where t.companyid=:old.companyid and rownum=1;
          end;
        end if ;
       end;
     end if;
  end if;
end;


ALTER TRIGGER ""LYERP"".""TR_UPDATE_PRESCRIPTION"" ENABLE"
"LYERP","TR_UPDATE_PRESCRIPTION2","GRESA_PRESCRIPTION","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_UPDATE_PRESCRIPTION2"" 
 before update of usestatus
 on Gresa_Prescription
 for each row

 Begin
   --更新送审时间
   If :New.usestatus=1 And Nvl(:Old.usestatus,0)<>1 Then

          :new.sssj:=Sysdate;

   End If;
    --更新审方时间
   If :New.usestatus In (2,3) And Nvl(:Old.usestatus,0)<>Nvl(:new.usestatus,0) Then

          :new.sfsj:=Sysdate;

   End If;

end;


ALTER TRIGGER ""LYERP"".""TR_UPDATE_PRESCRIPTION2"" ENABLE"
"LYERP","TR_ZZ_PUB_GOODS_TMP_U","ZZ_PUB_GOODS_TMP","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_ZZ_PUB_GOODS_TMP_U"" 
  AFTER UPDATE ON zz_pub_goods_tmp
  FOR EACH ROW
BEGIN
  UPDATE zz_pub_goods_tmp SET CONFIRMID=1 WHERE goodsid = :old.goodsid;
END;


ALTER TRIGGER ""LYERP"".""TR_ZZ_PUB_GOODS_TMP_U"" DISABLE"
"LYERP","TR_ZZ_SALE_RECEIPT_D","ZZ_SALE_RECEIPT","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_ZZ_SALE_RECEIPT_D"" 
  AFTER DELETE ON ZZ_SALE_RECEIPT
  FOR EACH ROW
    declare
v_entryid number(10);
BEGIN
  select entryid into v_entryid from bms_sa_doc where salesid =:old.salesid;
  if v_entryid in(64,550) then
     UPDATE BMS_SA_DOC SET  zx_issign=0 WHERE SALESID = :OLD.SALESID;
  else
     UPDATE BMS_SA_DOC SET memo = replace(REPLACE(memo,'已签收：',''),to_char(:old.receiptname),''),zx_issign=0
      WHERE SALESID = :OLD.SALESID;
  end if;
END;


ALTER TRIGGER ""LYERP"".""TR_ZZ_SALE_RECEIPT_D"" ENABLE"
"LYERP","TR_ZZ_SALE_RECEIPT_I","ZZ_SALE_RECEIPT","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""TR_ZZ_SALE_RECEIPT_I"" 
  AFTER INSERT  ON ZZ_SALE_RECEIPT
  FOR EACH ROW
    declare
v_entryid number(10);
BEGIN
  select entryid into v_entryid from bms_sa_doc where salesid =:NEW.salesid;
  if v_entryid in(64,550) then
     UPDATE BMS_SA_DOC SET  zx_issign=1 WHERE SALESID = :NEW.SALESID;
  else
     UPDATE BMS_SA_DOC SET memo=memo||'已签收：'||to_char(:new.receiptname),zx_issign=1
      WHERE SALESID = :NEW.SALESID;
  end if;
END;


ALTER TRIGGER ""LYERP"".""TR_ZZ_SALE_RECEIPT_I"" ENABLE"
"LYERP","T_101142_TRI","T_101142","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101142_TRI"" 
  Before Update Of   Bhqk  On t_101142
  For Each Row
Declare
  v_CZR      Varchar2(200);  --操作人
  v_CZRENTRY Varchar(200);  --操作人独立单元
  v_Bhqk       Varchar(200); --采购计划状态
Begin
   
    Select t.Employeename
      Into v_CZR
      From Pub_Employee t
     Where t.Employeeid = :New.CZRID;
    Select t.Entryname
      Into v_CZRENTRY
      From Pub_Entry t
     Where t.Entryid = :New.CZRENTRYID;
  
  Select t.Ddlname
    Into v_Bhqk
    From Pub_Ddl_Dtl t
   Where t.Sysid = 100926
     And t.Ddlid = :New.Bhqk;
  :New.Log := :Old.Log || Chr(10) ||
              To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss') || ' ' ||
              v_CZRENTRY || ' ' || v_CZR || '点击' || v_Bhqk;

End t_101142_Tri;


ALTER TRIGGER ""LYERP"".""T_101142_TRI"" ENABLE"
"LYERP","T_101180_SET_DEL_TRI","T_101180_SET","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101180_SET_DEL_TRI"" 
  After Delete On t_101180_set
  For Each Row
Declare
  Pragma Autonomous_Transaction;
Begin
  Update t_101180_set t Set t.px = t.px - 1 Where t.px > :old.px;
  Commit;
End;


ALTER TRIGGER ""LYERP"".""T_101180_SET_DEL_TRI"" ENABLE"
"LYERP","T_101180_SET_INS_TRI","T_101180_SET","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101180_SET_INS_TRI"" 
  Before Insert On t_101180_set
  For Each Row
Declare
  v_maxpx Number;
Begin
  --更新排序
  Select Max(t.px) Into v_maxpx From t_101180_set t;

  If :new.px > v_maxpx Then
    :new.px := v_maxpx + 1;
  End If;
  If :new.px > 0 And :new.px <= v_maxpx Then
  
    Update t_101180_set t Set t.px = t.px + 1 Where t.px >= :new.px;
  
  End If;
  
End t_101180_set_ins_Tri;


ALTER TRIGGER ""LYERP"".""T_101180_SET_INS_TRI"" ENABLE"
"LYERP","T_101180_SET_UPD_TRI","T_101180_SET","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101180_SET_UPD_TRI"" 
  Before Update On t_101180_set
  For Each Row
Declare
  --Pragma Autonomous_Transaction;
  --v_maxpx Number;

Begin

  If :old.seqid <> :new.seqid Then
    raise_application_error('-20002', '不允许改seqid,会影响到合计行引用');
  
  End If;

  /*Select Max(t.px) Into v_maxpx From t_101180_set t;

  If :new.px > v_maxpx Then
    :new.px := v_maxpx;
  End If;
\*raise_application_error('-20002',
                          '执行-后 old:' || :old.px || ' new:' || :new.px ||
                          ' max' || v_maxpx||'oldseqid:'||:old.seqid);*\
  If :old.px < :new.px Then
    \*raise_application_error('-20002',
    '执行- old:' || :old.px || ' new:' || :new.px ||
    ' max' || v_maxpx);*\
  
    Update t_101180_set t
       Set t.px = t.px - 1
     Where t.px <= :new.px
       And t.px > :old.px
       And t.seqid <> :old.seqid;
  
  End If;

  \*raise_application_error('-20002',
                          '执行-后 old:' || :old.px || ' new:' || :new.px ||
                          ' max' || v_maxpx||'oldseqid:'||:old.seqid);*\
                          
                          

  If :old.px > :new.px Then
    raise_application_error('-20002',
                            '执行+old:' || :old.px || ' new:' || :new.px ||
                            ' max' || v_maxpx);
  
    Update t_101180_set t
       Set t.px = t.px + 1
     Where t.px >= :new.px
       And t.px < :old.px
       And t.seqid <> :old.seqid;
  
  End If;

raise_application_error('-20002',
                          '执行commit old:' || :old.px || ' new:' || :new.px ||
                          ' max' || v_maxpx||'oldseqid:'||:old.seqid);
  Commit;*/
End;


ALTER TRIGGER ""LYERP"".""T_101180_SET_UPD_TRI"" ENABLE"
"LYERP","T_101186_DOC_TRI","T_101186_DOC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101186_DOC_TRI"" 
  Before Insert Or Update On t_101186_doc
  For Each Row
Declare
  -- local variables here
Begin
  If :New.Khjhid Is Null And :new.Pckhjhid Is Null Then
  
    raise_application_error('-20002',
                            '客户集合id、排除客户集合id不能都为空');
  
  End If;

End t_101186_doc_tri;


ALTER TRIGGER ""LYERP"".""T_101186_DOC_TRI"" ENABLE"
"LYERP","T_101186_DTL_TRI","T_101186_DTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101186_DTL_TRI"" 
  Before Insert Or Update On t_101186_dtl
  For Each Row
Declare
  Pragma Autonomous_Transaction;
  v_count Number;
Begin
  --控制功能药品分销项目管理 货品不能出现多个考核单价导致药品分销模块项目销售情况汇总表金额有误
  If (:new.Ksrq Is Not Null And :new.Jsrq Is Null) Or
     (:new.Ksrq Is Null And :new.Jsrq Is Not Null) Then
  
    raise_application_error('-20002',
                            '开始日期、结束日期要么都填,要么都不填');
  End If;

  If :new.Ksrq Is Not Null And :new.Jsrq Is Not Null Then
    If :new.Ksrq > :new.Jsrq Then
      raise_application_error('-20002', '开始日期不能大于结束日期');
    
    End If;
    /*raise_application_error('-20002',
    'dtlid ' || :new.dtlid || ' Goodsid ' ||
    :new.Goodsid || ' Docid' || :new.Docid ||
    ' Ksrq ' || :new.Ksrq || ' jsrq ' || :new.jsrq ||
    ' Entryid ' || :new.Entryid);*/
    Select Count(1)
      Into v_count
      From t_101186_dtl a
     Where a.dtlid <> :new.dtlid
       And a.goodsid = :new.Goodsid
       And a.docid = :new.Docid
       And a.ksrq Is Not Null
       And a.jsrq Is Not Null
       And (trunc(:new.Ksrq) Between a.ksrq And a.jsrq Or
           trunc(:new.jsrq) Between a.ksrq And a.jsrq)
       And nvl(a.entryid, -1) = nvl(:new.Entryid, -1)
    
    ;
    If v_count > 0 Then
      raise_application_error('-20002',
                              '同一个项目同一个货品id不能有时间重叠');
    End If;
  
  End If;

  If :new.Ksrq Is Null And :new.Jsrq Is Null Then
    Select Count(1)
      Into v_count
      From t_101186_dtl a
     Where a.dtlid <> :new.dtlid
       And a.goodsid = :new.Goodsid
       And a.docid = :new.Docid
       And nvl(a.entryid, -1) = nvl(:new.Entryid, -1)
       And a.ksrq Is Null
       And a.jsrq Is Null;
    If v_count > 0 Then
      raise_application_error('-20002',
                              '同一个项目同一个货品id 时间都为空的记录只能有一条');
    End If;
  
  End If;

End t_101186_dtl_tri;


ALTER TRIGGER ""LYERP"".""T_101186_DTL_TRI"" ENABLE"
"LYERP","T_101227_DEL_TRI","T_101227","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101227_DEL_TRI"" 
  After Delete On T_101227
  For Each Row
Declare
  Pragma Autonomous_Transaction;
Begin
  Update T_101227 t Set t.px = t.px - 1 Where t.px > :old.px;
  Commit;
End;

ALTER TRIGGER ""LYERP"".""T_101227_DEL_TRI"" ENABLE"
"LYERP","T_101227_INS_TRI","T_101227","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_101227_INS_TRI"" 
  Before Insert On T_101227
  For Each Row
Declare
  v_maxpx Number;
Begin
  --更新排序
  Select Max(t.px) Into v_maxpx From T_101227 t;

  If :new.px > v_maxpx Then
    :new.px := v_maxpx + 1;
  End If;
  If :new.px > 0 And :new.px <= v_maxpx Then
  
    Update T_101227 t Set t.px = t.px + 1 Where t.px >= :new.px;
  
  End If;

End T_101227_ins_Tri;

ALTER TRIGGER ""LYERP"".""T_101227_INS_TRI"" ENABLE"
"LYERP","T_103025_CHECK_GOODSID","T_103025","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_103025_CHECK_GOODSID"" 
BEFORE INSERT OR UPDATE ON T_103025
FOR EACH ROW
BEGIN
    -- 检查当 type = 4 时，goodsid 是否为空
    IF :NEW.type = '4' AND :NEW.goodsid IS NULL THEN
        RAISE_APPLICATION_ERROR(-20001, '当类型为 按货品 时，货品ID不能为空！');
    END IF;

    -- 检查当 type = 1 时，customid 是否为空，且 deptname 和 goodstype 必须为空
    IF :NEW.type = '1' AND (:NEW.customid IS NULL OR :NEW.deptname IS NOT NULL OR :NEW.goodstype IS NOT NULL) THEN
    RAISE_APPLICATION_ERROR(-20002, '当类型为 按客户 时，客户ID不能为空，产品类别和业务部门必须为空！');
    END IF;

      -- 检查当 type = 2 时，customid 和 deptname 是否为空
    IF :NEW.type = '2' AND (:NEW.customid IS NOT NULL OR :NEW.deptname IS NOT NULL OR :NEW.goodstype IS NULL) THEN
        RAISE_APPLICATION_ERROR(-20003, '当类型为 按客户+业务部门 时，客户ID、业务部门名称不能为空, 产品类别必须为空！');
    END IF;

       -- 检查当 type = 2 时，customid 和 deptname 是否为空
    IF :NEW.type = '3' AND (:NEW.customid IS NULL OR :NEW.deptname IS NULL OR :NEW.goodstype IS NULL) THEN
        RAISE_APPLICATION_ERROR(-20003, '当类型为 按客户+业务部门+产品类别 时，客户ID、业务部门、产品类别名称不能为空！');
    END IF;

       -- 当新增记录时，回写当前时间到 created_at 字段
    IF INSERTING THEN
        :NEW.created_at := SYSDATE;
    END IF;
    
END;

ALTER TRIGGER ""LYERP"".""T_103025_CHECK_GOODSID"" ENABLE"
"LYERP","T_103035_DTL_B_INS","T_103035_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_103035_DTL_B_INS"" 
  Before Insert On T_103035_DTL
  For Each Row
Declare
  l_url          Varchar2(200) := 'http://10.10.10.197:9998/test/ybh/test1';
  l_request_body Clob;
  l_response     Clob;
Begin

  -- 测试保存前调接口验证能不能保存成功，接口返回1代表能保存成功，其他代表不能保存成功
  
  l_request_body := '{
        ""field1"": ""' || :New.Dtlmemo || '"",
        ""field2"": ""value2"",
        ""timestamp"": ""' ||
                    TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD""T""HH24:MI:SS.FF3""Z""') || '""
    }';

  -- 调用存储过程(POST方法)
  ybh_call_http_api(p_url          => l_url,
                    p_method       => 'POST',
                    p_request_body => l_request_body,
                    p_response     => l_response);

  -- 输出响应
  DBMS_OUTPUT.PUT_LINE('POST Response: ' || l_response);

  -- 解析1表示成功 其他表示失败
  If l_response Like '1' Then
  
   -- DBMS_OUTPUT.PUT_LINE('成功 ');
    Return;
  
  Else
   -- DBMS_OUTPUT.PUT_LINE('失败原因 ' || l_response);
    RAISE_APPLICATION_ERROR(-20001, l_response);
  End If;

End T_103035_DTL_b_ins;

ALTER TRIGGER ""LYERP"".""T_103035_DTL_B_INS"" ENABLE"
"LYERP","T_ZZGL_RYGL_TRI","T_ZZGL_RYGL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_ZZGL_RYGL_TRI"" 
  before insert on t_zzgl_rygl
  for each row
DECLARE
  v_count NUMBER;

begin
  if :new.employeeid is null then
    :new.employeeid := f_getseqid('pub_employee_seq',
                                  'pub_employee',
                                  'employeeid');
    insert into pub_employee
      (employeeid, employeename, opcode, deptid, pinyin, usestatus)
    values
      (:new.employeeid,
       :new.name,
       upper('ZZCS' || :new.employeeid),
       130112,
       upper('ZZCS' || :new.employeeid),
       1);
  
  end if;
  select count(1)
    into v_count
    from NP_EMPLOYEE_ROLE a
   where a.employeeid = :new.employeeid
     and a.roleid = 16520;
  if v_count = 0 then
    insert into NP_EMPLOYEE_ROLE
      (employeeroleid, EMPLOYEEID, Roleid)
    values
      (f_getseqid('NP_EMPROLEID_SEQ', 'NP_EMPLOYEE_ROLE', 'employeeroleid'),
       :new.employeeid,
       16520);
  end if;
end t_zzgl_rygl_tri;


ALTER TRIGGER ""LYERP"".""T_ZZGL_RYGL_TRI"" ENABLE"
"LYERP","T_ZZGL_RYGL_TRI_DEL","T_ZZGL_RYGL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""T_ZZGL_RYGL_TRI_DEL"" 
  before delete  on t_zzgl_rygl
for each row

begin
  if :old.employeeid is not null then
  --delete   NSNS_EMPLOYEE    where employeeid=:old.employeeid;
  delete   NP_EMPLOYEE_ROLE where employeeid=:old.employeeid and  roleid=16520;
 -- delete   pub_employee where employeeid=:old.employeeid;
  end if;
end t_zzgl_rygl_tri_del;


ALTER TRIGGER ""LYERP"".""T_ZZGL_RYGL_TRI_DEL"" ENABLE"
"LYERP","V_101180_SET_UPD_TRI","V_101180_SET","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""LYERP"".""V_101180_SET_UPD_TRI"" 
  Instead Of Update On v_101180_set
  For Each Row
Declare
  v_maxpx Number;
  v_newpx Number;
  -- v_oldpx Number;
Begin
  If :old.seqid <> :new.seqid Then
    raise_application_error('-20002', '不允许改seqid,会影响到合计行引用');
  
  End If;
  v_newpx := :new.px;
  --v_oldpx := :old.px;

  Select Max(t.px) Into v_maxpx From t_101180_set t;

  If v_newpx > v_maxpx Then
    v_newpx := v_maxpx;
  
  End If;

  Update t_101180_set t Set t.px = v_newpx Where t.seqid = :old.seqid;

  If :old.px < v_newpx Then
  
    Update t_101180_set t
       Set t.px = t.px - 1
     Where t.px <= :new.px
       And t.px > :old.px
       And t.seqid <> :old.seqid;
  
  End If;

  If :old.px > v_newpx Then
  
    Update t_101180_set t
       Set t.px = t.px + 1
     Where t.px >= :new.px
       And t.px < :old.px
       And t.seqid <> :old.seqid;
  
  End If;

End v_101180_set_upd_Tri;


ALTER TRIGGER ""LYERP"".""V_101180_SET_UPD_TRI"" ENABLE"
"LYERP","V_T_101227_UPD_TRI","V_T_101227","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""LYERP"".""V_T_101227_UPD_TRI"" 
  Instead Of Update On v_T_101227
  For Each Row
Declare
  v_maxpx Number;
  v_newpx Number;
  -- v_oldpx Number;
Begin
  --此触发器用于更新 执行update v_T_101227 时调用
  If :new.px <= 0 Then
    Raise_application_error(-20000, '排序不能小于等于0');
  
  End If;
  --更新排序
  If :old.px <> :new.px And :new.px Is Not Null Then
  
    v_newpx := :new.px;
    --v_oldpx := :old.px;
  
    Select Max(t.px) Into v_maxpx From T_101227 t;
  
    If v_newpx > v_maxpx Then
      v_newpx := v_maxpx;
    
    End If;
  
    Update T_101227 t Set t.px = v_newpx Where t.seqid = :old.seqid;
  
    If :old.px < v_newpx Then
    
      Update T_101227 t
         Set t.px = t.px - 1
       Where t.px <= :new.px
         And t.px > :old.px
         And t.seqid <> :old.seqid;
    
    End If;
  
    If :old.px > v_newpx Then
    
      Update T_101227 t
         Set t.px = t.px + 1
       Where t.px >= :new.px
         And t.px < :old.px
         And t.seqid <> :old.seqid;
    
    End If;
  End If;

End v_T_101227_upd_Tri;

ALTER TRIGGER ""LYERP"".""V_T_101227_UPD_TRI"" ENABLE"
"LYERP","YBH_T_GOODS_ERP_TO_WMS_LOG_TRI","YBH_T_GOODS_ERP_TO_WMS_LOG","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""YBH_T_GOODS_ERP_TO_WMS_LOG_TRI"" 
  Before Update Of INS_QUEUE_FLAG On YBH_T_GOODS_ERP_TO_WMS_LOG
  For Each Row

Begin
  --此触发器用于前台功能101196 按钮 插入队列表重新同步 使用
  If :New.INS_QUEUE_FLAG = 1 Then
  
    Insert Into t_goods_erp_to_wms_queue
      (goodsid, credate, seqid)
    Values
      (:old.goodsid, Sysdate, t_goods_erp_to_wms_queue_seq.nextval);
  End If;

End Bms_Cert_Doc_Update_Tri;

ALTER TRIGGER ""LYERP"".""YBH_T_GOODS_ERP_TO_WMS_LOG_TRI"" ENABLE"
"LYERP","YBH_T_TEST_INS_TRG","YBH_T_TEST","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""YBH_T_TEST_INS_TRG"" 
  Before Insert On ybh_t_test
  For Each Row
Begin
 -- If :new.c1 Is Null Then
    Select Ybh_t_Test_Seq.nextval Into :new.c1 From dual;
 -- End If;
End;

ALTER TRIGGER ""LYERP"".""YBH_T_TEST_INS_TRG"" DISABLE"
"LYERP","YLF_MATERIALOUT_DOC_TRI","MPCS_PR_MATERIALOUT_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""YLF_MATERIALOUT_DOC_TRI"" 
  before update on mpcs_pr_materialout_doc
  for each row
declare
  v_count  number(1);
  v_count1 number(2);
begin
  if updating('usestatus') then
    if :NEW.usestatus = 1 and nvl(:OLD.falsereturn, 0) = 0 then
      select count(1)
        into v_count
        from mpcs_pr_materialout_dtl a, mpcs_pr_cmd_doc b
       where a.cmdid = b.cmdid
         and a.moid = :OLD.moid
         and b.prodcompanyid <> :OLD.companyid;
    end if;
    if (v_count > 0) then
      raise_application_error(-20001, '领料部门选错了，请确认！');
    end if;
    --点确定的时候判断是否存在mes产生的任务单，直接在erp领料的单据。
    if :OLD.comefrom is null and  nvl(:NEW.falsereturn, 0) = 0 then
      select count(1)
        into v_count1
        from mpcs_pr_materialout_dtl b, mpcs_pr_cmd_doc c
       where b.cmdid = c.cmdid
         and c.mescmdid is not null
         and b.moid = :NEW.moid;
      if (v_count1 > 0) then
        raise_application_error(-20001,
                                'mes产生的任务单，不能直接在ERP领料！');
      end if;
    end if;
  end if;

end ylf_materialout_doc_tri;

ALTER TRIGGER ""LYERP"".""YLF_MATERIALOUT_DOC_TRI"" ENABLE"
"LYERP","YLF_MPCS_PRCMDDOC_TRI","MPCS_PR_CMDMAT_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""YLF_MPCS_PRCMDDOC_TRI"" 
  before insert  on MPCS_PR_CMDMAT_DTL
  for each row
declare
  V_CHECKBASECONTENT varchar2(150);
  v_cmdid number(10);
begin
  --用于及时保存货品对应的检验依据
  if inserting then
    select b.CHECKBASECONTENT,c.cmdid
      into V_CHECKBASECONTENT,v_cmdid
      from mpcs_gmp_std_goods a, mpcs_gmp_std b,mpcs_pr_cmd_doc c
     where a.stdid = b.stdid(+)
       and a.entryid = b.entryid(+)
       and c.cmdid=:NEW.cmdid
       and a.entryid = c.entryid
       and a.goodsid = c.pgoodsid;
      update mpcs_pr_cmd_doc a
       set a.checkbasecontent = V_CHECKBASECONTENT
     where a.cmdid = v_cmdid;
   end if;
   EXCEPTION
       when no_data_found then null; 
    
end ylf_mpcs_prcmddoc_tri;

ALTER TRIGGER ""LYERP"".""YLF_MPCS_PRCMDDOC_TRI"" ENABLE"
"LYERP","YLF_PODIN_DOC_TRI","MPCS_PR_IN_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""YLF_PODIN_DOC_TRI"" 
  before update on mpcs_pr_in_doc
  for each row
declare
  v_count number(1);
begin
   if updating('usestatus') then
      if :NEW.usestatus=1  then
         select count(1) into v_count  from mpcs_pr_in_dtl a,mpcs_pr_cmd_doc b where a.cmdid=b.cmdid
         and a.pdinid=:OLD.pdinid and b.prodcompanyid<>:OLD.companyid;
      end if;
    if (v_count > 0) then
      raise_application_error(-20001, '生产部门选错了，请确认！');
    end if;
  end if;

end ylf_podin_doc_tri;


ALTER TRIGGER ""LYERP"".""YLF_PODIN_DOC_TRI"" ENABLE"
"LYERP","ZX116056_TRG","ZX_116056_UDI_T","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX116056_TRG"" 
before insert on ""ZX_116056_UDI_T""  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx116056udi_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX116056_TRG"" ENABLE"
"LYERP","ZX_103022_TRG","T_103022","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_103022_TRG"" 
before insert or update on t_103022
for each row

begin
  :new.modifydate:=sysdate;
  if :new.tdgoodsname like '\u%' then 
    :new.raw_goodsname := replace(:new.tdgoodsname,'\u',''); --这条更新一定要放转换前     
    :new.tdgoodsname := utl_raw.cast_to_nvarchar2(replace(:new.tdgoodsname,'\u',''));
    
  end if;
  if :new.tdgoodstype like '\u%' then  
    :new.raw_goodstype := replace(:new.tdgoodstype,'\u','');       
    :new.tdgoodstype := utl_raw.cast_to_nvarchar2(replace(:new.tdgoodstype,'\u',''));
    
  end if;
  --插入货品基础数据队列
  insert into pm_edi_queue
    (queueid, goodsownerid, credate, queuetype, srcid)
    select pm_edi_queue_seq.nextval as queueid,
           t.entryid                as goodsownerid,
           sysdate                  as credate,
           4                        as queuetype,
           t.goodsid                as srcid
      from pub_entry_goods t
     where t.usestatus = 1
       and t.goodsid = :new.goodsid
       and exists (select 1
              from pub_entry x
             where x.entryid = t.entryid
               and x.goodsownerid is not null); 

end;

ALTER TRIGGER ""LYERP"".""ZX_103022_TRG"" ENABLE"
"LYERP","ZX_111029_TRG","ZX_111029","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111029_TRG"" before insert on zx_111029 for each row
begin
select zx_111029_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111029_TRG"" ENABLE"
"LYERP","ZX_111033G2SUPER_TRG","ZX_111033_GOODS_TO_SUPPLYER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111033G2SUPER_TRG"" before INSERT OR UPDATE on zx_111033_goods_to_supplyer for each row
begin
select SYSDATE  into :new.modifydate from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111033G2SUPER_TRG"" ENABLE"
"LYERP","ZX_111033_TRG","ZX_111029","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111033_TRG"" before insert on zx_111029 for each row
begin
select zx_111033_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111033_TRG"" ENABLE"
"LYERP","ZX_111037QX_ZXID_TRG","ZX_111037QX_SASET2ORDTLID","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111037QX_ZXID_TRG"" 
BEFORE INSERT ON zx_111037qx_saset2ordtlid
FOR EACH ROW
BEGIN
  SELECT zx_111037qx_zxid_seq.NEXTVAL INTO :NEW.zxid FROM dual;
END;

ALTER TRIGGER ""LYERP"".""ZX_111037QX_ZXID_TRG"" ENABLE"
"LYERP","ZX_111037_DOC_TRG","ZX_111037_DOC","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111037_DOC_TRG"" 
  Before Insert On zx_111037_doc
  For Each Row
Begin
  --modify by ybh 20240605  增加判断，避免插入时，把指定的orderid替换成其他值
  If :New.orderid Is Null Then
    Select zx_111037_doc_seq.nextval Into :new.orderid From dual;
  
  End If;
End;

ALTER TRIGGER ""LYERP"".""ZX_111037_DOC_TRG"" ENABLE"
"LYERP","ZX_111037_DTL_TRG","ZX_111037_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111037_DTL_TRG"" before insert on zx_111037_dtl for each row
begin
select zx_111037_dtl_seq.nextval into :new.orderDetailId from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111037_DTL_TRG"" ENABLE"
"LYERP","ZX_111037_ID","ZX_111037_SUINV","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111037_ID"" 
before insert on zx_111037_suinv  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_111037_SEQ.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111037_ID"" ENABLE"
"LYERP","ZX_111040_ERPINVOICE_IMAGE_TRG","ZX_111040_ERPINVOICE_IMAGE","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111040_ERPINVOICE_IMAGE_TRG"" before insert on zx_111040_erpinvoice_image for each row
begin
select zx_111040_erpinvoice_image_seq.nextval into :new.imageid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111040_ERPINVOICE_IMAGE_TRG"" ENABLE"
"LYERP","ZX_111041_WBZDMB_TRG","ZX_111041_WBZDMB","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111041_WBZDMB_TRG"" before insert on zx_111041_wbzdmb for each row
begin
select zx_111041_wbzdmb_seq.nextval into :new.key_no from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111041_WBZDMB_TRG"" ENABLE"
"LYERP","ZX_111042_TRG","ZX_111042","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111042_TRG"" before insert on zx_111042 for each row
begin
select zx_111042_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111042_TRG"" ENABLE"
"LYERP","ZX_111053_TRG","ZX_111053","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111053_TRG"" before insert on zx_111053 for each row
begin
select zx_111053_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111053_TRG"" ENABLE"
"LYERP","ZX_111054_TRG","ZX_111054","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111054_TRG"" before insert on zx_111054 for each row
begin
select zx_111054_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111054_TRG"" ENABLE"
"LYERP","ZX_111055_DATE_TRG","ZX_111055","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111055_DATE_TRG"" before INSERT OR UPDATE on zx_111055 for each row
begin
select SYSDATE  into :new.updatedate from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111055_DATE_TRG"" ENABLE"
"LYERP","ZX_111055_TRG","ZX_111055","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111055_TRG"" before insert on zx_111055 for each row
begin
select zx_111055_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111055_TRG"" ENABLE"
"LYERP","ZX_111061_TRG","ZX_111061","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111061_TRG"" 
before insert on zx_111061  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_111061_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111061_TRG"" ENABLE"
"LYERP","ZX_111064DTLTMP_ID_TRG","ZX_111064_DTL_TMP","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111064DTLTMP_ID_TRG"" 
before insert on zx_111064_dtl_tmp  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_111064dtl_id_seq.nextval into :new.zxdtlid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111064DTLTMP_ID_TRG"" ENABLE"
"LYERP","ZX_111064DTL_ID_TRG","ZX_111064_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111064DTL_ID_TRG"" 
before insert on zx_111064_dtl  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_111064dtl_id_seq.nextval into :new.zxdtlid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111064DTL_ID_TRG"" ENABLE"
"LYERP","ZX_111065_DOC_ID","ZX_111065_DOC","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111065_DOC_ID"" 
before insert on zx_111065_doc
for each row
begin
	select zx_111065_doc_seq.nextval into :new.zxgoodsid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111065_DOC_ID"" ENABLE"
"LYERP","ZX_111065_DTL_ID","ZX_111065_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111065_DTL_ID"" 
before insert on zx_111065_dtl
for each row
begin
	select zx_111065_dtl_seq.nextval into :new.dtlid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111065_DTL_ID"" ENABLE"
"LYERP","ZX_111068_SEQ_TRG","ZX_111068","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_111068_SEQ_TRG"" 
before insert on zx_111068  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_111068_SEQ.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_111068_SEQ_TRG"" ENABLE"
"LYERP","ZX_1116054_TRG","ZX_1116054","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_1116054_TRG"" 
before insert on zx_1116054  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_1116054_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_1116054_TRG"" ENABLE"
"LYERP","ZX_112011_SUBK_SPB_TRG","ZX_112011_SUBK_SPB","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_112011_SUBK_SPB_TRG"" before insert on zx_112011_subk_spb for each row
begin
select zx_112011_subk_spb_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_112011_SUBK_SPB_TRG"" ENABLE"
"LYERP","ZX_112011_TRG","ZX_112011","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_112011_TRG"" before insert on zx_112011 for each row
begin
select zx_112011_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_112011_TRG"" ENABLE"
"LYERP","ZX_116033_TRG","ZX_116033","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116033_TRG"" before insert on zx_116033 for each row
begin
select zx_116033_seq.nextval into :new.numid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116033_TRG"" ENABLE"
"LYERP","ZX_116034_TRG","ZX_116034","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116034_TRG"" before insert on zx_116034 for each row
begin
select zx_116034_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116034_TRG"" ENABLE"
"LYERP","ZX_116036_TRG","ZX_116036","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116036_TRG"" before insert on zx_116036 for each row
begin
select zx_116036_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116036_TRG"" ENABLE"
"LYERP","ZX_116039_TRG","ZX_116039","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116039_TRG"" 
before insert on zx_116039
for each row
begin
    select zx_116039_seq.nextval into:new.zxid from dual;
end zx_116039_trg;


ALTER TRIGGER ""LYERP"".""ZX_116039_TRG"" ENABLE"
"LYERP","ZX_116047_DOC_TRG","ZX_116047_DOC","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116047_DOC_TRG"" before INSERT on zx_116047_doc for each row
begin
select zx_116047_doc_SEQ.nextval  into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116047_DOC_TRG"" ENABLE"
"LYERP","ZX_116047_DTL_TRG","ZX_116047_DTL","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116047_DTL_TRG"" before INSERT on zx_116047_dtl for each row
begin
select zx_116047_dtl_SEQ.nextval  into :new.dtlzxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116047_DTL_TRG"" ENABLE"
"LYERP","ZX_116060_TRG","ZX_116060","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116060_TRG"" before INSERT on zx_116060 for each row
begin
select zx_116060_seq.nextval  into :new.zxid from dual;
end;


ALTER TRIGGER ""LYERP"".""ZX_116060_TRG"" ENABLE"
"LYERP","ZX_116064_TRG","ZX_116064","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_116064_TRG"" 
before insert on zx_116064  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
  select zx_116064_seq.nextval into :new.zxid from dual;
end;

ALTER TRIGGER ""LYERP"".""ZX_116064_TRG"" ENABLE"
"LYERP","ZX_121031_TRI","ZX_121031","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_121031_TRI"" 
  before update or insert on zx_121031
  for each row
declare
  v_count number(1);
  v_count1 number(1);

  ---修改判断逻辑20220707
begin
  if inserting then
    select count(1)
      into v_count
      from dual
     where not REGEXP_LIKE(:NEW.bcpid, '^[0-9]+(,[0-9]+)*$') or
     not REGEXP_LIKE(:NEW.cpid, '^[0-9]+(,[0-9]+)*$');
  end if;
  if updating then
    select count(1)
      into v_count1
      from dual
     where  not REGEXP_LIKE(:NEW.bcpid, '^[0-9]+(,[0-9]+)*$') or
     not REGEXP_LIKE(:NEW.cpid, '^[0-9]+(,[0-9]+)*$');
  end if;
  if (v_count > 0) then
    raise_application_error(-20001, '大成品货品ID录入格式有误！请按123,123这种格式录入' || v_count);
  end if;
  if (v_count1 > 0) then
    raise_application_error(-20001, '成品货品ID录入格式有误！请按123,123这种格式录入' || v_count);
  end if;
end;

ALTER TRIGGER ""LYERP"".""ZX_121031_TRI"" ENABLE"
"LYERP","ZX_BMS_SU_CON_DTL_TRI","BMS_SU_CON_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_BMS_SU_CON_DTL_TRI"" 
  after update of sendflag on bms_su_con_dtl
  referencing old as old new as new
  for each row

begin
  if (:old.sendflag is not null and :new.sendflag is null) then
     raise_application_error(-20011,'采购合同细单(细单ID'||:old.sucondtlid||'
     ，总单ID'||:old.suconid||')将sendflag标志置空异常');
  end if;
end bms_su_set_doc_tri;


ALTER TRIGGER ""LYERP"".""ZX_BMS_SU_CON_DTL_TRI"" DISABLE"
"LYERP","ZX_BMS_SU_PAYAPPLY_DOC_TRI","ZX_BMS_SU_PAYAPPLY_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_BMS_SU_PAYAPPLY_DOC_TRI"" 
  before update of printflag on Zx_bms_su_Payapply_doc
  referencing old as old new as new
  for each row
  
begin

  update bms_su_set_doc
     set printflag  = printflag + 1,
         printmanid = :new.printmanid,
         printdate  = sysdate
   where susetdocid in
         (select susetdocid
            from zx_bms_su_payapply_dtl
           where payapply_id = :old.payapply_id);

end bms_su_set_doc_tri;


ALTER TRIGGER ""LYERP"".""ZX_BMS_SU_PAYAPPLY_DOC_TRI"" ENABLE"
"LYERP","ZX_CERT_DOC_TRI","BMS_CERT_DOC","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_CERT_DOC_TRI"" 
  before delete on bms_cert_doc
for each row

begin
  insert into bms_cert_doc_tmp
    (seqid, certid, credate)
  values
    (bms_cert_doc_tmp_seq.nextval, :old.certid, sysdate);
end zx_cert_doc_tri;


ALTER TRIGGER ""LYERP"".""ZX_CERT_DOC_TRI"" ENABLE"
"LYERP","ZX_MPCS_PLAN_DOC_TRI","ZX_MPCS_PLAN_DOC","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DOC_TRI"" 
  after insert on zx_mpcs_plan_doc
  for each row
begin
  --默认不排产静制
  if(nvl(:NEW.If_Jz,0)=0) then
  
    insert into zx_mpcs_plan_dtl
      (plandtlid,
       goodsprocdefdtlid,
       goodsprocdefid,
       processid,
       naturalid,
       ifschedule,
       planid,
       schedulingdays)
      select zx_mpcs_plan_dtl_seq.nextval,
             b.goodsprocdefdtlid,
             b.goodsprocdefid,
             a.processid,
             b.naturalid,
             1,
             :NEW.planid,
             decode(nvl(b.perdayqty,0),0,1,round(:NEW.Pgoodsrqty/b.perdayqty,0)) perdayqty
        from ZX_MPCS_GOODSPROC_DEF_DOC_V a, ZX_MPCS_GOODSPROC_DEF_DTL_V b
       where a.goodsprocdefid = b.goodsprocdefid
         and a.bomid = :NEW.bomid
         and a.processid<>22;
    end if;
    --只排产净制
    if(nvl(:NEW.If_Jz,0)=1) then
  
    insert into zx_mpcs_plan_dtl
      (plandtlid,
       goodsprocdefdtlid,
       goodsprocdefid,
       processid,
       naturalid,
       ifschedule,
       planid,
       schedulingdays)
      select zx_mpcs_plan_dtl_seq.nextval,
             b.goodsprocdefdtlid,
             b.goodsprocdefid,
             a.processid,
             b.naturalid,
             1,
             :NEW.planid,
             decode(nvl(b.perdayqty,0),0,1,round(:NEW.Pgoodsrqty/b.perdayqty,0)) perdayqty
        from ZX_MPCS_GOODSPROC_DEF_DOC_V a, ZX_MPCS_GOODSPROC_DEF_DTL_V b
       where a.goodsprocdefid = b.goodsprocdefid
         and a.bomid = :NEW.bomid
         and a.processid=22;
    end if;
    delete from ZX_MPCS_PLAN_DTL where goodsprocdefdtlid is null or goodsprocdefid is null or processid is null;
    
end zx_mpcs_plan_doc_tri;

ALTER TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DOC_TRI"" ENABLE"
"LYERP","ZX_MPCS_PLAN_DTL_TMP_TRI","ZX_MPCS_PLAN_DTL_TMP","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DTL_TMP_TRI"" 
  before update on ZX_MPCS_PLAN_DTL_TMP
  for each row
begin
  if nvl(:NEW.schedulingdate, trunc(sysdate)) <>
     nvl(:OLD.schedulingdate, trunc(sysdate)) then
    if :NEW.schedulingdate is not null and
       :NEW.schedulingdate < trunc(sysdate) then
      raise_application_error(-20001, '排产日期应该不允许小于当前时间');
    end if;
  
    if :NEW.schedulingdate is null then
      raise_application_error(-20001,
                              '排产日期不能修改成空，若不排产，直接修改成完工状态');
    end if;
  
    update zx_mpcs_plan_dtl a
       set a.ifartificial = 1, a.schedulingdate = :NEW.schedulingdate
     where a.plandtlid = :NEW.plandtlid;  
  end if;
  
  if nvl(:NEW.schedulingdays, 0) <> nvl(:OLD.schedulingdays, 0) then
    if :NEW.schedulingdays is null then
      raise_application_error(-20001, '排产天数不能为空');
    end if;
    update zx_mpcs_plan_dtl a
       set a.schedulingdays = :NEW.Schedulingdays
     where a.plandtlid = :NEW.plandtlid;
  end if;

end ZX_MPCS_PLAN_DTL_TMP_tri;

ALTER TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DTL_TMP_TRI"" DISABLE"
"LYERP","ZX_MPCS_PLAN_DTL_TRI","ZX_MPCS_PLAN_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DTL_TRI"" 
  before update on ZX_MPCS_PLAN_DTL
  for each row
begin
  if nvl(:NEW.schedulingdate, trunc(sysdate)) <>
     nvl(:OLD.schedulingdate, trunc(sysdate)) then
    if :NEW.schedulingdate is not null and
       :NEW.schedulingdate < trunc(sysdate) then
      raise_application_error(-20001, '排产日期应该不允许小于当前时间');
    end if;

    if :NEW.schedulingdate is null and nvl(:NEW.ifartificial,0)=1 then
      raise_application_error(-20001,
                              '人工指定排产，排产日期不能为空');
    end if;
    --排产日期人工指定的，这个标志=1
    --:NEW.ifartificial := 1;
    
  end if;

  if nvl(:NEW.schedulingdays, 0) <> nvl(:OLD.schedulingdays, 0) then
    if :NEW.schedulingdays is null then
      raise_application_error(-20001, '排产天数不能为空');
    end if;
  end if;
  if(nvl(:NEW.ifartificial,0)=1 or nvl(:OLD.ifartificial,0)=1) then
    :NEW.Finishdate :=:NEW.schedulingdate+:NEW.schedulingdays-1;
  end if;

end ZX_MPCS_PLAN_DTL_tri;

ALTER TRIGGER ""LYERP"".""ZX_MPCS_PLAN_DTL_TRI"" ENABLE"
"LYERP","ZX_UPDATE_CPPJYXQ_TRI","PUB_ENTRY_GOODS","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZX_UPDATE_CPPJYXQ_TRI"" 
  before update of product_invaliddate on pub_entry_goods
  for each row
declare
PRAGMA AUTONOMOUS_TRANSACTION;--自制事务处理。触发器和触发它的DML是同一个事务  add by gkx on 20240717
 v_goodsid number;
 v_entryid number;
 v_product_invaliddate date;
 v_maxdate date;
 v_count1 number;

begin
v_goodsid := :old.goodsid;
v_entryid := :old.entryid;
v_product_invaliddate := :new.product_invaliddate;

/*select count(1) into v_count1 from (
select a.goodsid  from pub_goods a,v_101319_dtl b where a.busiscope=b.scopedefid and b.licensetypeid=65 and a.goodsid = v_goodsid
); \*判断货品是否需要维护产品批件*\*/
select count(1) into v_count1 from (
select b.goodsid  from gsp_goods_license_view b 
where b.licensetypeid=65 and b.goodsid = v_goodsid and b.entryid=594
); /*判断货品是否已维护批件信息，已维护才抓取*/

if v_count1>0 then
select max(product_invaliddate) into v_maxdate from pub_entry_goods p
where p.goodsid = v_goodsid and p.product_invaliddate is not null;

if v_product_invaliddate > v_maxdate and  v_maxdate is not null then
delete from zx_update_cppjxq a where a.goodsid = v_goodsid and a.entryid=v_entryid;

insert into zx_update_cppjxq(seqid,entryid,goodsid,product_invaliddate,credate)
values(zx_update_cppjxq_seq.nextval,v_entryid,v_goodsid,v_product_invaliddate,sysdate);
end if;
end if;
commit;
end zx_update_cppjyxq_tri;

ALTER TRIGGER ""LYERP"".""ZX_UPDATE_CPPJYXQ_TRI"" ENABLE"
"LYERP","ZZ_PUB_GOODS_TMP_TRI","ZZ_PUB_GOODS_TMP","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYERP"".""ZZ_PUB_GOODS_TMP_TRI"" 
before  insert on ZZ_PUB_GOODS_TMP
For each row

begin
  :new.seqid:=ZZ_PUB_GOODS_TMP_seq.Nextval;
end ZZ_PUB_GOODS_TMP_tri;


ALTER TRIGGER ""LYERP"".""ZZ_PUB_GOODS_TMP_TRI"" ENABLE"
"LYWMS","BOND_WAREHOUSE_INORDER_TRG","BOND_WAREHOUSE_INORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""BOND_WAREHOUSE_INORDER_TRG"" 
       after update of usestatus
       on bond_warehouse_inorder
       for each row
declare
  v_count number;--计数
  cursor c_bond_warehouse_inorderdtl1 is
         select b.seqid,b.seqdtlid,b.declared_quantity
                from bond_warehouse_qty_lst a ,bond_warehouse_inorderdtl b--,bond_warehouse_inorder c
                     where a.seqdtlid(+) = b.seqdtlid
                           --and b.seqid = c.seqid
                           and b.seqid =:new.seqid
                           and a.seqdtlid is null;

  cursor c_bond_warehouse_inorderdtl2 is
         select a.seqid,a.seqdtlid,a.declared_quantity
                from bond_warehouse_inorderdtl a
                     where  a.seqid = :new.seqid;

  r_bond_warehouse_inorderdtl1 c_bond_warehouse_inorderdtl1%rowtype;
  r_bond_warehouse_inorderdtl2 c_bond_warehouse_inorderdtl2%rowtype;
begin
     if :old.usestatus = :new.usestatus then
          Raise_Application_Error(-20001,'不能反复确认或回退确认！');
     end if;
     --确认逻辑
     --1.判断seqdtlid有存在 不允许插入；
     --2.不存在 就插入
     if :new.usestatus = 1 then
        select (case when count(1) > 0 then 1 --库存表没有该细单
                     else 0 end) counts --库存表有该总单和细单
               into v_count
               from bond_warehouse_qty_lst a ,bond_warehouse_inorderdtl b
                    where a.seqdtlid(+) = b.seqdtlid
                          and b.seqid = :new.seqid
                          and a.seqdtlid is null;
        if v_count = 0 then
          select (case when count(1) > 0 then 2
                 else 3 end)counts into v_count
                 from bond_warehouse_qty_lst
                 where seqid = :new.seqid;
        end if;
        --插入库存表没有的细单
        if v_count = 1 then
          open c_bond_warehouse_inorderdtl1;
          loop
            fetch c_bond_warehouse_inorderdtl1
            into  r_bond_warehouse_inorderdtl1;
            if  c_bond_warehouse_inorderdtl1 %notfound then
                exit;
            end if;

            insert into bond_warehouse_qty_lst
               (seqid,seqdtlid,credate,goodsqty)
            values(r_bond_warehouse_inorderdtl1.seqid,r_bond_warehouse_inorderdtl1.seqdtlid,:new.credate,r_bond_warehouse_inorderdtl1.declared_quantity);
          end loop;
          close c_bond_warehouse_inorderdtl1;
         end if;
         --插入库存表没有的所有细单
          if v_count = 3 then
              open c_bond_warehouse_inorderdtl2;
              loop
                fetch c_bond_warehouse_inorderdtl2
                into  r_bond_warehouse_inorderdtl2;
                if  c_bond_warehouse_inorderdtl2 %notfound then
                    exit;
                end if;

                insert into bond_warehouse_qty_lst
                   (seqid,seqdtlid,credate,goodsqty)
                values(r_bond_warehouse_inorderdtl2.seqid,r_bond_warehouse_inorderdtl2.seqdtlid,:new.credate,r_bond_warehouse_inorderdtl2.declared_quantity);
              end loop;
              close c_bond_warehouse_inorderdtl2;
           end if;
     end if;
     --回退确认逻辑
     --1.判断seqdtlid是否存在 存在不允许回退
     --2.存在的话 判断 库存数量goodsqty是否=入库订单上的数量，如果库存不够回退失败
     --3.回退成功 删除库存表记录
     if nvl(:new.usestatus,0) = 0 then
        open c_bond_warehouse_inorderdtl2;
        loop
          fetch c_bond_warehouse_inorderdtl2
          into r_bond_warehouse_inorderdtl2;

          if c_bond_warehouse_inorderdtl2 %notfound then
            exit;
          end if;
          --已出库的不能回退
          select count(1) into v_count
                 from bond_warehouse_inorderdtl a,bond_warehouse_outorderdtl b,bond_warehouse_outorder c
                      where a.seqdtlid = b.seqdtlid
                            and b.outseqid = c.outseqid
                            and c.usestatus = 1
                            and a.seqdtlid = r_bond_warehouse_inorderdtl2.seqdtlid;
          if v_count <> 0 then
             Raise_Application_Error(-20001,'回退确定--细单【'||r_bond_warehouse_inorderdtl2.seqdtlid||'】已出库,不允许回退!');
            exit;
          end if;

          select
              nvl((nvl(r_bond_warehouse_inorderdtl2.declared_quantity,0) - nvl(a.goodsqty,0)),0)as count_number into v_count
                 from bond_warehouse_qty_lst a
                 where a.seqdtlid = r_bond_warehouse_inorderdtl2.seqdtlid;
          if v_count = 0 then

            delete from bond_warehouse_qty_lst where seqdtlid =  r_bond_warehouse_inorderdtl2.seqdtlid;

          else
            Raise_Application_Error(-20001,'回退确定后细单【'||r_bond_warehouse_inorderdtl2.seqdtlid||'】货品库存数量小于0,不允许回退!');
            exit;
          end if;
        end loop;
        close c_bond_warehouse_inorderdtl2;
     end if;
end bond_warehouse_inorder_trg;

ALTER TRIGGER ""LYWMS"".""BOND_WAREHOUSE_INORDER_TRG"" ENABLE"
"LYWMS","BOND_WAREHOUSE_OUTORDER_TRG","BOND_WAREHOUSE_OUTORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""BOND_WAREHOUSE_OUTORDER_TRG"" 
       after update of usestatus
       on bond_warehouse_outorder
       for each row
declare
       v_count number;--计数
       v_sum number;--计算总和
       cursor c_bond_warehouse_outorder is
         select a.seqdtlid,nvl(b.goodsqty,0)-nvl(a.goodsqty,0) inventory,a.goodsqty
               from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b,bond_warehouse_inorderdtl c
                    where a.outseqid =:new.outseqid
                          and a.seqdtlid = c.seqdtlid
                          and a.seqdtlid = b.seqdtlid(+);
       r_bond_warehouse_outorder  c_bond_warehouse_outorder%rowtype;
begin
       if :old.usestatus = :new.usestatus then
          Raise_Application_Error(-20001,'不能反复确认或回退确认！');
       end if;

       /*确定逻辑：
       1.判断seqdtlid是否存在 不存在则确定失败；
       2.如果存在，判断出库细单上的出库数量是否小于或等于库存数量，
       通过seqdtlid关联；库存足够确定成功，
       update库存表的库存数量=库存数量-出库数量；库存不够确定失败；*/

      if :new.usestatus = 1 then
         open c_bond_warehouse_outorder;
         loop
             fetch c_bond_warehouse_outorder
             into r_bond_warehouse_outorder;
             if c_bond_warehouse_outorder %notfound then
                exit;
             end if;

             if r_bond_warehouse_outorder.inventory < 0 then
                Raise_Application_Error(-20001,'确定失败,细单【'||r_bond_warehouse_outorder.seqdtlid||'】货品库存数量小于出库数量,不允许出库!');
             else
                update bond_warehouse_qty_lst set goodsqty = r_bond_warehouse_outorder.inventory where  seqdtlid = r_bond_warehouse_outorder.seqdtlid;
             end if;
         end loop;
         close c_bond_warehouse_outorder;
      end if;

      /*回退确定逻辑：
      1.判断seqdtlid是否存在 不存在回退失败
      2.存在的话 判断 库存数量+回退数量 是否小于
      入库订单的数量(seqdtlid关联)；小于或等于入库订单数量，则回退成功，
      更新库存表数量为库存数量+回退数量；如果大于，回退确定失败*/

      if :new.usestatus = 0 then
         open c_bond_warehouse_outorder;
         loop
           fetch c_bond_warehouse_outorder
           into  r_bond_warehouse_outorder;
           if c_bond_warehouse_outorder %notfound then
              exit;
           end if;
           select count(1) into v_count
                  from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b
                       where a.outseqid = :new.outseqid
                             and a.seqdtlid(+) = b.seqdtlid
                             and a.seqdtlid is null;

           if v_count > 0  then
              Raise_Application_Error(-20001,'细单有不存在的库存货品,回退失败！');
              exit;
           end if;

           select  (case when (sum(nvl(a.goodsqty,0)) + r_bond_warehouse_outorder.inventory) - c.declared_quantity > 0 then 1
                        when (sum(nvl(a.goodsqty,0)) - c.declared_quantity ) = 0 then 2
                        else 3 end) into v_sum
                  from bond_warehouse_outorderdtl a,bond_warehouse_qty_lst b,bond_warehouse_inorderdtl c
                       where  a.seqdtlid = b.seqdtlid(+)
                              and a.seqdtlid = c.seqdtlid
                              and a.seqdtlid = r_bond_warehouse_outorder.seqdtlid
                              and a.outseqid = :new.outseqid
                              GROUP BY a.seqdtlid,c.declared_quantity;
           if v_sum = 1 then
              Raise_Application_Error(-20001,'库存来源ID【'||r_bond_warehouse_outorder.seqdtlid||'】回退货品数过多,回退失败！');
              exit;
           elsif v_sum = 2 then
               update bond_warehouse_qty_lst set goodsqty = r_bond_warehouse_outorder.goodsqty where seqdtlid = r_bond_warehouse_outorder.seqdtlid;
               /*
               UPDATE bond_warehouse_qty_lst
                      SET goodsqty = (
                        SELECT a.goodsqty,a.outseqid
                        FROM bond_warehouse_outorderdtl a
                        WHERE seqdtlid = r_bond_warehouse_outorder.seqdtlid
                              and a.outseqid = :new.outseqid
                      )
                      WHERE seqdtlid = r_bond_warehouse_outorder.seqdtlid;*/
           else
              select a.goodsqty into v_sum from bond_warehouse_outorderdtl a where a.seqdtlid = r_bond_warehouse_outorder.seqdtlid and a.outseqid = :new.outseqid;
              update bond_warehouse_qty_lst set goodsqty = goodsqty + v_sum where  seqdtlid = r_bond_warehouse_outorder.seqdtlid;
           end if;
         end loop;
         close c_bond_warehouse_outorder;
      end if;
end bond_warehouse_outorder_trg;

ALTER TRIGGER ""LYWMS"".""BOND_WAREHOUSE_OUTORDER_TRG"" ENABLE"
"LYWMS","CDCS_UPLOADINOUTWHDA_TRG","CDCS_UPLOADINOUTWHDA","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""CDCS_UPLOADINOUTWHDA_TRG"" before insert on cdcs_uploadinoutwhda for each row
begin
select cdcs_uploadinoutwhda_seq.nextval into :new.SEQID from dual;
end;


ALTER TRIGGER ""LYWMS"".""CDCS_UPLOADINOUTWHDA_TRG"" ENABLE"
"LYWMS","GSP_APPL_MANAGE_PERMIT_TRI","GSP_APPLIANCE_MANAGE_PERMIT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""GSP_APPL_MANAGE_PERMIT_TRI"" 
  before insert or update on gsp_appliance_manage_permit  
for each row
       begin
  :new.validenddate:=to_date(to_char(:new.validenddate,'yyyymmdd')||' 23:59:59','yyyymmdd hh24:mi:ss');
end gsp_appl_manage_permit_tri;



ALTER TRIGGER ""LYWMS"".""GSP_APPL_MANAGE_PERMIT_TRI"" ENABLE"
"LYWMS","T610_TRI","T610","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""T610_TRI"" 
  before delete on t610
  for each row

      begin
  insert into t610_his
    (iodtlid,zxcolumn8,taxinvno,unitprice,goodsownerid,DEL_DATE)
  values
    (:old.iodtlid,
     :old.zxcolumn8,
     :old.taxinvno,
     :old.unitprice,
     :old.goodsownerid,
     sysdate);
end;


ALTER TRIGGER ""LYWMS"".""T610_TRI"" ENABLE"
"LYWMS","TRG_DPS_TO_WMS","DPS_TO_WMS","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_DPS_TO_WMS"" 
before delete
on dps_to_wms
 begin
insert into dps_to_wms_bak  select * from dps_to_wms;
end;


ALTER TRIGGER ""LYWMS"".""TRG_DPS_TO_WMS"" ENABLE"
"LYWMS","TRG_INTER_FINISH","INTER_FINISH","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_INTER_FINISH"" 
before delete
on inter_finish
 begin
insert into inter_finish_bak  select * from inter_finish;
end;


ALTER TRIGGER ""LYWMS"".""TRG_INTER_FINISH"" ENABLE"
"LYWMS","TRG_INTER_WCS_TASK","INTER_WCS_TASK","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_INTER_WCS_TASK"" 
before delete
on inter_wcs_task
 begin
insert into inter_wcs_task_bak  select * from inter_wcs_task;
end;


ALTER TRIGGER ""LYWMS"".""TRG_INTER_WCS_TASK"" ENABLE"
"LYWMS","TRG_INTER_WMS_TASK","INTER_WMS_TASK","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_INTER_WMS_TASK"" 
before delete
on inter_wms_task
 begin
insert into inter_wms_task_bak  select * from inter_wms_task;
end;


ALTER TRIGGER ""LYWMS"".""TRG_INTER_WMS_TASK"" ENABLE"
"LYWMS","TRG_PURCHASE_ROLLBACK","TPL_PURCHASE_ORDER","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_PURCHASE_ROLLBACK"" 
  Before Update On tpl_purchase_order
  For Each Row
   WHEN (nvl(new.rollbackstatus,0) = 1
       AND nvl(old.rollbackstatus,0) = 0 --必须是0否则所有的收配退和配送差异物流订单无法更改
       and nvl(old.operationtype,0) in(42,44) --必须是收配退和配送差异
       AND nvl(old.feedbackstatus,0) = 1
       and nvl(old.usestatus,0) = 3
       and nvl(new.goodsownerid,0) in(6, 244, 284, 304, 424, 444, 636, 658, 682)
       ) Declare
  v_rowcount number;
  v_xyd number;--差异单
BEGIN
    select count(1) into v_xyd from (
    select distinct a.dtlzxcolumn4,a.porderid 
                          from Tpl_purchase_order_dtl a where a.dtlzxcolumn4 = :new.srcno) b ;
                          
    If  v_xyd = 1 Then
       --必须下单状态且是收配退才能删除
       delete from wms_in_order_dtl t
        where t.inid in (select distinct t1.inid
                          from wms_in_order t1, wms_in_order_dtl tt
                         where  t1.inid = tt.inid
                           and t1.oldid = :new.porderid
                           and t1.usestatus = 1 --下单状态
                           and nvl(tt.clflag, 0)=0 --未收货
                           and t1.operationtype = :new.operationtype);
       v_rowcount := SQL%ROWCOUNT;
       if v_rowcount > 0 then
         --删除物流入库总单
         delete from wms_in_order t where t.oldid = :new.porderid and t.usestatus = 1;
         --删除平台入库细单
         delete from tpl_in_order_dtl t where t.inid = (select inid from tpl_in_order t where t.oldid= :new.porderid);
         --删除平台入库总单
         delete from tpl_in_order t where t.oldid = :new.porderid;
         -- 直接修改当前行的字段值
         :new.usestatus := -1;
         :new.error_msg := '收配退类型的入库订单需要审核!';
         :new.feedbackstatus := 0;
       else
         Raise_Application_Error(-20001,'订单总单ID:'||:new.porderid||',已收货,不能回退!                            
                                                                           
                                                                                      
                                                                                              
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               ');
       end if;
       elsif v_xyd > 1 then
         Raise_Application_Error(-20002,'订单总单ID:'||:new.porderid||',已生成差异单,不允许回退!                            
                                                                           
                                                                                      
                                                                                              
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               ');
    end if;
END;

ALTER TRIGGER ""LYWMS"".""TRG_PURCHASE_ROLLBACK"" ENABLE"
"LYWMS","TRG_T101_HIS","T101","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T101_HIS"" 
  BEFORE DELETE ON T101
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
        
BEGIN
  insert into t101_HIS
    (goodsownerid,
     goodsownid,
     barcode,
     goodsno,
     gopcode,
     gopinyin,
     poison_drug,
     goodsname,
     goodsengname,
     goodsformalname,
     goodstype,
     prodarea,
     factname,
     tradepack,
     outpack,
     outrule,
     alarmdays,
     allowindays,
     allowoutdays,
     safestock,
     addmedcheckflag,
     pasteflag,
     wholesaleprice,
     resaleprice,
     purchasetax,
     saletax,
     lotflag,
     batchflag,
     comeflag,
     memo,
     drugform,
     status,
     otcflag,
     trademark,
     storagecondition,
     approvedocno,
     qualifydocno,
     goodsclassid,
     packsize,
     dbcheck,
     storagetype,
     periodunit,
     validperiod,
     varietyname,
     varietyno,
     supplyername,
     registdocno,
     varietydescid,
     KEYCONSERVEFLAG,
     ecodeflag,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     erpfactoryid,
     erpgoodsid,
     erpgoodsdtlid,
     impflag,
     seqid,
     mah,
     udicode,
     udiflag,
     TRANSCONDITION,
     BUSISCOPENAME,
     prodlicenseno,
     print_goodsname,
     print_goodstype,
     zx_retainqty,
     cre_date,
     del_date)
  VALUES
    (:OLD.goodsownerid,
     :OLD.goodsownid,
     :OLD.barcode,
     :OLD.goodsno,
     :OLD.gopcode,
     :OLD.gopinyin,
     :OLD.poison_drug,
     :OLD.goodsname,
     :OLD.goodsengname,
     :OLD.goodsformalname,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.tradepack,
     :OLD.outpack,
     :OLD.outrule,
     :OLD.alarmdays,
     :OLD.allowindays,
     :OLD.allowoutdays,
     :OLD.safestock,
     :OLD.addmedcheckflag,
     :OLD.pasteflag,
     :OLD.wholesaleprice,
     :OLD.resaleprice,
     :OLD.purchasetax,
     :OLD.saletax,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.memo,
     :OLD.drugform,
     :OLD.status,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.storagecondition,
     :OLD.approvedocno,
     :OLD.qualifydocno,
     :OLD.goodsclassid,
     :OLD.packsize,
     :OLD.dbcheck,
     :OLD.storagetype,
     :OLD.periodunit,
     :OLD.validperiod,
     :OLD.varietyname,
     :OLD.varietyno,
     :OLD.supplyername,
     :OLD.registdocno,
     :OLD.varietydescid,
     :old.KEYCONSERVEFLAG,
     :old.ecodeflag,     
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.erpfactoryid,
     :OLD.erpgoodsid,
     :OLD.erpgoodsdtlid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.mah,
     :OLD.udicode,
     :OLD.udiflag,
     :OLD.TRANSCONDITION,
     :OLD.BUSISCOPENAME,
     :OLD.prodlicenseno,
     :OLD.print_goodsname,
     :OLD.print_goodstype,
     :old.zx_retainqty,
     :OLD.cre_date,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T101_HIS"" ENABLE"
"LYWMS","TRG_T102_HIS","T102","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T102_HIS"" 
  BEFORE DELETE ON T102
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
        BEGIN
  insert into t102_HIS
    (bank,
     goodsownerid,
     gcompanyid,
     companystyle,
     companyname,
     gopinyin,
     opcode,
     companyshortname,
     bankno,
     chiefofficer,
     connector,
     connphone,
     companytype,
     lotlimit,
     validdays,
     deliveraddr,
     province,
     credit,
     usedcredit,
     invoiceaddr,
     invoicehead,
     invoiceman,
     invoicephone,
     postcode,
     specialrequire,
     taxregistno,
     telephone,
     memo,
     addmedcheckflag,
     usestatus,
     companyno,
     station,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     erpcompanyid,
     impflag,
     seqid,
     cre_date,
     del_date)
  VALUES
    (:OLD.bank,
     :OLD.goodsownerid,
     :OLD.gcompanyid,
     :OLD.companystyle,
     :OLD.companyname,
     :OLD.gopinyin,
     :OLD.opcode,
     :OLD.companyshortname,
     :OLD.bankno,
     :OLD.chiefofficer,
     :OLD.connector,
     :OLD.connphone,
     :OLD.companytype,
     :OLD.lotlimit,
     :OLD.validdays,
     :OLD.deliveraddr,
     :OLD.province,
     :OLD.credit,
     :OLD.usedcredit,
     :OLD.invoiceaddr,
     :OLD.invoicehead,
     :OLD.invoiceman,
     :OLD.invoicephone,
     :OLD.postcode,
     :OLD.specialrequire,
     :OLD.taxregistno,
     :OLD.telephone,
     :OLD.memo,
     :OLD.addmedcheckflag,
     :OLD.usestatus,
     :OLD.companyno,
     :OLD.station,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.erpcompanyid,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T102_HIS"" ENABLE"
"LYWMS","TRG_T103_HIS","T103","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T103_HIS"" 
  BEFORE DELETE ON T103
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
    
    
BEGIN
  insert into t103_HIS
    (goodsownerid,
     gocompanyid,
     transid,
     inceptaddr,
     sendrecflag,
     connector,
     connphone,
     telefax,
     postcode,
     memo,
     usestatus,
     areacode,
     areaname,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     tranposname,
     impflag,
     seqid,
     cre_date,
     TRANPOSTYPE,
     del_date,
     ybps)
  VALUES
    (:OLD.goodsownerid,
     :OLD.gocompanyid,
     :OLD.transid,
     :OLD.inceptaddr,
     :OLD.sendrecflag,
     :OLD.connector,
     :OLD.connphone,
     :OLD.telefax,
     :OLD.postcode,
     :OLD.memo,
     :OLD.usestatus,
     :OLD.areacode,
     :OLD.areaname,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.tranposname,
     :OLD.impflag,
     :OLD.seqid,
     :OLD.cre_date,
     :OLD.TRANPOSTYPE,
     SYSDATE,
     :OLD.ybps);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T103_HIS"" ENABLE"
"LYWMS","TRG_T201_HIS","T201","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T201_HIS"" 
  BEFORE DELETE ON T201
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW


BEGIN
  insert into t201_HIS
    (goodsownerid,
     credate,
     goodsid,
     sourcecompanyid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     busiqty,
     qty,
     packsize,
     seqid,
     impflag,
     deldate
     )
  VALUES
    (
     :OLD.goodsownerid,
     :OLD.credate,
     :OLD.goodsid,
     :OLD.sourcecompanyid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.busiqty,
     :OLD.qty,
     :OLD.packsize,
     :OLD.seqid,
     :OLD.impflag,
     sysdate
     );
END;


ALTER TRIGGER ""LYWMS"".""TRG_T201_HIS"" ENABLE"
"LYWMS","TRG_T301_HIS","T301","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T301_HIS"" 
  BEFORE DELETE ON T301
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
     
BEGIN
  insert into t301_HIS
    (goodsownerid,
     porderid,
     credate,
     arrivedate,
     sourcecompanyid,
     companystyle,
     jobtype,
     operationtype,
     medicineclass,
     importflag,
     taxflag,
     dtllines,
     memo,
     porderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     lotflag,
     batchflag,
     comeflag,
     dtlmemo,
     inmode,
     fetchvaliddate,
     orderflag,
     packsize,
     sabackdate,
     sbreasonid,
     sadtlid,
     firstflag,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     packname,
     prtclass,
     bmsdocid,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     transid,
     del_date,
     NOWLFLAG,
     mulrecflag,
     AUTOFLAG,
     FROM_SALESID,
     FROM_SALESDTLID,
     autopassflag,
     to_sourcecompanyid,
     to_erpinid,
     to_erpindtlid,
     to_erpoutid,
     to_erpoutdtlid,
     agentname,
     price)
  VALUES
    (:OLD.goodsownerid,
     :OLD.porderid,
     :OLD.credate,
     :OLD.arrivedate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.importflag,
     :OLD.taxflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.porderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.lotflag,
     :OLD.batchflag,
     :OLD.comeflag,
     :OLD.dtlmemo,
     :OLD.inmode,
     :OLD.fetchvaliddate,
     :OLD.orderflag,
     :OLD.packsize,
     :OLD.sabackdate,
     :OLD.sbreasonid,
     :OLD.sadtlid,
     :OLD.firstflag,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.packname,
     :OLD.prtclass,
     :OLD.bmsdocid,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.transid,
     SYSDATE,
     :old.NOWLFLAG,
     :old.mulrecflag,
     :old.AUTOFLAG,
     :old.FROM_SALESID,
     :old.FROM_SALESDTLID,
     :old.autopassflag,
     :old.to_sourcecompanyid,
     :old.to_erpinid,
     :old.to_erpindtlid,
     :old.to_erpoutid,
     :old.to_erpoutdtlid,
     :old.agentname,
     :old.price);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T301_HIS"" ENABLE"
"LYWMS","TRG_T302_HIS","T302","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T302_HIS"" 
  BEFORE DELETE ON T302
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
   
 
    
BEGIN
  insert into t302_HIS
    (goodsownerid,
     exporderid,
     lineno,
     credate,
     preexpdate,
     expcompanyid,
     companystyle,
     jobtype,
     addinvoiceflag,
     companytype,
     operationtype,
     medicineclass,
     receiveaddr,
     receivehead,
     receiveman,
     samelotflag,
     taxflag,
     transmodeid,
     urgenflag,
     dtllines,
     memo,
     exporderdtlid,
     goodsid,
     gstorageid,
     batchno,
     lotno,
     validdate,
     proddate,
     goodstatus,
     quanstatus,
     approvedocno,
     tradepack,
     qty,
     addmedcheckflag,
     dtlmemo,
     partexpflag,
     outmode,
     invoicetype,
     placesupplyid,
     placesupplydtlid,
     placeprice,
     resaleprice,
     placemoney,
     otcflag,
     trademark,
     qualitydocno,
     goodsclassname,
     packsize,
     isboxup,
     planarrive,
     pionarrive,
     addressid,
     spellbillno,
     specialtype,
     deptno,
     deptname,
     amt,
     whid,
     orderflag,
     fixflag,
     salerid,
     salername,
     trdtlid,
     sasettledtlid,
     prtclass,
     prtorderset,
     prtgroupset,
     invno,
     packname,
     sorttype,
     zxcolumn1,
     zxcolumn2,
     zxcolumn3,
     zxcolumn4,
     zxcolumn5,
     zxcolumn6,
     zxcolumn7,
     zxcolumn8,
     zxcolumn9,
     zxcolumn10,
     impflag,
     transclass,
     storageid,
     dtlzxcolumn1,
     dtlzxcolumn2,
     dtlzxcolumn3,
     dtlzxcolumn4,
     dtlzxcolumn5,
     lyzxcolumn1,
     lyzxcolumn2,
     lyzxcolumn3,
     lyzxcolumn4,
     lyzxcolumn5,
     lyzxcolumn6,
     lyzxcolumn7,
     lyzxcolumn8,
     lyzxcolumn9,
     lyzxcolumn10,
     lydtlzxcolumn1,
     lydtlzxcolumn2,
     lydtlzxcolumn3,
     lydtlzxcolumn4,
     lydtlzxcolumn5,
     lydtlzxcolumn6,
     lydtlzxcolumn7,
     lydtlzxcolumn8,
     lydtlzxcolumn9,
     lydtlzxcolumn10,
     lyzxcolumn11,
     lyzxcolumn12,
     lyzxcolumn13,
     lyzxcolumn14,
     lyzxcolumn15,
     lyzxcolumn16,
     lyzxcolumn17,
     lyzxcolumn18,
     lyzxcolumn19,
     lyzxcolumn20,
     del_date,
     NOWLFLAG,
     AUTOFLAG,
     FROM_SUDOCID,
     FROM_SUDTLID,
     to_transid,
     passingflag,
     autopassflag,
     to_expcompanyid,
     to_addressid,
     to_erpinid,
     to_erpoutid,
     to_erpindtlid,
     to_erpoutdtlid,
     to_printprice,
     to_printamt,
     zx_djflag,
     discount_falg,
     discount_sadtlid,
     discount_goodsid,
     discount_amt,
     discount_taxrate,
     ysorderflag,
     yscredate
     )
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.lineno,
     :OLD.credate,
     :OLD.preexpdate,
     :OLD.expcompanyid,
     :OLD.companystyle,
     :OLD.jobtype,
     :OLD.addinvoiceflag,
     :OLD.companytype,
     :OLD.operationtype,
     :OLD.medicineclass,
     :OLD.receiveaddr,
     :OLD.receivehead,
     :OLD.receiveman,
     :OLD.samelotflag,
     :OLD.taxflag,
     :OLD.transmodeid,
     :OLD.urgenflag,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.gstorageid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.proddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.tradepack,
     :OLD.qty,
     :OLD.addmedcheckflag,
     :OLD.dtlmemo,
     :OLD.partexpflag,
     :OLD.outmode,
     :OLD.invoicetype,
     :OLD.placesupplyid,
     :OLD.placesupplydtlid,
     :OLD.placeprice,
     :OLD.resaleprice,
     :OLD.placemoney,
     :OLD.otcflag,
     :OLD.trademark,
     :OLD.qualitydocno,
     :OLD.goodsclassname,
     :OLD.packsize,
     :OLD.isboxup,
     :OLD.planarrive,
     :OLD.pionarrive,
     :OLD.addressid,
     :OLD.spellbillno,
     :OLD.specialtype,
     :OLD.deptno,
     :OLD.deptname,
     :OLD.amt,
     :OLD.whid,
     :OLD.orderflag,
     :OLD.fixflag,
     :OLD.salerid,
     :OLD.salername,
     :OLD.trdtlid,
     :OLD.sasettledtlid,
     :OLD.prtclass,
     :OLD.prtorderset,
     :OLD.prtgroupset,
     :OLD.invno,
     :OLD.packname,
     :OLD.sorttype,
     :OLD.zxcolumn1,
     :OLD.zxcolumn2,
     :OLD.zxcolumn3,
     :OLD.zxcolumn4,
     :OLD.zxcolumn5,
     :OLD.zxcolumn6,
     :OLD.zxcolumn7,
     :OLD.zxcolumn8,
     :OLD.zxcolumn9,
     :OLD.zxcolumn10,
     :OLD.impflag,
     :OLD.transclass,
     :OLD.storageid,
     :OLD.dtlzxcolumn1,
     :OLD.dtlzxcolumn2,
     :OLD.dtlzxcolumn3,
     :OLD.dtlzxcolumn4,
     :OLD.dtlzxcolumn5,
     :OLD.lyzxcolumn1,
     :OLD.lyzxcolumn2,
     :OLD.lyzxcolumn3,
     :OLD.lyzxcolumn4,
     :OLD.lyzxcolumn5,
     :OLD.lyzxcolumn6,
     :OLD.lyzxcolumn7,
     :OLD.lyzxcolumn8,
     :OLD.lyzxcolumn9,
     :OLD.lyzxcolumn10,
     :OLD.lydtlzxcolumn1,
     :OLD.lydtlzxcolumn2,
     :OLD.lydtlzxcolumn3,
     :OLD.lydtlzxcolumn4,
     :OLD.lydtlzxcolumn5,
     :OLD.lydtlzxcolumn6,
     :OLD.lydtlzxcolumn7,
     :OLD.lydtlzxcolumn8,
     :OLD.lydtlzxcolumn9,
     :OLD.lydtlzxcolumn10,
     :OLD.lyzxcolumn11,
     :OLD.lyzxcolumn12,
     :OLD.lyzxcolumn13,
     :OLD.lyzxcolumn14,
     :OLD.lyzxcolumn15,
     :OLD.lyzxcolumn16,
     :OLD.lyzxcolumn17,
     :OLD.lyzxcolumn18,
     :OLD.lyzxcolumn19,
     :OLD.lyzxcolumn20,
     SYSDATE,
     :old.NOWLFLAG,
     :old.AUTOFLAG,
     :old.FROM_SUDOCID,
     :old.FROM_SUDTLID,
     :old.to_transid,
     :old.passingflag,
     :old.autopassflag,
     :old.to_expcompanyid,
     :old.to_addressid,
     :old.to_erpinid,
     :old.to_erpoutid,
     :old.to_erpindtlid,
     :old.to_erpoutdtlid,
     :old.to_printprice,
     :old.to_printamt,
     :old.zx_djflag,
     :old.discount_falg,
     :old.discount_sadtlid,
     :old.discount_goodsid,
     :old.discount_amt,
     :old.discount_taxrate,
     :old.ysorderflag,
     :old.yscredate
     );
END;


ALTER TRIGGER ""LYWMS"".""TRG_T302_HIS"" ENABLE"
"LYWMS","TRG_T310_HIS","T310","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T310_HIS"" 
  BEFORE DELETE ON T310
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

       BEGIN
  insert into t310_his
    (goodsownerid,
     credate,
     jobflag,
     operationtype,
     jobid,
     jobdtlid,
     memo,
     impflag,
     del_date)
  values
    (:old.goodsownerid,
     :old.credate,
     :old.jobflag,
     :old.operationtype,
     :old.jobid,
     :old.jobdtlid,
     :old.memo,
     :old.impflag,
     sysdate);
end;


ALTER TRIGGER ""LYWMS"".""TRG_T310_HIS"" ENABLE"
"LYWMS","TRG_T320_HIS","T320","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T320_HIS"" 
  BEFORE DELETE ON T320
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW



BEGIN
  insert into t320_HIS
    (goodsownerid,
     lorderid,
     porderid,
     operationtype,
     opstatus,
     arrivedate,
     putupdate,
     sourcecompanyid,
     companystyle,
     dtllines,
     memo,
     lorderdtlid,
     porderdtlid,
     srcdtlno,
     goodsid,
     storageid,
     goodsname,
     packname,
     packsize,
     packunit,
     batchno,
     lotno,
     validdate,
     prddate,
     approvedocno,
     goodstype,
     prodarea,
     factname,
     supplyname,
     goodstatus,
     quanstatus,
     tradepack,
     realrecvqty,
     tinyid,
     tinyqty,
     dtlmemo,
     medchkrptno,
     checkdate,
     transtemp,
     importrepflag,
     passgateflag,
     registeflag,
     medcheckflag,
     eligibilityflag,
     approveno,
     impregno,
     rptno,
     backwhyid,
     checkman1,
     checkman2,
     registno,
     sectionid,
     procerrflag,
     PRINTMONTHFLAG,
     del_date)
  VALUES
    (:OLD.goodsownerid,
     :OLD.lorderid,
     :OLD.porderid,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.arrivedate,
     :OLD.putupdate,
     :OLD.sourcecompanyid,
     :OLD.companystyle,
     :OLD.dtllines,
     :OLD.memo,
     :OLD.lorderdtlid,
     :OLD.porderdtlid,
     :OLD.srcdtlno,
     :OLD.goodsid,
     :OLD.storageid,
     :OLD.goodsname,
     :OLD.packname,
     :OLD.packsize,
     :OLD.packunit,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.approvedocno,
     :OLD.goodstype,
     :OLD.prodarea,
     :OLD.factname,
     :OLD.supplyname,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.tradepack,
     :OLD.realrecvqty,
     :OLD.tinyid,
     :OLD.tinyqty,
     :OLD.dtlmemo,
     :OLD.medchkrptno,
     :OLD.checkdate,
     :OLD.transtemp,
     :OLD.importrepflag,
     :OLD.passgateflag,
     :OLD.registeflag,
     :OLD.medcheckflag,
     :OLD.eligibilityflag,
     :OLD.approveno,
     :OLD.impregno,
     :OLD.rptno,
     :OLD.backwhyid,
     :OLD.checkman1,
     :OLD.checkman2,
     :OLD.registno,
     :OLD.sectionid,
     :OLD.procerrflag,
     :OLD.PRINTMONTHFLAG,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T320_HIS"" ENABLE"
"LYWMS","TRG_T340_HIS","T340","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T340_HIS"" 
  BEFORE DELETE ON T340
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW




BEGIN
  insert into t340_HIS
    (goodsownerid,
     exporderid,
     srcexpno,
     lineno,
     operationtype,
     opstatus,
     preexpdate,
     prearrivedate,
     ttransmode,
     transno,
     expdate,
     gcompanyid,
     detaillines,
     exportmemo,
     srcexpdtlno,
     exporderdtlid,
     goodsid,
     batchno,
     lotno,
     validdate,
     prddate,
     goodstatus,
     quanstatus,
     approvedocno,
     registno,
     tradegoodspack,
     goodsqty,
     tradegoodsqty,
     expdtlmemo,
     packsize,
     status,
     gostockid,
     procerrflag,
     wholefinpacks,
     scatterfinpacks,
     del_date
     )
  VALUES
    (:OLD.goodsownerid,
     :OLD.exporderid,
     :OLD.srcexpno,
     :OLD.lineno,
     :OLD.operationtype,
     :OLD.opstatus,
     :OLD.preexpdate,
     :OLD.prearrivedate,
     :OLD.ttransmode,
     :OLD.transno,
     :OLD.expdate,
     :OLD.gcompanyid,
     :OLD.detaillines,
     :OLD.exportmemo,
     :OLD.srcexpdtlno,
     :OLD.exporderdtlid,
     :OLD.goodsid,
     :OLD.batchno,
     :OLD.lotno,
     :OLD.validdate,
     :OLD.prddate,
     :OLD.goodstatus,
     :OLD.quanstatus,
     :OLD.approvedocno,
     :OLD.registno,
     :OLD.tradegoodspack,
     :OLD.goodsqty,
     :OLD.tradegoodsqty,
     :OLD.expdtlmemo,
     :OLD.packsize,
     :OLD.status,
     :OLD.gostockid,
     :OLD.procerrflag,
     :OLD.wholefinpacks,
     :OLD.scatterfinpacks,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""TRG_T340_HIS"" ENABLE"
"LYWMS","TRG_T400_HIS","T400","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T400_HIS"" 
  BEFORE DELETE ON T400
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

 
      
BEGIN
insert into T400_his
(
 goodsownerid,
       tradeid,
       tradedate,
       operationtype,
       dtllines,
       usestatus,
       tradedtlid,
       ownergoodsid,
       fromcompanyid,
       fromstorageid,
       fromgoodstatus,
       fromquanstatus,
       frombatchno,
       fromlotno,
       fromproddate,
       fromvaliddate,
       fromapproveno,
       tocompanyid,
       tostorageid,
       togoodstatus,
       toqunstatus,
       tobatchno,
       tolotno,
       toproddate,
       tovaliddate,
       toapproveno,
       tradegoodsqty,
       tradegoodspack,
       goodspackid,
       qty,
       gstorageid,
       packname,
       packsize,
       sectionid,
       fromregistno,
       toregistno,
       tosectionid,
       srcdtlid,--add by wanghuaiyu 20130714
       warehid -- add by xyue 2016-03-09
       )
       values
     (
 :old.goodsownerid,
      :old.tradeid,
       :old.tradedate,
       :old.operationtype,
       :old.dtllines,
      :old.usestatus,
       :old.tradedtlid,
       :old.ownergoodsid,
       :old.fromcompanyid,
       :old.fromstorageid,
       :old.fromgoodstatus,
       :old.fromquanstatus,
       :old.frombatchno,
       :old.fromlotno,
       :old.fromproddate,
       :old.fromvaliddate,
       :old.fromapproveno,
      :old.tocompanyid,
       :old.tostorageid,
       :old.togoodstatus,
       :old.toqunstatus,
       :old.tobatchno,
       :old.tolotno,
       :old.toproddate,
       :old.tovaliddate,
       :old.toapproveno,
       :old.tradegoodsqty,
       :old.tradegoodspack,
       :old.goodspackid,
       :old.qty,
       :old.gstorageid,
       :old.packname,
       :old.packsize,
       :old.sectionid,
       :old.fromregistno,
       :old.toregistno,
       :old.tosectionid,
       :old.srcdtlid,--add by wanghuaiyu 20130714
       :old.warehid --add by xyue 2016-03-09
       );

end;


ALTER TRIGGER ""LYWMS"".""TRG_T400_HIS"" ENABLE"
"LYWMS","TRG_T_DESTROYMESSAGE","WMS_OUT_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_DESTROYMESSAGE"" 
  after update of DESTROYSTATUS on wms_out_order
  for each row

declare queueid number;

begin

      if nvl(:old.DESTROYSTATUS,0) <> :new.DESTROYSTATUS and :new.DESTROYSTATUS=1  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 49,
                 :new.outid,
                 null,
                 null,
                 queueid);

      end if;
  end ;


ALTER TRIGGER ""LYWMS"".""TRG_T_DESTROYMESSAGE"" ENABLE"
"LYWMS","TRG_T_GSP_CONSERVE","GSP_CONSERVE","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_GSP_CONSERVE"" 
  after update of usestatus on gsp_conserve
  for each row
  
declare p number;
begin
    
      if nvl(:old.usestatus,0) <> :new.usestatus and :old.goodsownerid in (340,520) and :new.usestatus=2 then
      
      select tpl_edi_queue_seq.nextval into p from dual;
-- usestatus 1.临时 2.确定
        insert into tpl_edi_queue
          values (:old.goodsownerid,
                 sysdate,
                 47,
                 :old.conserveid,
                 null,
                 null,
                 p);
            
      end if;
  end ;


ALTER TRIGGER ""LYWMS"".""TRG_T_GSP_CONSERVE"" ENABLE"
"LYWMS","TRG_T_GSP_PHYSIC_QUALITY_CHECK","WMS_IN_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_GSP_PHYSIC_QUALITY_CHECK"" 
  after update of usestatus on wms_in_order
  for each row

declare queueid number;

begin

      if nvl(:old.usestatus,0) <> :new.usestatus and :old.goodsownerid in (520) and :new.usestatus=3  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 48,
                 :old.inid,
                 null,
                 null,
                 queueid);

      end if;
  end ;


ALTER TRIGGER ""LYWMS"".""TRG_T_GSP_PHYSIC_QUALITY_CHECK"" ENABLE"
"LYWMS","TRG_T_GSP_QUALITY_FEEDBACK","GSP_QUALITY_FEEDBACK","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_GSP_QUALITY_FEEDBACK"" 
  after update of usestatus on gsp_quality_feedback
  for each row

declare queueid number;

begin

      if nvl(:old.usestatus,0) <> :new.usestatus  then

        select tpl_edi_queue_seq.nextval into queueid from dual;
        insert into tpl_edi_queue
        values (
           :new.goodsownerid,
                 sysdate,
                 45,
                 :new.FEEDBACKID,
                 null,
                 null,
                 queueid);

      end if;
  end ;


ALTER TRIGGER ""LYWMS"".""TRG_T_GSP_QUALITY_FEEDBACK"" ENABLE"
"LYWMS","TRG_T_GSP_RECHECKWMS_HIS","T_GSP_QUALITY_RECHECK_WMS","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_GSP_RECHECKWMS_HIS"" 
  BEFORE DELETE ON T_GSP_QUALITY_RECHECK_WMS
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
BEGIN
insert into T_GSP_QUALITY_RECHECK_WMS_HIS t
(
     t.feedbackid,
     t.credate,
     t.goodsownerid,
     t.wtfqualitydeptidea,
     t.wtfrelatedeptidea,
     t.dealresult,
     t.del_date,
     t.impflag
       )
       values
     (
     :old.feedbackid,
     :old.credate,
     :old.goodsownerid,
     :old.wtfqualitydeptidea,
     :old.wtfrelatedeptidea,
     :old.dealresult,
     sysdate,
     :old.impflag
       );

end;


ALTER TRIGGER ""LYWMS"".""TRG_T_GSP_RECHECKWMS_HIS"" ENABLE"
"LYWMS","TRG_T_SHGL","WMS_IN_ORDER_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_T_SHGL"" 
  after update of shdate on wms_in_order_dtl
  for each row
begin
    
      if nvl(:old.shdate,to_date('1900-01-01','yyyy-mm-dd')) <> :new.shdate  then

        insert into tpl_edi_queue
          select t.goodsownerid,
                 sysdate,
                 44,
                 :old.inid,
                 null,
                 null,
                 tpl_edi_queue_seq.nextval
            from wms_in_order t
           where t.inid = :old.inid and t.goodsownerid in (340,520) ;
      end if;
  end ;


ALTER TRIGGER ""LYWMS"".""TRG_T_SHGL"" ENABLE"
"LYWMS","TRG_WMS_GOODSGROUP_TMP_HIS","WMS_GOODSGROUP_ORDER_TMP","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_WMS_GOODSGROUP_TMP_HIS"" 
  BEFORE DELETE ON WMS_GOODSGROUP_ORDER_TMP
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into WMS_GOODSGROUP_ORDER_TMP_HIS
    (seqid,
     WAREHID,
     GOODSOWNERID,
     CREDATE,
     ERPDOCID,
     ERPDTLID,
     OPERATIONTYPE,
     INPUTMANID,
     INPUTMANNAME,
     GROUPID,
     MEMO,
     DTLLINES,
     GSTORAGEID,
     GOODSID,
     tradepackname,
     packname,
     PACKSIZE,
     BATCHNO,
     LOTNO,
     VALIDDATE,
     PRODDATE,
     APPROVEDOCNO,
     GOODSSTATUSID,
     QUANTITYSTATUS,
     GOODSQTY,
     DTLMEMO,
     IMPFLAG,
     COMPANYSTYLE,
     GCOMPANYID,
     DEL_DATE)
  VALUES
    (:OLD.seqid,
     :OLD.WAREHID,
     :OLD.GOODSOWNERID,
     :OLD.CREDATE,
     :OLD.ERPDOCID,
     :OLD.ERPDTLID,
     :OLD.OPERATIONTYPE,
     :OLD.INPUTMANID,
     :OLD.INPUTMANNAME,
     :OLD.GROUPID,
     :OLD.MEMO,
     :OLD.DTLLINES,
     :OLD.GSTORAGEID,
     :OLD.GOODSID,
     :OLD.tradepackname,
     :OLD.packname,
     :OLD.PACKSIZE,
     :OLD.BATCHNO,
     :OLD.LOTNO,
     :OLD.VALIDDATE,
     :OLD.PRODDATE,
     :OLD.APPROVEDOCNO,
     :OLD.GOODSSTATUSID,
     :OLD.QUANTITYSTATUS,
     :OLD.GOODSQTY,
     :OLD.DTLMEMO,
     :OLD.IMPFLAG,
     :OLD.COMPANYSTYLE,
     :OLD.GCOMPANYID,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""TRG_WMS_GOODSGROUP_TMP_HIS"" ENABLE"
"LYWMS","TRG_WMS_HIS_PATCH","WMS_BOX_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_WMS_HIS_PATCH"" 
  after update on wms_box_dtl
  for each row
     begin
  --当修改装箱单总单时删除医院收货服务单。
  if :old.docid <> :new.docid then
    delete from wms_his_patch t
    where exists(select 1 from wms_turnbox_to_box_rel t1
                                  where t.inoutid=t1.inoutid
                                  and t1.boxdtlid = :new.dtlid );
   end if;
end trg_wms_his_patch;


ALTER TRIGGER ""LYWMS"".""TRG_WMS_HIS_PATCH"" ENABLE"
"LYWMS","TRG_WMS_LOT_MODIFY_LST","WMS_LOT_MODIFY_LST","INSERT OR UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_WMS_LOT_MODIFY_LST"" 
after INSERT OR UPDATE
ON wms_lot_modify_lst
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
 
        declare
  num1 number;
BEGIN
  select count(*)
  into num1
  from tpl_goods a where a.waregoodsid=:new.goodsid and a.goodsownerid=2;

  if :new.usestatus=2 and num1 > 0 then
  insert into tpl_edi_queue(goodsownerid,credate,queuetype,srcid,seqid)
  values(2,sysdate,5,:new.modifyid,tpl_edi_queue_seq.nextval);
  end if;
END;


ALTER TRIGGER ""LYWMS"".""TRG_WMS_LOT_MODIFY_LST"" ENABLE"
"LYWMS","TRG_WMS_TO_DPS","WMS_TO_DPS","DELETE","BEFORE STATEMENT","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_WMS_TO_DPS"" 
before delete
on wms_to_dps
 begin
insert into wms_to_dps_bak  select * from wms_to_dps;
end;


ALTER TRIGGER ""LYWMS"".""TRG_WMS_TO_DPS"" ENABLE"
"LYWMS","TRG_ZX_PURCHASE_INVNO_HIS","ZX_PURCHASE_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_ZX_PURCHASE_INVNO_HIS"" 
  BEFORE DELETE ON ZX_PURCHASE_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into ZX_PURCHASE_INVNO_his
    (goodsownerid,
     suconid,
     sucondtlid,
     invcode,
     invno,
     invdate,
     credate,
     del_date,
     seqid)
  values
    (:old.goodsownerid,
     :old.suconid,
     :old.sucondtlid,
     :old.invcode,
     :old.invno,
     :old.invdate,
     :old.credate,
     sysdate,
     :old.seqid);
end;

ALTER TRIGGER ""LYWMS"".""TRG_ZX_PURCHASE_INVNO_HIS"" ENABLE"
"LYWMS","TRG_ZX_SALES_INVNO_HIS","ZX_SALES_INVNO","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_ZX_SALES_INVNO_HIS"" 
  BEFORE DELETE ON ZX_SALES_INVNO
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

--change by xyue 2017-11-28 增加发票代码字段
BEGIN
  insert into ZX_SALES_INVNO_his
    (salesdtlid,
     invno,
     seqid,
     goodsownerid,
     salesid,
     INVCODE,
     invoaddress,
     cre_date,
     del_date)
  values
    (:old.salesdtlid,
     :old.invno,
     :old.seqid,
     :old.goodsownerid,
     :old.salesid,
     :old.INVCODE,
     :old.invoaddress,
     :old.cre_date,
     sysdate);
end;

ALTER TRIGGER ""LYWMS"".""TRG_ZX_SALES_INVNO_HIS"" ENABLE"
"LYWMS","TRG_ZX_SALES_INVNO_WB_HIS","ZX_SALES_INVNO_WB","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TRG_ZX_SALES_INVNO_WB_HIS"" 
  BEFORE DELETE ON ZX_SALES_INVNO_WB
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into ZX_SALES_INVNO_WB_his
    (salesdtlid,
     invno,
     seqid,
     goodsownerid,
     salesid,
     INVCODE,
     del_date,
     credate,
     invoaddress)
  values
    (:old.salesdtlid,
     :old.invno,
     :old.seqid,
     :old.goodsownerid,
     :old.salesid,
     :old.INVCODE,
     sysdate,
     :old.credate,
     :old.invoaddress);
end;

ALTER TRIGGER ""LYWMS"".""TRG_ZX_SALES_INVNO_WB_HIS"" ENABLE"
"LYWMS","TR_GSP_QUALITY_FEEDBACK","WMS_TRADE_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TR_GSP_QUALITY_FEEDBACK"" 
  after update of usestatus
  on wms_trade_order
  for each row

begin

      if :old.usestatus <> :new.usestatus and :new.usestatus = 3 and :new.operationtype in (24, 31)
      and :old.goodsownerid = 340 then

        insert into gsp_quality_feedback a
          (a.feedbackid,
           a.goodsid,
           a.goodsqty,
           a.lotid,
           a.inputmanid,
           a.credate,
           a.goodsownerid,
           a.warehid,
           a.ownergoodsid,
           a.goodssituation,
           a.comefrom,
           a.tradeid)
          select gsp_quality_feedback_seq.nextval,
                 t.goodsid,
                 t.qty,
                 t.tolotid,
                 :new.inputmanid,
                 :new.tradedate,
                 :new.goodsownerid,
                 :new.warehid,
                 t.ownergoodsid,
                 t.dtlmemo,
                 :new.operationtype,
                 t.tradeid
            from wms_trade_dtl t
           where t.tradeid = :old.tradeid
             and t.togoodsstatusid = 8;
      end if;

end tr_gsp_quality_feedback;


ALTER TRIGGER ""LYWMS"".""TR_GSP_QUALITY_FEEDBACK"" ENABLE"
"LYWMS","TR_WMS_TRADE_ORDER_U","WMS_TRADE_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TR_WMS_TRADE_ORDER_U"" 
  after update of usestatus
  on wms_trade_order
  for each row
begin

      if :old.usestatus <> :new.usestatus and :new.usestatus = 3 and :new.operationtype in (24, 31) then
        --select * From GSP_goods_Unqualified
        --select * From wms_trade_order a,wms_trade_order_dtl
        --select * from wms_trade_dtl
        insert into gsp_goods_unqualified
          select gsp_goods_unqualified_seq.nextval,
                 goodsid,
                 t.goodspackid,
                 0,
                 t.tolotid,
                 t.toposid,
                 t.qty,
                 t.dtlmemo,
                 '',
                 '',
                 :new.goodsownerid,
                 :old.tradedate,
                 :old.inputmanid,
                 '',
                 '',
                 0,
                 '',
                 t.tradedtlid,
                 t.ownergoodsid,
                 :old.warehid,
                 t.togoodsstatusid,
                 0 usestatus
            from wms_trade_dtl t
            --wms_trade_order tt
           where t.tradeid = :old.tradeid
             --and t.tradeid = tt.tradeid
             and t.togoodsstatusid = 3;
      end if;

end tr_wms_trade_order_u;



ALTER TRIGGER ""LYWMS"".""TR_WMS_TRADE_ORDER_U"" ENABLE"
"LYWMS","TR_ZX_TWOBOXING_DEL","ZX_TWOBOXING","DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TR_ZX_TWOBOXING_DEL"" 
after delete
on zx_twoboxing
FOR EACH ROW

begin
update wms_container_def t set t.usestatus = 1 where t.containerid =:new.wboxid;

end;


ALTER TRIGGER ""LYWMS"".""TR_ZX_TWOBOXING_DEL"" DISABLE"
"LYWMS","TR_ZX_TWOBOXING_UPDATE","ZX_TWOBOXING","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""TR_ZX_TWOBOXING_UPDATE"" 
after INSERT
on zx_twoboxing
FOR EACH ROW

begin
update wms_container_def t set t.usestatus = 2 where t.containerid =:new.wboxid;

end;


ALTER TRIGGER ""LYWMS"".""TR_ZX_TWOBOXING_UPDATE"" DISABLE"
"LYWMS","T_TMP_ZH_TJB","TMP_ZH_TJB","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""T_TMP_ZH_TJB"" 
before insert on  tmp_zh_tjb
for each row
begin
select tmp_zh_tjb_seq.nextval into :new.zxid from dual;
end t_tmp_zh_tjb;


ALTER TRIGGER ""LYWMS"".""T_TMP_ZH_TJB"" ENABLE"
"LYWMS","T_WCS_TO_WMS_BOXBIND_TRG","T_WCS_TO_WMS_BOXBIND","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""T_WCS_TO_WMS_BOXBIND_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_BOXBIND
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_BOXBIND_BAK
    (WAREHID,
    TASKID,
    BOXBARCODE,
    LTIME,
    DELDATE)
  VALUES
    (:OLD.WAREHID,
    :OLD.TASKID,
    :OLD.BOXBARCODE,
    :OLD.LTIME,
    SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""T_WCS_TO_WMS_BOXBIND_TRG"" ENABLE"
"LYWMS","T_WCS_TO_WMS_DZBQFINISH_TRG","T_WCS_TO_WMS_DZBQFINISH","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""T_WCS_TO_WMS_DZBQFINISH_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_DZBQFINISH
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_DZBQFINISH_BAK
    (DELDATE,
     BOXBARCODE,
     LOC,
     QTY,
     LTIME,
     WMSWORKTYPE,
     WAREHID,
     WMSSERIALKEY)
  VALUES
    (SYSDATE,
     :OLD.BOXBARCODE,
     :OLD.LOC,
     :OLD.QTY,
     :OLD.LTIME,
     :OLD.WMSWORKTYPE,
     :OLD.WAREHID,
     :OLD.WMSSERIALKEY);
END;


ALTER TRIGGER ""LYWMS"".""T_WCS_TO_WMS_DZBQFINISH_TRG"" ENABLE"
"LYWMS","T_WCS_TO_WMS_WORKFINISH_TRG","T_WCS_TO_WMS_WORKFINISH","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""T_WCS_TO_WMS_WORKFINISH_TRG"" 
  BEFORE DELETE ON T_WCS_TO_WMS_WORKFINISH
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW

BEGIN
  insert into T_WCS_TO_WMS_WORKFINISH_BAK
    (WAREHID,
     WMSWORKINDEX,
     WMSWORKTYPE,
     PALLETID,
     RETURNCODE,
     RETURNDESCR,
     LTIME,
     DELDATE)
  VALUES
    (:OLD.WAREHID,
     :OLD.WMSWORKINDEX,
     :OLD.WMSWORKTYPE,
     :OLD.PALLETID,
     :OLD.RETURNCODE,
     :OLD.RETURNDESCR,
     :OLD.LTIME,
     SYSDATE);
END;


ALTER TRIGGER ""LYWMS"".""T_WCS_TO_WMS_WORKFINISH_TRG"" ENABLE"
"LYWMS","WCS_DEVICE_GOODS_IN_TRG","WCS_DEVICE_GOODS_IN","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""WCS_DEVICE_GOODS_IN_TRG"" 
  after update of usestatus
  on wcs_device_goods_in
  for each row

declare
  v_count number;--计数
  v_newqty number; --更新后库存

begin
  --入库单由【临时】->【正式】,先按goodsid查库存表是否存在,存在就数量叠加,不存在就新增一条库存记录
  if :new.usestatus = 1 then 
    select count(1)
      into v_count
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_count<>0 then
      update wcs_device_goods_qty t
         set t.goodsqty = t.goodsqty + :new.goodsqty
       where t.goodsid = :new.goodsid;
    else
      insert into wcs_device_goods_qty
        (goodsid, goodsqty)
      values
        (:new.goodsid, :new.goodsqty);
    end if;
  end if;
  
  --入库单回退确定由【正式】->【临时】,先按goodsid查库存表扣减库存，扣减出现负数就报错
  --扣减完成后库存数量为0,则删除记录
  if nvl(:new.usestatus,0) = 0 then 
    select nvl(max(t.goodsqty), 0) - :new.goodsqty
      into v_newqty
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_newqty > 0 then 
      update wcs_device_goods_qty t
         set t.goodsqty = v_newqty
       where t.goodsid = :new.goodsid;
    elsif v_newqty = 0 then --更新后库存为0 删除库存表记录
      delete wcs_device_goods_qty t where t.goodsid = :new.goodsid;
    else
      Raise_Application_Error(-20001,'回退确定后该货品库存数量小于0,不允许回退!');
    end if;  
  end if;
  
end wcs_device_goods_in_trg;

ALTER TRIGGER ""LYWMS"".""WCS_DEVICE_GOODS_IN_TRG"" ENABLE"
"LYWMS","WCS_DEVICE_GOODS_OUT_TRG","WCS_DEVICE_GOODS_OUT","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""WCS_DEVICE_GOODS_OUT_TRG"" 
  after update of usestatus
  on wcs_device_goods_out
  for each row

declare
  v_count number;--计数
  v_newqty number; --更新后库存

begin
  --出库单确定由【正式】->【临时】,先按goodsid查库存表扣减库存，扣减出现负数就报错
  --扣减完成后库存数量为0,则删除记录
  if nvl(:new.usestatus,0) = 1 then 
    select nvl(max(t.goodsqty), 0) - :new.goodsqty
      into v_newqty
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_newqty > 0 then 
      update wcs_device_goods_qty t
         set t.goodsqty = v_newqty
       where t.goodsid = :new.goodsid;
    elsif v_newqty = 0 then --更新后库存为0 删除库存表记录
      delete wcs_device_goods_qty t where t.goodsid = :new.goodsid;
    else
      Raise_Application_Error(-20001,'出库单确定后该货品库存数量小于0,不允许确定!请检查库存数量!');
    end if;  
  end if;
  
  --出库单由【正式】->【临时】,先按goodsid查库存表是否存在,存在就数量叠加,不存在就新增一条库存记录
  if nvl(:new.usestatus,0) = 0 then 
    select count(1)
      into v_count
      from wcs_device_goods_qty t
     where t.goodsid = :new.goodsid;

    if v_count<>0 then
      update wcs_device_goods_qty t
         set t.goodsqty = t.goodsqty + :new.goodsqty
       where t.goodsid = :new.goodsid;
    else
      insert into wcs_device_goods_qty
        (goodsid, goodsqty)
      values
        (:new.goodsid, :new.goodsqty);
    end if;
  end if;  
end wcs_device_goods_out_trg;

ALTER TRIGGER ""LYWMS"".""WCS_DEVICE_GOODS_OUT_TRG"" ENABLE"
"LYWMS","ZX_710030_INCEPTADDR_TRG","ZX_710030_INCEPTADDR","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710030_INCEPTADDR_TRG"" before insert on zx_710030_inceptaddr for each row
begin
select zx_710030_inceptaddr_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYWMS"".""ZX_710030_INCEPTADDR_TRG"" ENABLE"
"LYWMS","ZX_710030_TRG","ZX_710030","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710030_TRG"" before insert on zx_710030 for each row
begin
select zx_710030_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYWMS"".""ZX_710030_TRG"" ENABLE"
"LYWMS","ZX_710031_TRG","ZX_710031","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710031_TRG"" before insert on zx_710031 for each row
begin
select zx_710031_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYWMS"".""ZX_710031_TRG"" ENABLE"
"LYWMS","ZX_710037_TRG","ZX_710037","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710037_TRG"" 
before insert on zx_710037  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_710037_seq.nextval into :new.zxid from dual;
end;


ALTER TRIGGER ""LYWMS"".""ZX_710037_TRG"" ENABLE"
"LYWMS","ZX_710091_ID","ZX_710091","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710091_ID"" 
before insert on zx_710091  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
	select zx_710091_ID_SEQ.nextval into :new.zxid from dual;
end;

ALTER TRIGGER ""LYWMS"".""ZX_710091_ID"" ENABLE"
"LYWMS","ZX_710092_ID","ZX_710092","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_710092_ID"" 
before insert on zx_710092  --before:执行DML等操作之前触发
for each row  --行级触发器
begin
  select zx_710092_ID_SEQ.nextval into :new.zxid from dual;
end;

ALTER TRIGGER ""LYWMS"".""ZX_710092_ID"" ENABLE"
"LYWMS","ZX_RK_WMS_TRADE_DTL_TRI","WMS_TRADE_DTL","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_RK_WMS_TRADE_DTL_TRI"" 
after UPDATE
ON WMS_Trade_Dtl
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW

    
declare
--v_prtclass varchar2(100);
p_executype number(12);
p_userstatus number(12);
p_packsize number(12);
p_wholeqty number(12);
p_exist number(2);
BEGIN
---算出上下架分开的
select t1.executetype
into p_executype
from wms_trade_order t1
where  t1.tradeid = :new.tradeid;
p_userstatus:=:new.USESTATUS;
select count(*) into p_exist from zx_WMS_Trade_Dtl where tradedtlid = :new.tradedtlid;
   --在生成整件波次出库的出入库明细时，生成10件以下的标签数

 if nvl(p_executype,0) = 2 and nvl(p_userstatus,0) = 2 and nvl(p_exist,0) = 0 then ---补货、上下架分开执行
       -----取包装大小。
       select packsize
       into p_packsize
       from tpl_pub_goods_packs
       where goodspackid = :new.goodspackid ;
       -----取出件数。
       if nvl(p_packsize,0) <> 0 then
          p_wholeqty := ceil(:new.qty/p_packsize);
       else
          p_wholeqty := 1;
       end if;

       if (nvl(p_wholeqty,0)>=1 and nvl(p_wholeqty,0)<10)then    --超过10件只打印一张，低于10件的才打印对应件数的标签数量
         for i in 1..p_wholeqty loop
         insert into zx_WMS_Trade_Dtl(ZXTRADEID,TRADEDTLID,printflag,seqno,wholeqty)
                values(zx_WMS_Trade_Dtl_SEQ.NEXTVAL,:new.tradedtlid,0,i,p_wholeqty);
 /*                  commit;*/
         end loop;
       else
                insert into zx_WMS_Trade_Dtl(ZXTRADEID,TRADEDTLID,printflag,seqno,wholeqty)
                values(zx_WMS_Trade_Dtl_SEQ.NEXTVAL,:new.tradedtlid,0,p_wholeqty,p_wholeqty);
                /* commit;*/
       end if;

 end if;


 end ;


ALTER TRIGGER ""LYWMS"".""ZX_RK_WMS_TRADE_DTL_TRI"" ENABLE"
"LYWMS","ZX_TRG_WMS_CANCEL_IN","WMS_CANCEL_JOB_LST","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_TRG_WMS_CANCEL_IN"" 
  after insert  on WMS_CANCEL_JOB_LST
for each row

begin
  if :new.goodsownerid=520 and :new.operationtype in (1,7) and :new.jobcancelstatus=2  then
      p_trg_wms_cancel_in(:new.jobid,:new.jobdtlid);
  end if;

end zx_trg_wms_cancel_in;


ALTER TRIGGER ""LYWMS"".""ZX_TRG_WMS_CANCEL_IN"" ENABLE"
"LYWMS","ZX_TRG_WMS_CANCEL_JOB_LST_TEST","WMS_CANCEL_JOB_LST_TEST","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_TRG_WMS_CANCEL_JOB_LST_TEST"" 
  after insert  on WMS_CANCEL_JOB_LST_TEST
for each row

begin
  if :new.goodsownerid=520 and :new.operationtype in (1,7) and :new.jobcancelstatus=2  then
      --update   T_TEST t set   t.c2=:new.goodsownerid where  t.c1=1;
    p_trg_wms_cancel_in(:new.jobid,:new.jobdtlid);
  end if;

end zx_trg_WMS_CANCEL_JOB_LST_TEST;


ALTER TRIGGER ""LYWMS"".""ZX_TRG_WMS_CANCEL_JOB_LST_TEST"" ENABLE"
"LYWMS","ZX_WMS_IN_ORDER_DTL_MF1_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF1_TRG"" 
  before update of memoflaga on wms_in_order_dtl
  for each row 
  WHEN (new.memoflaga=1) begin
  :new.memoa:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf1_trg;


ALTER TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF1_TRG"" ENABLE"
"LYWMS","ZX_WMS_IN_ORDER_DTL_MF2_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF2_TRG"" 
  before update of memoflagb on wms_in_order_dtl
  for each row   WHEN (new.memoflagb=1) begin
  :new.memob:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf2_trg;


ALTER TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF2_TRG"" ENABLE"
"LYWMS","ZX_WMS_IN_ORDER_DTL_MF3_TRG","WMS_IN_ORDER_DTL","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF3_TRG"" 
  before update of memoflagc on wms_in_order_dtl
  for each row   WHEN (new.memoflagc=1) begin
  :new.memoc:=:old.memotemp;
  :new.memotemp:=null;
end zx_wms_in_order_dtl_mf3_trg;


ALTER TRIGGER ""LYWMS"".""ZX_WMS_IN_ORDER_DTL_MF3_TRG"" ENABLE"
"LYWMS","ZX_WMS_OUT_ORDER_TRI","WMS_OUT_ORDER","UPDATE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_WMS_OUT_ORDER_TRI"" 
after update of wavedtlid
ON wms_out_order
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
 WHEN (old.autopassflag=1) begin
  if nvl(:new.wavedtlid,0)<>0 and :new.autopassflag=1 then
  update wms_wave_dtl t
     set t.autopassflag    = :new.autopassflag,
         t.togoodsownerid  = :new.togoodsownerid,
         t.to_expcompanyid = :new.to_expcompanyid,
         t.to_addressid    = :new.to_addressid
   where t.wavedtlid = :new.wavedtlid;
  end if;
end;

ALTER TRIGGER ""LYWMS"".""ZX_WMS_OUT_ORDER_TRI"" ENABLE"
"LYWMS","ZX_WMS_ST_IO_DOC_TRI","WMS_ST_IO_DOC","INSERT","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""LYWMS"".""ZX_WMS_ST_IO_DOC_TRI"" 
after INSERT
ON wms_st_io_doc
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
/*************************************************************/
/*  中文名称：出入库明细                                      */
/*  功能描述：在整件出库标签的打印时货位上不同的出库件数        */
/*              打印的标签数有所不同。                         */
/*  编写人：wanghuaiyu      编写时间：20130622                  */
/*  修改人：      修改时间：                                    */
/**************************************************************/
declare
  v_autoprtparam number(1);--标签打印件数上限
  v_wholeqty number(8);--整件数量
  v_prtperpackflag number(1);--每箱打印出库标签

BEGIN
  if :new.comefrom = 3 then
    --查询出拣货工作区定义中的""标签打印件数上限""
    select nvl(b.autoprtparam,0),nvl(b.prtperpackflag, 0) 
      into v_autoprtparam,v_prtperpackflag
      from wms_pickarea b
     where b.pickareaid = nvl(:new.pickareaid,0);
    v_wholeqty := :new.wholeqty;--整件数量
    if nvl(v_wholeqty,0) > 0 then
      --如果“每箱打印出库标签”没有选上，即值不等于 1，只插入一条记录
      if(v_prtperpackflag <> 1) then
         insert into zx_out_label_print(seqid, inoutid, labelseq, wholeqty, credate)
          values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, v_wholeqty, v_wholeqty, sysdate);
      --如果选择了“每箱打印出库标签”，即值等于1
      elsif(v_prtperpackflag = 1)then
        --如果 "" 标签打印件数上限 "" 为空或 0 
        if(v_autoprtparam = 0) then
          insert into zx_out_label_print(seqid, inoutid, labelseq, wholeqty, credate)
          values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, v_wholeqty, v_wholeqty, sysdate);
        --如果 "" 标签打印件数上限 "" 不为空或者0 ，且大于整件数量，插入整件数量条记录
        elsif(v_autoprtparam >= v_wholeqty) then
          for i in 1 .. v_wholeqty loop
            insert into zx_out_label_print(seqid,inoutid,labelseq,wholeqty,credate)
            values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, i, v_wholeqty,sysdate);
          end loop;
        --如果整件数量大于"" 标签打印件数上限 "" ,插入5 条记录
        elsif(nvl(v_wholeqty, 0) > v_autoprtparam) then
        	for i in 1 .. v_autoprtparam loop
            insert into zx_out_label_print(seqid,inoutid,labelseq,wholeqty,credate)
            values(zx_out_label_print_seq.NEXTVAL, :new.inoutid, i, v_wholeqty,sysdate);
          end loop;
        end if;
      end if;
    end if;
  end if;
end;


ALTER TRIGGER ""LYWMS"".""ZX_WMS_ST_IO_DOC_TRI"" ENABLE"
"MDSYS","Animation3d781_TAB$xd","Animation3d781_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""Animation3d781_TAB$xd"" after delete or update on ""MDSYS"".""Animation3d781_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','Animation3d781_TAB', :old.sys_nc_oid$, 'B8F6796A7CF2365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','Animation3d781_TAB', :old.sys_nc_oid$, 'B8F6796A7CF2365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""Animation3d781_TAB$xd"" ENABLE"
"MDSYS","CHK_SDO_DIMNAME","SDO_GEOM_METADATA_TABLE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""CHK_SDO_DIMNAME"" 
  BEFORE INSERT OR UPDATE ON MDSYS.SDO_GEOM_METADATA_TABLE
  FOR EACH ROW
DECLARE
  cnt   NUMBER;
  res   NUMBER;
BEGIN
  FOR cnt IN 1 .. :NEW.sdo_diminfo.COUNT LOOP



    SELECT REGEXP_INSTR(:NEW.sdo_diminfo(cnt).sdo_dimname, '[^[:alnum:]_]')
      INTO res FROM DUAL;
    IF (res > 0) THEN
      mderr.raise_md_error('MD', 'SDO_GEOM_METADATA_TABLE',-13249,
      'Only alphanumeric characters and ""_"" are allowed in SDO_DIMNAME');
    END IF;

  END LOOP;


  mdsys.mdprvt_gmd.invalidate_geom_metadata(:new.sdo_owner,
                                            :new.sdo_table_name,
                                            :new.sdo_column_name);
END;
ALTER TRIGGER ""MDSYS"".""CHK_SDO_DIMNAME"" ENABLE"
"MDSYS","CS_SRS_TRIGGER","CS_SRS","INSERT OR UPDATE OR DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""CS_SRS_TRIGGER"" 
INSTEAD OF
  UPDATE OR
  INSERT OR
  DELETE
ON
  MDSYS.CS_SRS
FOR EACH ROW
BEGIN
  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  if(not(:old.srid is null)) then
    delete from sdo_coord_ref_system crs where crs.srid = :old.srid;
  end if;
  if(not(:new.srid is null)) then
    if(upper(trim(:new.wktext)) like 'GEOGCS%') then
      insert into sdo_coord_ref_system (
        SRID,
        COORD_REF_SYS_NAME,
        COORD_REF_SYS_KIND,
        COORD_SYS_ID,
        DATUM_ID,
        GEOG_CRS_DATUM_ID,
        SOURCE_GEOG_SRID,
        PROJECTION_CONV_ID,
        CMPD_HORIZ_SRID,
        CMPD_VERT_SRID,
        INFORMATION_SOURCE,
        DATA_SOURCE,
        IS_LEGACY,
        LEGACY_CODE,
        LEGACY_WKTEXT,
        LEGACY_CS_BOUNDS,
        IS_VALID,
        SUPPORTS_SDO_GEOMETRY)
      values(
        :new.SRID,
        :new.CS_NAME,
        'GEOGRAPHIC2D',
        null,
        1000000123,
        1000000123,
        null,
        null,
        null,
        null,
        null,
        null,
        'TRUE',
        null,
        :new.WKTEXT,
        :new.CS_BOUNDS,
        'TRUE',
        'TRUE');
    else
      insert into sdo_coord_ref_system (
        SRID,
        COORD_REF_SYS_NAME,
        COORD_REF_SYS_KIND,
        COORD_SYS_ID,
        DATUM_ID,
        GEOG_CRS_DATUM_ID,
        SOURCE_GEOG_SRID,
        PROJECTION_CONV_ID,
        CMPD_HORIZ_SRID,
        CMPD_VERT_SRID,
        INFORMATION_SOURCE,
        DATA_SOURCE,
        IS_LEGACY,
        LEGACY_CODE,
        LEGACY_WKTEXT,
        LEGACY_CS_BOUNDS,
        IS_VALID,
        SUPPORTS_SDO_GEOMETRY)
      values(
        :new.SRID,
        :new.CS_NAME,
        'PROJECTED',
        null,
        null,
        1000000123,
        1000000123,
        null,
        null,
        null,
        null,
        null,
        'TRUE',
        null,
        :new.WKTEXT,
        :new.CS_BOUNDS,
        'TRUE',
        'TRUE');
    end if;
  end if;
END;
ALTER TRIGGER ""MDSYS"".""CS_SRS_TRIGGER"" ENABLE"
"MDSYS","DefaultStyle764_TAB$xd","DefaultStyle764_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""DefaultStyle764_TAB$xd"" after delete or update on ""MDSYS"".""DefaultStyle764_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','DefaultStyle764_TAB', :old.sys_nc_oid$, 'B8F6796A7CF8365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','DefaultStyle764_TAB', :old.sys_nc_oid$, 'B8F6796A7CF8365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""DefaultStyle764_TAB$xd"" ENABLE"
"MDSYS","ForeignKey752_TAB$xd","ForeignKey752_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""ForeignKey752_TAB$xd"" after delete or update on ""MDSYS"".""ForeignKey752_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','ForeignKey752_TAB', :old.sys_nc_oid$, 'B8F6796A7CF9365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','ForeignKey752_TAB', :old.sys_nc_oid$, 'B8F6796A7CF9365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""ForeignKey752_TAB$xd"" ENABLE"
"MDSYS","GridFile742_TAB$xd","GridFile742_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""GridFile742_TAB$xd"" after delete or update on ""MDSYS"".""GridFile742_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','GridFile742_TAB', :old.sys_nc_oid$, 'B8F6796A7B90365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','GridFile742_TAB', :old.sys_nc_oid$, 'B8F6796A7B90365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""GridFile742_TAB$xd"" ENABLE"
"MDSYS","LightSource3d780_TAB$xd","LightSource3d780_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""LightSource3d780_TAB$xd"" after delete or update on ""MDSYS"".""LightSource3d780_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','LightSource3d780_TAB', :old.sys_nc_oid$, 'B8F6796A7CF4365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','LightSource3d780_TAB', :old.sys_nc_oid$, 'B8F6796A7CF4365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""LightSource3d780_TAB$xd"" ENABLE"
"MDSYS","OGIS_CRS_DELETE_TRIGGER","OGIS_SPATIAL_REFERENCE_SYSTEMS","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""OGIS_CRS_DELETE_TRIGGER"" 
BEFORE
  DELETE
ON
  MDSYS.ogis_spatial_reference_systems
FOR EACH ROW
BEGIN
  DELETE FROM MDSYS.sdo_coord_ref_system WHERE SRID = :old.srid;
END;
ALTER TRIGGER ""MDSYS"".""OGIS_CRS_DELETE_TRIGGER"" ENABLE"
"MDSYS","OGIS_CRS_INSERT_TRIGGER","OGIS_SPATIAL_REFERENCE_SYSTEMS","INSERT","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""OGIS_CRS_INSERT_TRIGGER"" 
BEFORE
  INSERT
ON
  MDSYS.ogis_spatial_reference_systems
FOR EACH ROW
BEGIN
  IF(UPPER(TRIM(:new.srtext)) like 'GEOGCS%') THEN
    insert into MDSYS.sdo_coord_ref_system (
      SRID,
      COORD_REF_SYS_NAME,
      COORD_REF_SYS_KIND,
      COORD_SYS_ID,
      DATUM_ID,
      GEOG_CRS_DATUM_ID,
      SOURCE_GEOG_SRID,
      PROJECTION_CONV_ID,
      CMPD_HORIZ_SRID,
      CMPD_VERT_SRID,
      INFORMATION_SOURCE,
      DATA_SOURCE,
      IS_LEGACY,
      LEGACY_CODE,
      LEGACY_WKTEXT,
      LEGACY_CS_BOUNDS,
      IS_VALID,
      SUPPORTS_SDO_GEOMETRY)
    VALUES (
      :new.SRID,
      'OGIS ' || :new.SRID,
      'GEOGRAPHIC2D',
      NULL,
      1000000123,
      1000000123,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      'TRUE',
      NULL,
      :new.SRTEXT,
      NULL,
      'TRUE',
      'TRUE');
  ELSE
    insert into MDSYS.sdo_coord_ref_system (
      SRID,
      COORD_REF_SYS_NAME,
      COORD_REF_SYS_KIND,
      COORD_SYS_ID,
      DATUM_ID,
      GEOG_CRS_DATUM_ID,
      SOURCE_GEOG_SRID,
      PROJECTION_CONV_ID,
      CMPD_HORIZ_SRID,
      CMPD_VERT_SRID,
      INFORMATION_SOURCE,
      DATA_SOURCE,
      IS_LEGACY,
      LEGACY_CODE,
      LEGACY_WKTEXT,
      LEGACY_CS_BOUNDS,
      IS_VALID,
      SUPPORTS_SDO_GEOMETRY)
    VALUES (
      :new.SRID,
      'OGIS ' || :new.SRID,
      'PROJECTED',
      NULL,
      NULL,
      1000000123,
      1000000123,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      'TRUE',
      NULL,
      :new.SRTEXT,
      NULL,
      'TRUE',
      'TRUE');
  END IF;
END;
ALTER TRIGGER ""MDSYS"".""OGIS_CRS_INSERT_TRIGGER"" ENABLE"
"MDSYS","SDO_ANNOT_TRIG_INS1","USER_ANNOTATION_TEXT_METADATA","INSERT OR UPDATE OR DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_ANNOT_TRIG_INS1"" 
INSTEAD OF INSERT OR DELETE OR UPDATE ON USER_ANNOTATION_TEXT_METADATA
REFERENCING NEW AS n OLD as o
FOR EACH ROW
declare
 tname varchar2(32);
begin

  IF INSERTING THEN
 EXECUTE IMMEDIATE
  'SELECT user FROM dual' into tname;
      INSERT INTO SDO_ANNOTATION_TEXT_METADATA values(null,tname,
            UPPER(:n.table_name), UPPER(:n.column_name), :n.MAP_BASE_SCALE,
                 :n.TEXT_EXPRESSION,
             :n.TEXT_ATTRIBUTES);
  ELSIF UPDATING THEN
 EXECUTE IMMEDIATE
  'SELECT user FROM dual' into tname;
  UPDATE SDO_ANNOTATION_TEXT_METADATA SET(F_TABLE_SCHEMA,
             F_TABLE_NAME,F_TEXT_COLUMN, MAP_BASE_SCALE, TEXT_DEFAULT_EXPRESSION,
                    TEXT_DEFAULT_ATTRIBUTES) =
   (SELECT tname, :n.table_name, :n.column_name, :n.MAP_BASE_SCALE,
                    :n.TEXT_EXPRESSION,
           :n.TEXT_ATTRIBUTES FROM DUAL)
  WHERE F_TABLE_SCHEMA =  tname AND
     F_TABLE_NAME = :o.table_name AND F_TEXT_COLUMN = :o.column_name;
  ELSE
 EXECUTE IMMEDIATE
  'SELECT user FROM dual' into tname;
   DELETE FROM SDO_ANNOTATION_TEXT_METADATA
    WHERE  F_TABLE_SCHEMA =  tname AND
     F_TABLE_NAME = :o.table_name AND F_TEXT_COLUMN = :o.column_name;
  END IF;
end;
ALTER TRIGGER ""MDSYS"".""SDO_ANNOT_TRIG_INS1"" ENABLE"
"MDSYS","SDO_COORD_OPS_TRIGGER","SDO_COORD_OPS","INSERT OR UPDATE OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_OPS_TRIGGER"" 
BEFORE
  INSERT OR
  UPDATE OR
  DELETE
ON
  MDSYS.SDO_COORD_OPS
FOR EACH ROW
BEGIN
  MDSYS.sdo_cs.sdo_cs_context_invalidate;
END;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_OPS_TRIGGER"" ENABLE"
"MDSYS","SDO_COORD_OP_METHODS_TRIGGER","SDO_COORD_OP_METHODS","INSERT OR UPDATE OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_OP_METHODS_TRIGGER"" 
BEFORE
  INSERT OR
  UPDATE OR
  DELETE
ON
  MDSYS.SDO_COORD_OP_METHODS
FOR EACH ROW
BEGIN
  MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, 'This cannot change the actual implementation status of a method.');
END;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_OP_METHODS_TRIGGER"" ENABLE"
"MDSYS","SDO_COORD_OP_PARAM_VAL_TRIGG2","SDO_COORD_OP_PARAM_VALS","INSERT OR UPDATE OR DELETE","AFTER STATEMENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_OP_PARAM_VAL_TRIGG2"" 
AFTER
  INSERT OR
  UPDATE or
  delete
ON
  MDSYS.SDO_coord_op_param_vals
BEGIN
  update
    sdo_cs_srs
  set
    wktext = MDSYS.sdo_cs.internal_det_srid_wkt(srid),
    wktext3d = mdsys.sdo_cs.get_3d_wkt(srid)
  where
    wktext = 'Getting updated';
end;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_OP_PARAM_VAL_TRIGG2"" ENABLE"
"MDSYS","SDO_COORD_OP_PARAM_VAL_TRIGGER","SDO_COORD_OP_PARAM_VALS","INSERT OR UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_OP_PARAM_VAL_TRIGGER"" 
AFTER
  INSERT OR
  UPDATE or
  delete
ON
  MDSYS.SDO_coord_op_param_vals
for each row
BEGIN
  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  update
    sdo_cs_srs
  set
    wktext = 'Getting updated'
  where
    srid in (
      select
        crs.srid
      from
        sdo_coord_ref_sys crs
      where
        crs.projection_conv_id = :new.coord_op_id);
end;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_OP_PARAM_VAL_TRIGGER"" ENABLE"
"MDSYS","SDO_COORD_OP_PATHS_TRIGGER","SDO_COORD_OP_PATHS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_OP_PATHS_TRIGGER"" 
BEFORE
  INSERT OR
  UPDATE
ON
  MDSYS.SDO_COORD_OP_PATHS
FOR EACH ROW
DECLARE
  c NUMBER;
  is_impl_single NUMBER;
  is_impl_concat NUMBER;
BEGIN

  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = :new.CONCAT_OPERATION_ID;
  IF(c < 1) THEN
    SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_ELEM_OPS WHERE COORD_OP_ID = :new.CONCAT_OPERATION_ID;
    IF(c < 1) THEN
      IF(:new.CONCAT_OPERATION_ID > 0) THEN
        MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.CONCAT_OPERATION_ID || ' does not exist.'));
      ELSE
        SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = -:new.CONCAT_OPERATION_ID;
        IF(c < 1) THEN
          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.CONCAT_OPERATION_ID || ' does not exist, neither does its forward version ' || -:new.CONCAT_OPERATION_ID || '.'));
        ELSE
          dbms_output.put_line('Concatenated operation ' || -:new.CONCAT_OPERATION_ID || ' is not reversible, because of its following elementary component(s):');

          <<FIND_CULPRITS>>
          DECLARE
            CURSOR CULPRITS IS
              SELECT
                -PATHS.SINGLE_OPERATION_ID ""COORD_OP_ID""
              FROM
                MDSYS.SDO_COORD_OP_PATHS PATHS
              WHERE
                PATHS.CONCAT_OPERATION_ID = -:new.CONCAT_OPERATION_ID
              MINUS
              SELECT
                COORD_OP_ID
              FROM
                MDSYS.SDO_AVAILABLE_OPS;
            CULPRIT CULPRITS%ROWTYPE;
          BEGIN
            FOR CULPRIT IN CULPRITS LOOP
              dbms_output.put_line('Elementary operation ' || (-CULPRIT.COORD_OP_ID) || ' is not reversible.');
            END LOOP;
          END FIND_CULPRITS;

          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Concatenated operation ' || -:new.CONCAT_OPERATION_ID || ' is not reversible'));
        END IF;
      END IF;
    ELSE
      MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.CONCAT_OPERATION_ID || ' is an elementary operation, not a concatenated one.'));
    END IF;
  END IF;

  SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_ELEM_OPS WHERE COORD_OP_ID = :new.SINGLE_OPERATION_ID;
  IF(c < 1) THEN
    SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = :new.SINGLE_OPERATION_ID;
    IF(c < 1) THEN
      IF(:new.SINGLE_OPERATION_ID > 0) THEN
        MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.SINGLE_OPERATION_ID || ' does not exist.'));
      ELSE
        SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_ELEM_OPS WHERE COORD_OP_ID = -:new.SINGLE_OPERATION_ID;
        IF(c < 1) THEN
          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.SINGLE_OPERATION_ID || ' does not exist, neither does its forward version ' || -:new.SINGLE_OPERATION_ID || '.'));
        ELSE
          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || -:new.SINGLE_OPERATION_ID || ' is not reversible.'));
        END IF;
      END IF;
    ELSE
      MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.SINGLE_OPERATION_ID || ' is a concatenated operation, not an elementary one.'));
    END IF;
  END IF;

  SELECT IS_IMPLEMENTED INTO is_impl_single FROM MDSYS.SDO_AVAILABLE_ELEM_OPS WHERE COORD_OP_ID = :new.SINGLE_OPERATION_ID;
  IF(is_impl_single = 0) THEN
    SELECT IS_IMPLEMENTED INTO is_impl_concat FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = :new.CONCAT_OPERATION_ID;
    IF(is_impl_concat = 1) THEN
      MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, (
        'Single operation ' || :new.SINGLE_OPERATION_ID ||
        ' is not implemented. Then concatenated operation ' || :new.CONCAT_OPERATION_ID ||
        ' cannot be, neither.'));
    END IF;
  END IF;
END;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_OP_PATHS_TRIGGER"" ENABLE"
"MDSYS","SDO_COORD_REF_SRID_UPDATE","SDO_COORD_REF_SYS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_COORD_REF_SRID_UPDATE"" 
AFTER UPDATE OR DELETE ON MDSYS.SDO_COORD_REF_SYS
FOR EACH ROW
BEGIN
  mdsys.mdprvt_srid.sdo_invalidate_srid_metadata(:old.srid,
                                                 :old.coord_ref_sys_kind);
END;
ALTER TRIGGER ""MDSYS"".""SDO_COORD_REF_SRID_UPDATE"" ENABLE"
"MDSYS","SDO_CRS_DELETE_TRIGGER","SDO_COORD_REF_SYSTEM","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_CRS_DELETE_TRIGGER"" 
INSTEAD OF
  DELETE
ON
  MDSYS.SDO_COORD_REF_SYSTEM
FOR EACH ROW
DECLARE
  already_exists  NUMBER;
BEGIN
  DELETE FROM MDSYS.SDO_CS_SRS WHERE SRID = :old.SRID;
  DELETE FROM MDSYS.SDO_COORD_REF_SYS WHERE SRID = :old.SRID;
  DELETE FROM mdsys.sdo_crs_geographic_plus_height WHERE srid = :old.srid;
END;
ALTER TRIGGER ""MDSYS"".""SDO_CRS_DELETE_TRIGGER"" ENABLE"
"MDSYS","SDO_CRS_INSERT_TRIGGER","SDO_COORD_REF_SYSTEM","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_CRS_INSERT_TRIGGER"" 
INSTEAD OF
  INSERT
ON
  MDSYS.SDO_COORD_REF_SYSTEM
FOR EACH ROW
DECLARE
  already_exists  NUMBER;
BEGIN
  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  INSERT INTO MDSYS.SDO_COORD_REF_SYS (
    SRID,
    COORD_REF_SYS_NAME,
    COORD_REF_SYS_KIND,
    COORD_SYS_ID,
    DATUM_ID,
    GEOG_CRS_DATUM_ID,
    SOURCE_GEOG_SRID,
    PROJECTION_CONV_ID,
    CMPD_HORIZ_SRID,
    CMPD_VERT_SRID,
    INFORMATION_SOURCE,
    DATA_SOURCE,
    IS_LEGACY,
    LEGACY_CODE,
    LEGACY_WKTEXT,
    LEGACY_CS_BOUNDS,
    IS_VALID,
    SUPPORTS_SDO_GEOMETRY)
  VALUES (
    :new.SRID,
    :new.COORD_REF_SYS_NAME,
    :new.COORD_REF_SYS_KIND,
    :new.COORD_SYS_ID,
    :new.DATUM_ID,
    :new.GEOG_CRS_DATUM_ID,
    :new.SOURCE_GEOG_SRID,
    :new.PROJECTION_CONV_ID,
    :new.CMPD_HORIZ_SRID,
    :new.CMPD_VERT_SRID,
    :new.INFORMATION_SOURCE,
    :new.DATA_SOURCE,
    :new.IS_LEGACY,
    :new.LEGACY_CODE,
    :new.LEGACY_WKTEXT,
    :new.LEGACY_CS_BOUNDS,
    :new.IS_VALID,
    :new.SUPPORTS_SDO_GEOMETRY);

  INSERT INTO MDSYS.SDO_CS_SRS (
    CS_NAME,
    SRID,
    AUTH_SRID,
    AUTH_NAME,
    WKTEXT,
    wktext3d,
    CS_BOUNDS
    )
  VALUES (
    :new.COORD_REF_SYS_NAME,
    :new.SRID,
    :new.SRID,
    :new.INFORMATION_SOURCE,
    NVL(
      :new.LEGACY_WKTEXT,
      MDSYS.sdo_cs.internal_det_srid_wkt(:new.srid)),
    sdo_cs.get_3d_wkt(:new.srid),
    :new.LEGACY_CS_BOUNDS);

    if(:new.COORD_REF_SYS_KIND = 'GEOGRAPHIC3D') then
      insert into sdo_crs_geographic_plus_height values (:new.srid);
    elsif(:new.COORD_REF_SYS_KIND = 'COMPOUND') then
      insert into sdo_crs_geographic_plus_height (
        select :new.srid from sdo_crs_geographic2d g2d
	where g2d.srid = :new.CMPD_HORIZ_SRID);
    end if;

END;
ALTER TRIGGER ""MDSYS"".""SDO_CRS_INSERT_TRIGGER"" ENABLE"
"MDSYS","SDO_CS_SRS_SRID_UPDATE","SDO_CS_SRS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_CS_SRS_SRID_UPDATE"" 
AFTER UPDATE OR DELETE ON MDSYS.SDO_CS_SRS
FOR EACH ROW
BEGIN
  mdsys.mdprvt_srid.sdo_invalidate_srid_metadata(:old.srid);
END;
ALTER TRIGGER ""MDSYS"".""SDO_CS_SRS_SRID_UPDATE"" ENABLE"
"MDSYS","SDO_DROP_USER","","DROP ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_DROP_USER"" 
after drop on DATABASE
declare
   stmt varchar2(200);
   cnt number;
BEGIN
     if sys.dbms_standard.dictionary_obj_type = 'USER' THEN
       stmt := 'DELETE FROM SDO_GEOM_METADATA_TABLE ' ||
     ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_MAPS_TABLE ' ||
    ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_CACHED_MAPS_TABLE ' ||
    ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_STYLES_TABLE ' ||
    ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_THEMES_TABLE ' ||
   ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_LRS_METADATA_TABLE ' ||
   ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_TOPO_METADATA_TABLE ' ||
   ' WHERE SDO_OWNER = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;

       stmt := 'DELETE FROM SDO_ANNOTATION_TEXT_METADATA ' ||
   ' WHERE F_TABLE_SCHEMA = :owner ';
       EXECUTE IMMEDIATE stmt USING sys.dbms_standard.dictionary_obj_name;
    end if;
end;
ALTER TRIGGER ""MDSYS"".""SDO_DROP_USER"" ENABLE"
"MDSYS","SDO_FEATURE_USAGE_UPDATE","SDO_FEATURE_USAGE","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_FEATURE_USAGE_UPDATE"" 
AFTER UPDATE OR DELETE ON MDSYS.SDO_FEATURE_USAGE
FOR EACH ROW
BEGIN
  mdsys.mdprvt_feature.sdo_invalidate_feature(:old.feature_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_FEATURE_USAGE_UPDATE"" ENABLE"
"MDSYS","SDO_GEOM_METADATA_UPDATE","SDO_GEOM_METADATA_TABLE","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOM_METADATA_UPDATE"" 
AFTER UPDATE OR DELETE ON MDSYS.SDO_GEOM_METADATA_TABLE
FOR EACH ROW
BEGIN
  mdsys.mdprvt_gmd.invalidate_geom_metadata(:old.sdo_owner,
                                            :old.sdo_table_name,
                                            :old.sdo_column_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOM_METADATA_UPDATE"" ENABLE"
"MDSYS","SDO_GEOM_TRIG_DEL1","USER_SDO_GEOM_METADATA","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_DEL1"" 
INSTEAD OF DELETE ON user_sdo_geom_metadata
REFERENCING OLD AS n
FOR EACH ROW
declare
 tname varchar2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' into tname;

  mdsys.sdo_meta.delete_all_sdo_geom_metadata(tname,
                                              :n.table_name,
                                              :n.column_name);

END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_DEL1"" ENABLE"
"MDSYS","SDO_GEOM_TRIG_INS1","USER_SDO_GEOM_METADATA","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_INS1"" 
INSTEAD OF INSERT ON user_sdo_geom_metadata
REFERENCING NEW AS n
FOR EACH ROW
declare
 tname varchar2(32);
 stmt  varchar2(2048);
 vcount INTEGER;
 dimcount INTEGER;
 tolerance NUMBER;
 dimelement MDSYS.SDO_DIM_ELEMENT;
 idx  number;
BEGIN
  EXECUTE IMMEDIATE 'SELECT user FROM dual' into tname;

  if ( (instr(:n.table_name, ' ') > 0 ) OR
       (instr(:n.table_name, '''') > 0 ) )  then
   mderr.raise_md_error('MD', 'SDO', -13199,
               'wrong table name: ' || :n.table_name);
   end if;

  if ( (instr(:n.column_name, ' ') > 0 ) OR
       (instr(:n.column_name, '''') > 0 ) ) then
   mderr.raise_md_error('MD', 'SDO', -13199,
               'wrong column name: ' || :n.column_name);
   end if;

  stmt :=  'SELECT count(*) FROM SDO_GEOM_METADATA_TABLE ' ||
  'WHERE sdo_owner = :tname  AND sdo_table_name = :table_name  '||
  '  AND  sdo_column_name = :column_name  ';

EXECUTE IMMEDIATE stmt INTO vcount
   USING tname, upper(:n.table_name), upper(:n.column_name);


  IF vcount = 0 THEN
    dimcount :=  :n.diminfo.count;
    FOR idx in 1 .. dimcount LOOP
      dimelement := :n.diminfo(idx);
      tolerance := dimelement.SDO_TOLERANCE;
      if ( (tolerance is NULL) OR (tolerance <= 0) ) then
          mderr.raise_md_error('MD', 'SDO', -13224,
                :n.table_name||'.'||:n.column_name);
      end if;
    END LOOP;

    mdsys.sdo_meta.insert_all_sdo_geom_metadata(tname,
                                                :n.table_name,
                                                :n.column_name,
                                                :n.diminfo,
                                                :n.srid);
  ELSE
   mderr.raise_md_error('MD', 'SDO', -13223,
               :n.table_name||'.'||:n.column_name);
 END IF;
END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_INS1"" ENABLE"
"MDSYS","SDO_GEOM_TRIG_UPD1","USER_SDO_GEOM_METADATA","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_UPD1"" 
INSTEAD OF UPDATE ON user_sdo_geom_metadata
REFERENCING OLD AS old NEW AS n
FOR EACH ROW
declare
 tname varchar2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' into tname;

  mdsys.sdo_meta.change_all_sdo_geom_metadata(tname,
                                              :old.table_name,
                                              :old.column_name,
                                              :n.table_name,
                                              :n.column_name,
                                              :n.diminfo,
                                              :n.srid);

END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOM_TRIG_UPD1"" ENABLE"
"MDSYS","SDO_GEOR_ADDL_TRIGGER","","DDL ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOR_ADDL_TRIGGER"" 
after ddl on database
declare
 TYPE attrs_cur IS REF CURSOR;
 m_cur       attrs_cur;
 m_event   varchar2(512);
 m_user    varchar2(512);
 m_owner   varchar2(512);
 m_user1   varchar2(512);
 m_type    varchar2(512);
 m_name    varchar2(5120);
 m_column  varchar2(5120);
 m_cnt     NUMBER;
 m_stmt    varchar2(512);
 m_ret     varchar2(3000);
 m_ret1     varchar2(512);
 m_o_stmt VARCHAR2(5120);
begin

 m_stmt:='select sys.dbms_standard.dictionary_obj_type from dual';
 execute immediate m_stmt into m_type;
 if(not (m_type='TABLE' or m_type='TRIGGER' or m_type='USER' or m_type='TABLESPACE'))
 then
   return;
 end if;

 m_stmt:='select sys.dbms_standard.sysevent from dual';
 execute immediate m_stmt into m_event;

 m_stmt:='select SYS_CONTEXT(''USERENV'',''SESSION_USER'') from dual';
 execute immediate m_stmt into m_user;

 m_stmt:='select sys.dbms_standard.login_user  from dual';
 execute immediate m_stmt into m_user1;

 m_stmt:='select sys.dbms_standard.dictionary_obj_owner from dual';
 execute immediate m_stmt into m_owner;

 m_stmt:='select sys.dbms_standard.dictionary_obj_name from dual';
 execute immediate m_stmt into m_name;

 if((instr(upper(m_name),'MDRT_')>0) and m_event='DROP')
 then
   return;
 end if;








 if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='CREATE')
 then
   m_stmt:='select sdo_geor_def.listAllGeoRasterFieldsStr(:1,:2) from dual';
   execute immediate m_stmt  into m_ret  using SYS.DBMS_ASSERT.SCHEMA_NAME(m_owner),SYS.DBMS_ASSERT.SIMPLE_SQL_NAME(m_name);
   m_ret:=trim(m_ret);
   while (length(m_ret)!=0) loop
     if (instr(m_ret,' $$__## ')!=0)
     then
       m_ret1:=trim(substr(m_ret,1,instr(m_ret,' $$__## ')-1));
       m_ret:=trim(substr(m_ret,instr(m_ret,' $$__## ')+8));
     else
       m_ret1:=trim(m_ret);
       m_ret:='';
     end if;
     m_stmt:='begin SDO_GEOR_UTL.createDMLTrigger(:1,:2); end;';
    execute immediate m_stmt using m_owner||'.'||m_name,SYS.DBMS_ASSERT.QUALIFIED_SQL_NAME(m_ret1);
   end loop;
   return;
 end if;






















  if (m_name!='MDSYS' and m_type='USER' and m_event='DROP')
  then
     m_stmt:='call sdo_geor_def.doDropUserAndTable()';
     execute immediate m_stmt;
  end if;

  if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='DROP')
  then
     m_stmt:='call sdo_geor_def.doDropUserAndTable()';
     execute immediate m_stmt;
  end if;

  if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='TRUNCATE')
  then
     m_stmt:='call sdo_geor_def.doTruncateTable()';
     execute immediate m_stmt;
  end if;

  if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='ALTER')
  then
     m_stmt:='call sdo_geor_def.doAlterRenameTable()';
     execute immediate m_stmt;
  end if;

  if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='RENAME')
  then
     m_stmt:='call sdo_geor_def.doRenameTable()';
     execute immediate m_stmt;
  end if;






 if (m_event='DROP' and m_type='TABLE')
 then
   m_stmt:='delete from sdo_geor_ddl__table$$ where id=2';
   EXECUTE IMMEDIATE m_stmt;
 end if;

 if ((m_type='USER' and m_event='DROP') or (m_type='TABLESPACE' and m_event='DROP'))
 then
   m_stmt:='delete from sdo_geor_ddl__table$$';
   EXECUTE IMMEDIATE m_stmt;
 end if;

 Exception
   when others then
     if(sqlcode=-13391)
     then
       m_stmt:=sqlerrm;
       m_stmt:=substr(m_stmt,11);
       m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391,'''||m_stmt||''')';
       execute immediate m_stmt;
     end if;
end;
ALTER TRIGGER ""MDSYS"".""SDO_GEOR_ADDL_TRIGGER"" ENABLE"
"MDSYS","SDO_GEOR_BDDL_TRIGGER","","DDL ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOR_BDDL_TRIGGER"" 
before ddl on database
declare
 TYPE attrs_cur IS REF CURSOR;
 m_cur       attrs_cur;
 m_event varchar2(512);
 m_user  varchar2(512);
 m_owner varchar2(512);
 m_user1 varchar2(512);
 m_type  varchar2(512);
 m_stmt  varchar2(512);
 m_name  varchar2(5120);
 m_column varchar2(5120);
 m_cnt   NUMBER;
 m_stmt1 varchar2(512);
 m_var   varchar2(512);
 m_o_stmt VARCHAR2(5120);
PRAGMA AUTONOMOUS_TRANSACTION;
begin

 m_stmt:='select sys.dbms_standard.dictionary_obj_type from dual';
 execute immediate m_stmt into m_type;
 if(not (m_type='TABLE' or m_type='TRIGGER' or m_type='USER' or m_type='TABLESPACE'))
 then
   return;
 end if;

 m_stmt:='select sys.dbms_standard.sysevent from dual';
 execute immediate m_stmt into m_event;

 m_stmt:='select SYS_CONTEXT(''USERENV'',''SESSION_USER'') from dual';
 execute immediate m_stmt into m_user;

 m_stmt:='select SYS_CONTEXT(''USERENV'',''CURRENT_USER'') from dual';
 execute immediate m_stmt into m_user1;

 m_stmt:='select sys.dbms_standard.dictionary_obj_owner from dual';
 execute immediate m_stmt into m_owner;

 m_stmt:='select sys.dbms_standard.dictionary_obj_name from dual';
 execute immediate m_stmt into m_name;

 m_stmt:='select sdo_geor_def.getSqlText from dual';
 execute immediate m_stmt into m_o_stmt;







  if (m_owner!='MDSYS' and m_owner!='SYS' and m_type='TABLE' and m_event='ALTER')
  then
    m_stmt:='select column_name from dba_tab_columns where owner=:1 and table_name=:2';
    open m_cur for m_stmt using m_owner,m_name;
    loop
      fetch m_cur into m_column;
      exit when m_cur%NOTFOUND;
      m_stmt:='select sdo_geor_def.isDropColumn(:1) from dual';
      execute immediate m_stmt into m_stmt1 using SYS.DBMS_ASSERT.SIMPLE_SQL_NAME(m_column);
      if (trim(m_stmt1)='TRUE')
      then
        m_stmt:='begin sdo_geor_def.doAlterDropColumn(:1,:2,:3); end;';
        execute immediate m_stmt using SYS.DBMS_ASSERT.SCHEMA_NAME(m_owner),SYS.DBMS_ASSERT.SIMPLE_SQL_NAME(m_name),SYS.DBMS_ASSERT.SIMPLE_SQL_NAME(m_column);
      end if;
    end loop;
  end if;







 if ((m_event='DROP' and m_type='USER') or (m_event='DROP' and m_type='TABLESPACE'))
 then
   m_stmt:='insert into sdo_geor_ddl__table$$ values (1)';
   EXECUTE IMMEDIATE m_stmt;
   commit;
 end if;

 if (m_event='DROP' and m_type='TABLE')
 then
   m_stmt:='select count(*) from sdo_geor_sysdata_table where sdo_owner=:1 and RDT_TABLE_NAME=:2';
   EXECUTE IMMEDIATE m_stmt into m_cnt using m_owner,m_name;
   if(m_cnt!=0)
   then
     m_stmt:='select count(*) from sdo_geor_ddl__table$$';
     EXECUTE IMMEDIATE m_stmt into m_cnt;
     if((m_cnt=0)and (m_user!='SYS' and m_user!='SYSTEM' and m_user!='MDSYS'and m_owner!='MDSYS' and m_owner!='SYS'))
     then
        m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391, ''The referenced raster data table(RDT) cannot be dropped.'')';
        execute immediate m_stmt;
     end if;
   end if;

   m_stmt:='insert into sdo_geor_ddl__table$$ values (2)';
   EXECUTE IMMEDIATE m_stmt;
   commit;
 end if;

 if(m_user='SYS' or m_user='SYSTEM' or m_user='MDSYS'
   or m_owner='MDSYS' or m_owner='SYS')
 then
   return;
 end if;


 if (m_event='RENAME' and m_type='TABLE')
 then

   m_stmt:='select count(*) from sdo_geor_sysdata_table where sdo_owner=:1 and RDT_TABLE_NAME=:2';
   EXECUTE IMMEDIATE m_stmt into m_cnt using m_owner,m_name;
   if(m_cnt!=0)
   then
     m_stmt:='select count(*) from sdo_geor_ddl__table$$';
     EXECUTE IMMEDIATE m_stmt into m_cnt;
     if(m_cnt=0)
     then
        m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391, ''The referenced raster data table(RDT) cannot be renamed directly.'')';
        execute immediate m_stmt;
     end if;
   end if;

 end if;

 if (m_type='TRIGGER' and m_event='DROP')
 then
   m_stmt:='select REGEXP_SUBSTR(:1,''GRDMLTR_.+'',1,1,''i'') from dual';
   EXECUTE IMMEDIATE m_stmt into m_var using m_name;
   if(m_var is null)
   then
     return;
   end if;
   m_stmt:='select count(*) from sdo_geor_ddl__table$$';
   EXECUTE IMMEDIATE m_stmt into m_cnt;
   if(m_cnt=0)
   then
     m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391, ''GeoRaster DML triggers cannot be dropped.'')';
     execute immediate m_stmt;
   end if;
 end if;

 if (m_type='TRIGGER' and m_event='ALTER')
 then
   m_o_stmt:=upper(trim(m_o_stmt));
   if(instr(m_o_stmt,' COMPILE ')>0 or instr(m_o_stmt,' ENABLE ')>0
     or substr(m_o_stmt,length(m_o_stmt)-8,8)=' COMPILE' or substr(m_o_stmt,length(m_o_stmt)-7,7)=' ENABLE' )
   then
     return;
   end if;
   m_stmt:='select REGEXP_SUBSTR(:1,''GRDMLTR_.+'',1,1,''i'') from dual';
   EXECUTE IMMEDIATE m_stmt into m_var using m_name;
   if(m_var is null)
   then
     return;
   end if;
   m_stmt:='select count(*) from sdo_geor_ddl__table$$';
   EXECUTE IMMEDIATE m_stmt into m_cnt;
   if(m_cnt=0)
   then
     m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391, ''GeoRaster DML triggers cannot be altered.'')';
     execute immediate m_stmt;
   end if;
 end if;

 if (m_type='TRIGGER' and m_event='CREATE')
 then
   m_stmt:='select REGEXP_SUBSTR(:1,''GRDMLTR_.+'',1,1,''i'') from dual';
   EXECUTE IMMEDIATE m_stmt into m_var using m_name;
   if(m_var is null)
   then
     return;
   end if;
   m_stmt:='select count(*) from sdo_geor_ddl__table$$';
   EXECUTE IMMEDIATE m_stmt into m_cnt;
   if(m_cnt=0)
   then
     m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391, ''GeoRaster reserved names cannot be used to create regular triggers.'')';
     execute immediate m_stmt;
   end if;
 end if;

 Exception
   when others then
     if(sqlcode=-13391)
     then
       m_stmt:=sqlerrm;
       m_stmt:=substr(m_stmt,11);
       m_stmt:='call mderr.raise_md_error(''MD'', ''SDO'', -13391,'''||m_stmt||''')';
       execute immediate m_stmt;
     end if;
end;
ALTER TRIGGER ""MDSYS"".""SDO_GEOR_BDDL_TRIGGER"" ENABLE"
"MDSYS","SDO_GEOR_TRIG_DEL1","USER_SDO_GEOR_SYSDATA","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_DEL1"" 
INSTEAD OF DELETE ON user_sdo_geor_sysdata
FOR EACH ROW
DECLARE
  owner   VARCHAR2(32);
  valid   VARCHAR2(32);
BEGIN
  owner:=user;
  valid:=SDO_GEOR_DEF.isValidEntry(upper(owner),upper(:old.table_name),upper(:old.column_name),upper(:old.rdt_table_name),:old.raster_id);
  if(valid='TRUE')
  then
     mderr.raise_md_error('MD', 'SDO', -13391, 'A valid entry cannot be deleted directly.');
  end if;
  SDO_GEOR_DEF.deleteMetaEntry(user, :old.rdt_table_name, :old.raster_id);
END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_DEL1"" ENABLE"
"MDSYS","SDO_GEOR_TRIG_INS1","USER_SDO_GEOR_SYSDATA","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_INS1"" 
INSTEAD OF INSERT ON user_sdo_geor_sysdata
FOR EACH ROW
DECLARE
  owner   VARCHAR2(32);
  valid   VARCHAR2(32);
BEGIN
  owner:=user;
  valid:=SDO_GEOR_DEF.isValidEntry(upper(owner),upper(:new.table_name),upper(:new.column_name),upper(:new.rdt_table_name),:new.raster_id);

  if(valid='FALSE')
  then
     mderr.raise_md_error('MD', 'SDO', -13391, 'The inserted entry is not valid.');
  end if;
  SDO_GEOR_INT.insertUserSysEntry(user, :new.table_name, :new.column_name,
      :new.metadata_column_name, :new.rdt_table_name, :new.raster_id,
      :new.other_table_names);
END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_INS1"" ENABLE"
"MDSYS","SDO_GEOR_TRIG_UPD1","USER_SDO_GEOR_SYSDATA","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_UPD1"" 
INSTEAD OF UPDATE ON user_sdo_geor_sysdata
FOR EACH ROW
DECLARE
 stmt  varchar2(2048);
 cnt   NUMBER;
 owner VARCHAR2(32);
 rdt   VARCHAR2(32);
 valid   VARCHAR2(32);
BEGIN
  owner:=user;
  valid:=SDO_GEOR_DEF.isValidEntry(upper(owner),upper(:old.table_name),upper(:old.column_name),upper(:old.rdt_table_name),:old.raster_id);
  if(valid='TRUE')
  then
     mderr.raise_md_error('MD', 'SDO', -13391, 'A valid entry cannot be updated directly.');
  end if;
  valid:=SDO_GEOR_DEF.isValidEntry(upper(owner),upper(:new.table_name),upper(:new.column_name),upper(:new.rdt_table_name),:new.raster_id);
  if(valid='FALSE')
  then
     mderr.raise_md_error('MD', 'SDO', -13391, 'The updated entry is not valid.');
  end if;


  SDO_GEOR_DEF.deleteMetaEntry(user, :old.rdt_table_name, :old.raster_id);


  SDO_GEOR_INT.insertUserSysEntry(user, :new.table_name, :new.column_name,
      :new.metadata_column_name, :new.rdt_table_name, :new.raster_id,
      :new.other_table_names);
END;
ALTER TRIGGER ""MDSYS"".""SDO_GEOR_TRIG_UPD1"" ENABLE"
"MDSYS","SDO_INDEX_METADATA_UPDATE","SDO_INDEX_METADATA_TABLE","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_INDEX_METADATA_UPDATE"" 
AFTER UPDATE OR DELETE ON MDSYS.SDO_INDEX_METADATA_TABLE
FOR EACH ROW
BEGIN


  mdsys.mdprvt_idx.invalidate_cache(:old.sdo_index_owner,
                                    :old.sdo_index_name,
                                    :old.sdo_index_partition,
                                    :old.sdo_index_table);
END;
ALTER TRIGGER ""MDSYS"".""SDO_INDEX_METADATA_UPDATE"" ENABLE"
"MDSYS","SDO_LRS_TRIG_DEL","USER_SDO_LRS_METADATA","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_LRS_TRIG_DEL"" 
INSTEAD OF DELETE ON user_sdo_lrs_metadata
REFERENCING OLD AS n
FOR EACH ROW
declare
 user_name 	varchar2(32);
 stmt  		varchar2(2048);
 vcount 	INTEGER;
BEGIN

  EXECUTE IMMEDIATE
  'SELECT user FROM dual' into user_name;

    DELETE FROM  sdo_lrs_metadata_table
    WHERE SDO_OWNER   = user_name
      AND SDO_TABLE_NAME  = UPPER(:n.table_name)
      AND SDO_COLUMN_NAME = UPPER(:n.column_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_LRS_TRIG_DEL"" ENABLE"
"MDSYS","SDO_LRS_TRIG_INS","USER_SDO_LRS_METADATA","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_LRS_TRIG_INS"" 
INSTEAD OF INSERT ON user_sdo_lrs_metadata
REFERENCING NEW AS n
FOR EACH ROW
declare
 user_name 	varchar2(32);
 stmt  		varchar2(2048);
 vcount 	INTEGER;
BEGIN

  EXECUTE IMMEDIATE
  'SELECT user FROM dual' into user_name;

  if ( (instr(:n.table_name, ' ') > 0) OR
       (instr(:n.table_name, '''') > 0)  ) then
   mderr.raise_md_error('MD', 'SDO', -13223,
               :n.table_name||'.'||:n.column_name);
   end if;

  if ( (instr(:n.column_name, ' ') > 0) OR
   (instr(:n.column_name, '''') > 0)  ) then
   mderr.raise_md_error('MD', 'SDO', -13223,
               :n.table_name||'.'||:n.column_name);
   end if;

/*
  stmt :=  'SELECT count(*) FROM SDO_LRS_METADATA_TABLE ' ||
  ' WHERE sdo_owner = '''   || UPPER(user_name) || '''  ' ||
  '  AND  sdo_table_name = '''  || UPPER(replace(:n.table_name,'''',''))
   || ''' ' ||
 ' AND  sdo_column_name = ''' || UPPER(replace(:n.column_name,'''',''))|| ''' ';
  */

  stmt :=  'SELECT count(*) FROM SDO_LRS_METADATA_TABLE ' ||
  ' WHERE sdo_owner = :owner  AND  sdo_table_name =  :tab ' ||
  ' AND  sdo_column_name = :col ';

 EXECUTE IMMEDIATE stmt INTO vcount
    USING  UPPER(user_name), UPPER(:n.table_name), UPPER(:n.column_name) ;

  IF vcount = 0 THEN
    INSERT INTO sdo_lrs_metadata_table values
             (UPPER(user_name), UPPER(:n.table_name), UPPER(:n.column_name), :n.dim_pos, UPPER(:n.dim_unit));
  ELSE
   mderr.raise_md_error('MD', 'SDO', -13223,
           user_name||'.'||:n.table_name);
 END IF;
END;
ALTER TRIGGER ""MDSYS"".""SDO_LRS_TRIG_INS"" ENABLE"
"MDSYS","SDO_LRS_TRIG_UPD","USER_SDO_LRS_METADATA","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_LRS_TRIG_UPD"" 
INSTEAD OF UPDATE ON user_sdo_lrs_metadata
REFERENCING OLD AS old NEW AS n
FOR EACH ROW
declare
 user_name 	varchar2(32);
 stmt  		varchar2(2048);
 vcount 	INTEGER;
BEGIN

  EXECUTE IMMEDIATE
  'SELECT user FROM dual' into user_name;

    UPDATE sdo_lrs_metadata_table
    SET (SDO_TABLE_NAME, SDO_COLUMN_NAME, SDO_DIM_POS, SDO_DIM_UNIT)  =
     (SELECT UPPER(:n.table_name), UPPER(:n.column_name),:n.dim_pos, UPPER(:n.dim_unit) FROM DUAL)
    WHERE SDO_OWNER   	  = UPPER(user_name)
      AND SDO_TABLE_NAME  = UPPER(:old.table_name)
      AND SDO_COLUMN_NAME = UPPER(:old.column_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_LRS_TRIG_UPD"" ENABLE"
"MDSYS","SDO_NETWORK_CONS_DEL_TRIG","USER_SDO_NETWORK_CONSTRAINTS","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_constraints
FOR EACH ROW
DECLARE
  err_msg      VARCHAR2(200);
  num          NUMBER := -1;
  stmt         VARCHAR2(200);
BEGIN

  stmt := 'select count(*) from dba_java_classes where owner = :owner '||
   ' and name = :name';
  execute immediate stmt into num using user, :old.class_name;

  if (num=1) then
    err_msg := 'Java class schema object: '||:old.class_name||' exists. Please '||
      'drop it first.';
    mdsys.mderr.raise_md_error('MD', 'SDO', '13385', err_msg);
  else
    stmt := 'delete from sdo_network_constraints where sdo_owner = :owner '||
      ' and class_name = :name';
    execute immediate stmt using user, :old.class_name;
  end if;

EXCEPTION
  when others then raise;
END sdo_network_cons_del_trig;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_CONS_INS_TRIG","USER_SDO_NETWORK_CONSTRAINTS","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_constraints
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
  err_msg         VARCHAR2(200);
  num             NUMBER := -1;
  stmt            VARCHAR2(200);
BEGIN

  stmt := 'select count(*) from dba_java_classes where owner = :owner '||
   ' and name = :name';
  execute immediate stmt into num using user, :n.class_name;

  if (num<>1) then
    err_msg := 'Could not find Java class schema object: ' || :n.class_name ||
        '. Did not load Java class properly.';
    mdsys.mderr.raise_md_error('MD', 'SDO','13385', err_msg);
  else
    stmt := 'insert into sdo_network_constraints(sdo_owner, constraint, ' ||
     'description, class_name, class) values (:owner, :constraint, '||
     ':description, :class_name, :class)';
    execute immediate stmt using NLS_UPPER(user),:n.constraint,
     :n.description, :n.class_name,:n.class;
  end if;

EXCEPTION
  when others then raise;
END sdo_network_cons_ins_trig;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_CONS_UPD_TRIG","USER_SDO_NETWORK_CONSTRAINTS","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_constraints
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  UPDATE sdo_network_constraints
    SET
	    (constraint,
       description,
       class_name,
       class)
      =
	    (SELECT
	       :n.constraint,
         :n.description,
         :n.class_name,
         :n.class
       FROM DUAL)
    WHERE  NLS_UPPER(sdo_owner)  = NLS_UPPER(user_name)
      AND  constraint = :o.constraint;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_CONS_UPD_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_DROP_USER","","DROP ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_DROP_USER"" 
AFTER DROP ON DATABASE
DECLARE
  stmt    VARCHAR2(256);
BEGIN

  IF  sys.dbms_standard.dictionary_obj_type = 'USER'  THEN
    stmt := 'DELETE FROM SDO_NETWORK_METADATA_TABLE WHERE SDO_OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);

    stmt := 'DELETE FROM SDO_NETWORK_CONSTRAINTS WHERE SDO_OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);

    stmt := 'DELETE FROM SDO_NETWORK_LOCKS_WM WHERE SDO_OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);

    stmt := 'DELETE FROM SDO_NETWORK_USER_DATA WHERE SDO_OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);

    --lrg-3417773
    stmt := 'DELETE FROM SDO_NETWORK_HISTORIES WHERE OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);

    stmt := 'DELETE FROM SDO_NETWORK_TIMESTAMPS WHERE OWNER = :name';
    EXECUTE IMMEDIATE stmt using NLS_UPPER(sys.dbms_standard.dictionary_obj_name);
  END IF;
END ;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_DROP_USER"" ENABLE"
"MDSYS","SDO_NETWORK_HIS_DEL_TRIG","USER_SDO_NETWORK_HISTORIES","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_histories
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE
    FROM  sdo_network_histories
    WHERE NLS_UPPER(OWNER) = NLS_UPPER(user_name)
      AND network = :o.network;

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_HIS_INS_TRIG","USER_SDO_NETWORK_HISTORIES","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_histories
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
 user_name         VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' INTO user_name;

  INSERT INTO sdo_network_histories(
     owner, network, node_history_table, link_history_table, node_trigger,
     link_trigger)
  VALUES(
     NLS_UPPER(user_name),:n.network,:n.node_history_table,
     :n.link_history_table,:n.node_trigger,:n.link_trigger);

EXCEPTION WHEN OTHERS THEN RAISE;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_HIS_UPD_TRIG","USER_SDO_NETWORK_HISTORIES","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_histories
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  UPDATE sdo_network_histories
   SET(network,node_history_table,link_history_table,node_trigger,link_trigger)
      =
   (SELECT
      :n.network,:n.node_history_table,:n.link_history_table,:n.node_trigger,
      :n.link_trigger
    FROM DUAL)
    WHERE  NLS_UPPER(owner)  = NLS_UPPER(user_name)
      AND  network = :o.network;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_HIS_UPD_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_JAVA_DEL_TRIG","USER_SDO_NETWORK_JAVA_OBJECTS","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_java_objects
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE
    FROM  sdo_network_constraints
    WHERE NLS_UPPER(SDO_OWNER) = NLS_UPPER(user_name)
      AND constraint = :o.name;

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_JAVA_INS_TRIG","USER_SDO_NETWORK_JAVA_OBJECTS","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_java_objects
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
 user_name         VARCHAR2(32);
 dir_name          VARCHAR2(200);
 file_name         VARCHAR2(32);
 class_file_name   VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' INTO user_name;

  INSERT INTO
    sdo_network_constraints
	  (sdo_owner,
     constraint,
     description,
     class_name,
     class,
     java_interface)
  VALUES
	  (
	   NLS_UPPER(user_name),
	   :n.name,
     :n.description,
     :n.class_name,
     :n.class,
     :n.java_interface
	  );
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_JAVA_UPD_TRIG","USER_SDO_NETWORK_JAVA_OBJECTS","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_java_objects
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  UPDATE sdo_network_constraints
    SET
	    (constraint,
       description,
       class_name,
       class,
       java_interface)
      =
	    (SELECT
	       :n.name,
         :n.description,
         :n.class_name,
         :n.class,
         :n.java_interface
       FROM DUAL)
    WHERE  NLS_UPPER(sdo_owner)  = NLS_UPPER(user_name)
      AND  constraint = :o.name;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_JAVA_UPD_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_LOCKS_DEL_TRIG","USER_SDO_NETWORK_LOCKS_WM","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_locks_wm
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE
    FROM  sdo_network_locks_wm
    WHERE NLS_UPPER(SDO_OWNER) = NLS_UPPER(user_name)
      AND lock_id = :o.lock_id;

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_LOCKS_INS_TRIG","USER_SDO_NETWORK_LOCKS_WM","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_locks_wm
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
 user_name         VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' INTO user_name;

  INSERT INTO
    sdo_network_locks_wm(sdo_owner, lock_id, network, workspace,
     original_node_filter, original_link_filter, original_path_filter,
     adjusted_node_filter, adjusted_link_filter, adjusted_path_filter)
  VALUES (NLS_UPPER(user_name), :n.lock_id, :n.network, :n.workspace,
     :n.original_node_filter,:n.original_link_filter,:n.original_path_filter,
     :n.adjusted_node_filter,:n.adjusted_link_filter,:n.adjusted_path_filter);
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_LOCKS_UPD_TRIG","USER_SDO_NETWORK_LOCKS_WM","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_locks_wm
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  UPDATE sdo_network_locks_wm
    SET  (lock_id, network, workspace,
          original_node_filter, original_link_filter, original_path_filter,
          adjusted_node_filter, adjusted_link_filter, adjusted_path_filter)
      = (SELECT :n.lock_id, :n.network, :n.workspace,
          :n.original_node_filter, :n.original_link_filter,
          :n.original_path_filter,
          :n.adjusted_node_filter, :n.adjusted_link_filter,
          :n.adjusted_path_filter
       FROM DUAL)
    WHERE  NLS_UPPER(sdo_owner)  = NLS_UPPER(user_name)
      AND  lock_id = :o.lock_id;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_LOCKS_UPD_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_TIME_DEL_TRIG","USER_SDO_NETWORK_TIMESTAMPS","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_timestamps
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE
    FROM  sdo_network_timestamps
    WHERE owner = NLS_UPPER(user_name)
      AND network = :o.network
      AND table_name = :o.table_name;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_TIME_INS_TRIG","USER_SDO_NETWORK_TIMESTAMPS","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_timestamps
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
 user_name         VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' INTO user_name;

  INSERT INTO sdo_network_timestamps(
     owner, network, table_name, last_dml_time)
  VALUES(NLS_UPPER(user_name),:n.network,:n.table_name, :n.last_dml_time);

EXCEPTION WHEN OTHERS THEN RAISE;
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_TIME_UPD_TRIG","USER_SDO_NETWORK_TIMESTAMPS","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_timestamps
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  UPDATE sdo_network_timestamps
   SET(network,table_name,last_dml_time)
      =
   (SELECT
      :n.network,:n.table_name,:n.last_dml_time
    FROM DUAL)
    WHERE  owner = NLS_UPPER(user_name)
      AND  NLS_UPPER(network) = NLS_UPPER(:o.network)
      AND  NLS_UPPER(table_name) = NLS_UPPER(:o.table_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TIME_UPD_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_TRIG_DEL","USER_SDO_NETWORK_METADATA","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_DEL"" 
INSTEAD OF DELETE ON user_sdo_network_metadata
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE FROM SDO_NETWORK_METADATA_TABLE WHERE NLS_UPPER(SDO_OWNER) = NLS_UPPER(user_name)
  AND NLS_UPPER(network) = NLS_UPPER(:o.network);

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_DEL"" ENABLE"
"MDSYS","SDO_NETWORK_TRIG_INS","USER_SDO_NETWORK_METADATA","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_INS"" 
INSTEAD OF INSERT ON USER_SDO_NETWORK_METADATA
REFERENCING NEW AS n
FOR EACH ROW
declare
 user_name varchar2(32);
 net_id number;
 no_of_partitions number := 0;
 no_of_hierarchy_levels number := 1;
 direction    VARCHAR2(12);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' into user_name;
  -- find out the network ID from network ID sequence
  EXECUTE IMMEDIATE 'SELECT sdo_ndm_network_id_seq.nextval FROM DUAL' INTO net_id;

  -- insert network metadata and network ID into SDO_NETWORK_METADATA_TABLE

  IF ( :n.no_of_partitions is NOT null ) THEN
	no_of_partitions :=  :n.no_of_partitions;
  END IF;

  IF ( :n.no_of_hierarchy_levels is NOT null ) THEN
	no_of_hierarchy_levels :=  :n.no_of_hierarchy_levels;
  END IF;

  -- change bidirected to undirected
  direction := :n.link_direction ;

  IF ( NLS_UPPER(direction) = 'BIDIRECTED' ) THEN
    direction := 'UNDIRECTED';
  END IF ;

  insert into SDO_NETWORK_METADATA_TABLE
	(
	 SDO_OWNER,
	 NETWORK,
	 NETWORK_ID,
         NETWORK_CATEGORY,
	 GEOMETRY_TYPE,
         NETWORK_TYPE,
	 NO_OF_HIERARCHY_LEVELS,
	 NO_OF_PARTITIONS,
	 LRS_TABLE_NAME,
	 LRS_GEOM_COLUMN,
         NODE_TABLE_NAME,
         NODE_GEOM_COLUMN,
         NODE_COST_COLUMN,
         NODE_PARTITION_COLUMN,
         NODE_DURATION_COLUMN,
         LINK_TABLE_NAME,
         LINK_GEOM_COLUMN,
	 LINK_DIRECTION,
	 LINK_COST_COLUMN,
         LINK_PARTITION_COLUMN,
	 LINK_DURATION_COLUMN,
	 PATH_TABLE_NAME,
	 PATH_GEOM_COLUMN,
	 PATH_LINK_TABLE_NAME,
	 SUBPATH_TABLE_NAME,
	 SUBPATH_GEOM_COLUMN,
	 PARTITION_TABLE_NAME,
	 PARTITION_BLOB_TABLE_NAME,
         COMPONENT_TABLE_NAME,
         NODE_LEVEL_TABLE_NAME,
	 TOPOLOGY,
         USER_DEFINED_DATA,
         EXTERNAL_REFERENCES
	)
 	values
	(
	 NLS_UPPER(user_name),
	 NLS_UPPER(:n.network),
	 net_id,
         NLS_UPPER(:n.network_category),
         NLS_UPPER(:n.geometry_type),
         NLS_UPPER(:n.network_type),
	 no_of_hierarchy_levels,
	 no_of_partitions,
	 NLS_UPPER(:n.lrs_table_name),
         NLS_UPPER(:n.lrs_geom_column),
         NLS_UPPER(:n.node_table_name),
         NLS_UPPER(:n.node_geom_column),
         NLS_UPPER(:n.node_cost_column),
         NLS_UPPER(:n.node_partition_column),
         NLS_UPPER(:n.node_duration_column),
         NLS_UPPER(:n.link_table_name),
         NLS_UPPER(:n.link_geom_column),
	 NLS_UPPER(direction),
	 NLS_UPPER(:n.link_cost_column),
         NLS_UPPER(:n.link_partition_column),
	 NLS_UPPER(:n.link_duration_column),
	 NLS_UPPER(:n.path_table_name),
	 NLS_UPPER(:n.path_geom_column),
	 NLS_UPPER(:n.path_link_table_name),
	 NLS_UPPER(:n.subpath_table_name),
	 NLS_UPPER(:n.subpath_geom_column),
	 NLS_UPPER(:n.partition_table_name),
	 NLS_UPPER(:n.partition_blob_table_name),
	 NLS_UPPER(:n.component_table_name),
         NLS_UPPER(:n.node_level_table_name),
	 NLS_UPPER(:n.topology),
         NLS_UPPER(:n.user_defined_data),
         NLS_UPPER(:n.external_references)
	);

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_INS"" ENABLE"
"MDSYS","SDO_NETWORK_TRIG_UPD","USER_SDO_NETWORK_METADATA","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_UPD"" 
INSTEAD OF UPDATE ON user_sdo_network_metadata
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
  direction    VARCHAR2(12);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;
  direction := :n.link_direction ;
  IF ( UPPER(direction) = 'BIDIRECTED' ) THEN
    direction := 'UNDIRECTED';
  END IF;


  UPDATE sdo_network_metadata_table
    SET (NETWORK,
         NETWORK_CATEGORY,
	 GEOMETRY_TYPE,
         NETWORK_TYPE,
	 NO_OF_HIERARCHY_LEVELS,
	 NO_OF_PARTITIONS,
	 LRS_TABLE_NAME,
	 LRS_GEOM_COLUMN,
         NODE_TABLE_NAME,
         NODE_GEOM_COLUMN,
         NODE_COST_COLUMN,
         NODE_PARTITION_COLUMN,
         NODE_DURATION_COLUMN,
         LINK_TABLE_NAME,
         LINK_GEOM_COLUMN,
	 LINK_DIRECTION,
	 LINK_COST_COLUMN,
         LINK_PARTITION_COLUMN,
	 LINK_DURATION_COLUMN,
	 PATH_TABLE_NAME,
	 PATH_GEOM_COLUMN,
	 PATH_LINK_TABLE_NAME,
	 SUBPATH_TABLE_NAME,
	 SUBPATH_GEOM_COLUMN,
	 PARTITION_TABLE_NAME,
	 PARTITION_BLOB_TABLE_NAME,
	 COMPONENT_TABLE_NAME,
         NODE_LEVEL_TABLE_NAME,
	 TOPOLOGY,
         USER_DEFINED_DATA,
         EXTERNAL_REFERENCES
        ) =
	( SELECT
	 NLS_UPPER(:n.network),
         NLS_UPPER(:n.network_category),
         NLS_UPPER(:n.geometry_type),
         NLS_UPPER(:n.network_type),
	 :n.no_of_hierarchy_levels,
	 :n.no_of_partitions,
	 NLS_UPPER(:n.lrs_table_name),
         NLS_UPPER(:n.lrs_geom_column),
         NLS_UPPER(:n.node_table_name),
         NLS_UPPER(:n.node_geom_column),
         NLS_UPPER(:n.node_cost_column),
         NLS_UPPER(:n.node_partition_column),
         NLS_UPPER(:n.node_duration_column),
         NLS_UPPER(:n.link_table_name),
         NLS_UPPER(:n.link_geom_column),
	 NLS_UPPER(direction),
	 NLS_UPPER(:n.link_cost_column),
         NLS_UPPER(:n.link_partition_column),
	 NLS_UPPER(:n.link_duration_column),
	 NLS_UPPER(:n.path_table_name),
	 NLS_UPPER(:n.path_geom_column),
	 NLS_UPPER(:n.path_link_table_name),
	 NLS_UPPER(:n.subpath_table_name),
	 NLS_UPPER(:n.subpath_geom_column),
	 NLS_UPPER(:n.partition_table_name),
	 NLS_UPPER(:n.partition_blob_table_name),
	 NLS_UPPER(:n.component_table_name),
         NLS_UPPER(:n.node_level_table_name),
	 NLS_UPPER(:n.topology),
         NLS_UPPER(:n.user_defined_data),
         NLS_UPPER(:n.external_references)
	 FROM DUAL )
  WHERE  NLS_UPPER(SDO_OWNER)  = NLS_UPPER(user_name)
     AND NLS_UPPER(NETWORK)    = NLS_UPPER(:o.network);

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_TRIG_UPD"" ENABLE"
"MDSYS","SDO_NETWORK_UD_DEL_TRIG","USER_SDO_NETWORK_USER_DATA","DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_UD_DEL_TRIG"" 
INSTEAD OF DELETE ON user_sdo_network_user_data
REFERENCING OLD AS o
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  DELETE
    FROM  sdo_network_user_data
    WHERE NLS_UPPER(SDO_OWNER) = NLS_UPPER(user_name)
      AND network    = NLS_UPPER(:o.network)
      AND table_type = NLS_UPPER(:o.table_type)
      AND data_name  = NLS_UPPER(:o.data_name);

END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_UD_DEL_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_UD_INS_TRIG","USER_SDO_NETWORK_USER_DATA","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_UD_INS_TRIG"" 
INSTEAD OF INSERT ON user_sdo_network_user_data
REFERENCING NEW AS n
FOR EACH ROW
DECLARE
 user_name         VARCHAR2(32);
 no		   number ;
 table_name	   VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT user FROM dual' INTO user_name;

  -- check if network already exists in the networkwork metadata
  EXECUTE IMMEDIATE
	'SELECT COUNT(*) FROM sdo_network_metadata_table ' ||
	'  where sdo_owner = :owner AND NLS_UPPER(network) = :net ' into no using NLS_UPPER(user_name), NLS_UPPER(:n.network);
  IF ( no = 0 ) THEN
   mderr.raise_md_error('MD', 'SDO', -13385, user_name||'.'||:n.network || ' NOT IN NETWORK METADATA!');
  END IF;


  INSERT INTO
    sdo_network_user_data
    (
     sdo_owner,
     network,
     table_type,
     data_name,
     data_type,
     data_length,
     category_id
     )
  VALUES
     (
      NLS_UPPER(user_name),
      NLS_UPPER(:n.network),
      NLS_UPPER(:n.table_type),
      NLS_UPPER(:n.data_name),
      NLS_UPPER(:n.data_type),
      :n.data_length,
      :n.category_id
     );
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_UD_INS_TRIG"" ENABLE"
"MDSYS","SDO_NETWORK_UD_UPD_TRIG","USER_SDO_NETWORK_USER_DATA","UPDATE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_NETWORK_UD_UPD_TRIG"" 
INSTEAD OF UPDATE ON user_sdo_network_user_data
REFERENCING OLD AS o NEW AS n
FOR EACH ROW
DECLARE
  user_name    VARCHAR2(256);
  no	       number ;
  table_name	   VARCHAR2(32);
BEGIN

  EXECUTE IMMEDIATE 'SELECT USER FROM DUAL' INTO user_name;

  -- check if network already exists in the networkwork metadata
  EXECUTE IMMEDIATE
	'SELECT COUNT(*) FROM sdo_network_metadata_table ' ||
	'  where sdo_owner = :owner AND NLS_UPPER(network) = :net ' into no using NLS_UPPER(user_name), NLS_UPPER(:n.network);

  IF ( no = 0 ) THEN
   mderr.raise_md_error('MD', 'SDO', -13385,
           user_name||'.'||:n.network || ' NOT IN NETWORK METADATA!');
  END IF;

  UPDATE sdo_network_user_data
    SET
      (
       network,
       table_type,
       data_name,
       data_type,
       data_length,
       category_id)
      =
      (SELECT
	 NLS_UPPER(:n.network),
         NLS_UPPER(:n.table_type),
         NLS_UPPER(:n.data_name),
         NLS_UPPER(:n.data_type),
         :n.data_length,
         :n.category_id
       FROM DUAL)
    WHERE  NLS_UPPER(sdo_owner)  = NLS_UPPER(user_name)
      AND  NLS_UPPER(network)    = NLS_UPPER(:o.network)
      AND  NLS_UPPER(table_type) = NLS_UPPER(:o.table_type)
      AND  NLS_UPPER(data_name)  = NLS_UPPER(:o.data_name);
END;
ALTER TRIGGER ""MDSYS"".""SDO_NETWORK_UD_UPD_TRIG"" ENABLE"
"MDSYS","SDO_PREFERRED_OPS_SYSTEM_TRIG","SDO_PREFERRED_OPS_SYSTEM","INSERT OR UPDATE OR DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_SYSTEM_TRIG"" 
BEFORE
  INSERT OR
  UPDATE OR
  DELETE
ON
  MDSYS.SDO_PREFERRED_OPS_SYSTEM
FOR EACH ROW
BEGIN
  MDSYS.sdo_cs.sdo_cs_context_invalidate;
END;
ALTER TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_SYSTEM_TRIG"" ENABLE"
"MDSYS","SDO_PREFERRED_OPS_SYS_TRIGGER","SDO_PREFERRED_OPS_SYSTEM","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_SYS_TRIGGER"" 
BEFORE
  INSERT OR
  UPDATE
ON
  MDSYS.SDO_PREFERRED_OPS_SYSTEM
FOR EACH ROW
DECLARE
  c NUMBER;
BEGIN

  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = :new.COORD_OP_ID;
  IF(c < 1) THEN
    IF(:new.COORD_OP_ID > 0) THEN
      MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' does not exist.'));
    ELSE
      SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = -:new.COORD_OP_ID;
      IF(c < 1) THEN
        MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' does not exist, neither does its forward version ' || -:new.COORD_OP_ID || '.'));
      ELSE
        SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = -:new.COORD_OP_ID;
        IF(c < 1) THEN
          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Elementary operation ' || -:new.COORD_OP_ID || ' is not reversible.'));
        ELSE
          dbms_output.put_line('Concatenated operation ' || -:new.COORD_OP_ID || ' is not reversible, because of its following elementary component(s):');

          <<FIND_CULPRITS>>
          DECLARE
            CURSOR CULPRITS IS
              SELECT
                -PATHS.SINGLE_OPERATION_ID ""COORD_OP_ID""
              FROM
                MDSYS.SDO_COORD_OP_PATHS PATHS
              WHERE
                PATHS.CONCAT_OPERATION_ID = -:new.COORD_OP_ID
              MINUS
              SELECT
                COORD_OP_ID
              FROM
                MDSYS.SDO_AVAILABLE_OPS;
            CULPRIT CULPRITS%ROWTYPE;
          BEGIN
            FOR CULPRIT IN CULPRITS LOOP
              dbms_output.put_line('Elementary operation ' || (-CULPRIT.COORD_OP_ID) || ' is not reversible.');
            END LOOP;
          END FIND_CULPRITS;

          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Concatenated operation ' || -:new.COORD_OP_ID || ' is not reversible.'));
        END IF;
      END IF;
    END IF;
  END IF;

  SELECT IS_IMPLEMENTED INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = :new.COORD_OP_ID;
  IF(c = 0) THEN
    MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' is not implemented.'));
  END IF;
END;
ALTER TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_SYS_TRIGGER"" ENABLE"
"MDSYS","SDO_PREFERRED_OPS_USER_TRIGGER","SDO_PREFERRED_OPS_USER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_USER_TRIGGER"" 
BEFORE
  INSERT OR
  UPDATE
ON
  MDSYS.SDO_PREFERRED_OPS_USER
FOR EACH ROW
DECLARE
  c NUMBER;
BEGIN

  MDSYS.sdo_cs.sdo_cs_context_invalidate;

  SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = :new.COORD_OP_ID;
  IF(c < 1) THEN
    IF(:new.COORD_OP_ID > 0) THEN
      MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' does not exist.'));
    ELSE
      SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = -:new.COORD_OP_ID;
      IF(c < 1) THEN
        MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' does not exist, neither does its forward version ' || -:new.COORD_OP_ID || '.'));
      ELSE
        SELECT COUNT(COORD_OP_ID) INTO c FROM MDSYS.SDO_AVAILABLE_NON_ELEM_OPS WHERE COORD_OP_ID = -:new.COORD_OP_ID;
        IF(c < 1) THEN
          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Elementary operation ' || -:new.COORD_OP_ID || ' is not reversible.'));
        ELSE
          dbms_output.put_line('Concatenated operation ' || -:new.COORD_OP_ID || ' is not reversible, because of its following elementary component(s):');

          <<FIND_CULPRITS>>
          DECLARE
            CURSOR CULPRITS IS
              SELECT
                -PATHS.SINGLE_OPERATION_ID ""COORD_OP_ID""
              FROM
                MDSYS.SDO_COORD_OP_PATHS PATHS
              WHERE
                PATHS.CONCAT_OPERATION_ID = -:new.COORD_OP_ID
              MINUS
              SELECT
                COORD_OP_ID
              FROM
                MDSYS.SDO_AVAILABLE_OPS;
            CULPRIT CULPRITS%ROWTYPE;
          BEGIN
            FOR CULPRIT IN CULPRITS LOOP
              dbms_output.put_line('Elementary operation ' || (-CULPRIT.COORD_OP_ID) || ' is not reversible.');
            END LOOP;
          END FIND_CULPRITS;

          MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Concatenated operation ' || -:new.COORD_OP_ID || ' is not reversible'));
        END IF;
      END IF;
    END IF;
  END IF;

  SELECT IS_IMPLEMENTED INTO c FROM MDSYS.SDO_AVAILABLE_OPS WHERE COORD_OP_ID = :new.COORD_OP_ID;
  IF(c = 0) THEN
    MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, ('Operation ' || :new.COORD_OP_ID || ' is not implemented.'));
  END IF;
END;
ALTER TRIGGER ""MDSYS"".""SDO_PREFERRED_OPS_USER_TRIGGER"" ENABLE"
"MDSYS","SDO_ST_SYN_CREATE","","CREATE ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_ST_SYN_CREATE"" 
  BEFORE CREATE ON DATABASE
 declare
 error boolean;
  st_syn_detected EXCEPTION;
   PRAGMA EXCEPTION_INIT(st_syn_detected, -995);
 BEGIN
   if((sys.dbms_standard.dictionary_obj_type!='SYNONYM')or(sys.dbms_standard.dictionary_obj_owner!='PUBLIC'))
   then
     return;
   end if;
   error :=
      CASE sys.dbms_standard.dictionary_obj_name
         WHEN 'ST_GEOMETRY' THEN TRUE
         WHEN 'ST_SURFACE' THEN TRUE
         WHEN 'ST_POLYGON' THEN TRUE
         WHEN 'ST_POINT' THEN TRUE
         WHEN 'ST_MULTISURFACE' THEN TRUE
         WHEN 'ST_MULTIPOINT' THEN TRUE
         WHEN 'ST_MULTILINESTRING' THEN TRUE
         WHEN 'ST_MULTICURVE' THEN TRUE
         WHEN 'ST_LINESTRING' THEN TRUE
         WHEN 'ST_GEOMCOLLECTION' THEN TRUE
         WHEN 'ST_CURVE' THEN TRUE
         WHEN 'ST_CURVEPOLYGON' THEN TRUE
         WHEN 'ST_COMPOUNDCURVE' THEN TRUE
         WHEN 'ST_CIRCULARSTRING' THEN TRUE
         WHEN 'ST_INTERSECTS' THEN TRUE
         WHEN 'ST_RELATE' THEN TRUE
         WHEN 'ST_TOUCH' THEN TRUE
         WHEN 'ST_CONTAINS' THEN TRUE
         WHEN 'ST_COVERS' THEN TRUE
         WHEN 'ST_COVEREDBY' THEN TRUE
         WHEN 'ST_INSIDE' THEN TRUE
         WHEN 'ST_OVERLAP' THEN TRUE
         WHEN 'ST_OVERLAPS' THEN TRUE
         WHEN 'ST_EQUAL' THEN TRUE
         WHEN 'ST_OVERLAPBDYDISJOINT' THEN TRUE
         WHEN 'ST_OVERLAPBDYINTERSECT' THEN TRUE
         WHEN 'ST_GEOMETRY_ARRAY' THEN TRUE
         WHEN 'ST_POINT_ARRAY' THEN TRUE
         WHEN 'ST_CURVE_ARRAY' THEN TRUE
         WHEN 'ST_SURFACE_ARRAY' THEN TRUE
         WHEN 'ST_LINESTRING_ARRAY' THEN TRUE
         WHEN 'ST_POLYGON_ARRAY' THEN TRUE
         ELSE FALSE
      END;

   if(error) then
     raise st_syn_detected;

   end if;
 END;
ALTER TRIGGER ""MDSYS"".""SDO_ST_SYN_CREATE"" ENABLE"
"MDSYS","SDO_TOPO_DROP_FTBL","","DROP ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_TOPO_DROP_FTBL"" 
  BEFORE DROP ON DATABASE
  DECLARE
    cnt        NUMBER;
    stmt       VARCHAR(500);
    topology   VARCHAR(100);
    REG_TBL    EXCEPTION;

  BEGIN
    if(sys.dbms_standard.dictionary_obj_type != 'TABLE')
    then
      return;
    end if;
    stmt := 'SELECT  topology ' ||
     '  FROM  SDO_TOPO_METADATA_TABLE a, TABLE(a.Topo_Geometry_Layers) b ' ||
            '  WHERE b.owner = :owner AND b.table_name = :tab ' ;
    EXECUTE IMMEDIATE stmt into topology
      USING sys.dbms_standard.DICTIONARY_OBJ_OWNER,sys.dbms_standard.DICTIONARY_OBJ_NAME;
    RAISE REG_TBL;

    EXCEPTION
      WHEN REG_TBL THEN
        MDSYS.MDERR.raise_md_error(
         'MD', 'SDO', -13199,
         'Need use delete_topo_geometry_layer() to deregister table '
         || sys.dbms_standard.DICTIONARY_OBJ_NAME || ' from topology ' || topology ||
         ' before drop it');
      WHEN OTHERS THEN
        RETURN;
  END;
ALTER TRIGGER ""MDSYS"".""SDO_TOPO_DROP_FTBL"" ENABLE"
"MDSYS","SDO_TOPO_TRIG_INS1","SDO_TOPO_TRANSACT_DATA$","INSERT","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_TOPO_TRIG_INS1"" 
INSTEAD OF INSERT ON SDO_TOPO_TRANSACT_DATA$
REFERENCING NEW AS n
FOR EACH ROW
declare
  user_name varchar2(32);
  topo_name varchar2(32);
  tname varchar2(100);
begin










   INSERT INTO SDO_TOPO_TRANSACT_DATA
      values(SDO_TOPO_TRANSACT_SUBSEQ.nextval, :n.topology_id, :n.topo_id,
                :n.topo_type, :n.topo_op, :n.parent_id);

end;
ALTER TRIGGER ""MDSYS"".""SDO_TOPO_TRIG_INS1"" ENABLE"
"MDSYS","SDO_UNITS_OF_MEASURE_TRIGGER","SDO_UNITS_OF_MEASURE","INSERT OR UPDATE","AFTER STATEMENT","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""SDO_UNITS_OF_MEASURE_TRIGGER"" 
AFTER
  INSERT OR
  UPDATE
ON
  MDSYS.SDO_UNITS_OF_MEASURE
DECLARE
  c NUMBER;
BEGIN
  select
    count(*)
  into
    c
  from (
    select
      name
    from
      (
        select unit_of_meas_name name, factor_b, factor_c from mdsys.sdo_units_of_measure
        union
        select short_name        name, factor_b, factor_c from mdsys.sdo_units_of_measure where not short_name is null
      )
    group by
      name
    having
      count(*) > 1
      and
      min(factor_b/factor_c) < max(factor_b/factor_c));

  if(c > 0) then
    MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, 'This unit name/short name has already been defined with another factor or base unit.');
  end if;

  ------------------------------------------

  select
    count(*)
  into
    c
  from
    mdsys.sdo_units_of_measure uom1,
    mdsys.sdo_units_of_measure uom2
  where
    uom1.target_uom_id = uom2.uom_id and
    not(lower(uom1.unit_of_meas_type) = lower(uom2.unit_of_meas_type));

  if(c > 0) then
    MDSYS.MDERR.RAISE_MD_ERROR('MD', 'SDO', -13199, 'Unit and base unit have different types.');
  end if;

END;
ALTER TRIGGER ""MDSYS"".""SDO_UNITS_OF_MEASURE_TRIGGER"" ENABLE"
"MDSYS","Scene3d783_TAB$xd","Scene3d783_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""Scene3d783_TAB$xd"" after delete or update on ""MDSYS"".""Scene3d783_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','Scene3d783_TAB', :old.sys_nc_oid$, 'B8F6796A7CED365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','Scene3d783_TAB', :old.sys_nc_oid$, 'B8F6796A7CED365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""Scene3d783_TAB$xd"" ENABLE"
"MDSYS","Style3d785_TAB$xd","Style3d785_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""Style3d785_TAB$xd"" after delete or update on ""MDSYS"".""Style3d785_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','Style3d785_TAB', :old.sys_nc_oid$, 'B8F6796A7CE7365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','Style3d785_TAB', :old.sys_nc_oid$, 'B8F6796A7CE7365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""Style3d785_TAB$xd"" ENABLE"
"MDSYS","Theme3d784_TAB$xd","Theme3d784_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""Theme3d784_TAB$xd"" after delete or update on ""MDSYS"".""Theme3d784_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','Theme3d784_TAB', :old.sys_nc_oid$, 'B8F6796A7CE9365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','Theme3d784_TAB', :old.sys_nc_oid$, 'B8F6796A7CE9365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""Theme3d784_TAB$xd"" ENABLE"
"MDSYS","ViewFrame3d782_TAB$xd","ViewFrame3d782_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""ViewFrame3d782_TAB$xd"" after delete or update on ""MDSYS"".""ViewFrame3d782_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','ViewFrame3d782_TAB', :old.sys_nc_oid$, 'B8F6796A7CF0365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','ViewFrame3d782_TAB', :old.sys_nc_oid$, 'B8F6796A7CF0365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""ViewFrame3d782_TAB$xd"" ENABLE"
"MDSYS","ViewPoint3d769_TAB$xd","ViewPoint3d769_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""ViewPoint3d769_TAB$xd"" after delete or update on ""MDSYS"".""ViewPoint3d769_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','ViewPoint3d769_TAB', :old.sys_nc_oid$, 'B8F6796A7CF7365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','ViewPoint3d769_TAB', :old.sys_nc_oid$, 'B8F6796A7CF7365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""ViewPoint3d769_TAB$xd"" ENABLE"
"MDSYS","Vis3DConfig779_TAB$xd","Vis3DConfig779_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""MDSYS"".""Vis3DConfig779_TAB$xd"" after delete or update on ""MDSYS"".""Vis3DConfig779_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('MDSYS','Vis3DConfig779_TAB', :old.sys_nc_oid$, 'B8F6796A7CF6365FE053690AF40ACF51' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('MDSYS','Vis3DConfig779_TAB', :old.sys_nc_oid$, 'B8F6796A7CF6365FE053690AF40ACF51', user ); END IF; END;
ALTER TRIGGER ""MDSYS"".""Vis3DConfig779_TAB$xd"" ENABLE"
"OGGERP","GKM_11024_TRI","BMS_ST_IO_DOC","UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OGGERP"".""GKM_11024_TRI"" 
  before update of sourceid on ""OGGERP"".""BMS_ST_IO_DOC""
  for each row
declare
  --Pragma autonomous_transaction;
  v_count1 number(2);
  v_count  number(2);

begin
  --判断出库的是过账保管帐的
  if :OLD.inoutflag = 0 and :OLD.storageid in (382, 941, 902, 708) then
    /*select count(1)
     into v_count
     from bms_st_io_doc a, bms_st_io_dtl b
    where a.inoutid = b.inoutid
      and a.credate between :OLD.credate-3/(24*60*60) and :OLD.credate
      and a.storageid = :OLD.storageid
     -- and a.comefrom = 75
      and a.sourcetable = 75;
     -- and a.entryid = 6;*/
    --判断是对象调拨或者总部调拨
    select count(1)
      into v_count1
      from gpcs_placesupply t
     where exists (select 1
              from gpcs_placesupplydtl_forop_v a
             where t.placesupplyid = a.PLACESUPPLYID
               and a.PLACESUPPLYDTLSTID = :OLD.placedtlid)
       and t.placemethod in (5, 9);
    if v_count1 > 0 then
      select count(1)
        into v_count
        from bms_mv_dtl a
       where exists (select 1
                from bms_mv_dtl c
               where a.goodsid = c.goodsid
                 and nvl(a.batchid, 0) = nvl(c.batchid, 0)
                 and nvl(a.lotid, 0) = nvl(c.lotid, 0)
                 and a.goodsqty = c.goodsqty
                 and c.movedtlid = :NEW.sourceid
                 and a.movedtlid <> c.movedtlid
                 and nvl(a.sendflag, 0) = nvl(c.sendflag, 0)
                 and a.movedtlid between c.movedtlid - 200 and
                     c.movedtlid + 200
              --and c.dtlmemo='门店收货自动生成'
              )
         and a.dtlmemo = '中心收配退自动生成';
      --判断调出门店是否已记账
      if (v_count = 0) then
        raise_application_error(-20001,
                                '验收入库异常，请重新点验收！' || v_count);
      end if;
    end if;
  end if;

end;
  /* GOLDENGATE_DDL_REPLICATION */
ALTER TRIGGER ""OGGERP"".""GKM_11024_TRI"" ENABLE"
"OLAPSYS","CWM$CLASSIFICATIONENTRYUPD","CWM$CLASSIFICATIONENTRY","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$CLASSIFICATIONENTRYUPD"" 
  before insert or update on olapsys.cwm$classificationentry for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedOn := SYSDATE;
      :new.CreatedBy := v_User_Name;
    else
      :new.LastModifiedOn := SYSDATE;
      :new.LastModifiedBy := v_User_Name;
    end if;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM$CLASSIFICATIONENTRYUPD"" ENABLE"
"OLAPSYS","CWM$CLASSIFICATIONUPD","CWM$CLASSIFICATION","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$CLASSIFICATIONUPD"" 
  before insert or update on olapsys.cwm$classification for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedOn := SYSDATE;
      :new.CreatedBy := v_User_Name;
    else
      :new.LastModifiedOn := SYSDATE;
      :new.LastModifiedBy := v_User_Name;
    end if;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM$CLASSIFICATIONUPD"" ENABLE"
"OLAPSYS","CWM$CUBEDEL","CWM$CUBE","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$CUBEDEL"" 
  before delete on olapsys.CWM$CUBE for each row
  declare
  begin
    delete from olapsys.CwM2$AWCubeLoad
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM';
    delete from olapsys.CwM2$AWCompositeSpec
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM';
    delete from olapsys.CwM2$AWCubeAgg
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM';
 end;
ALTER TRIGGER ""OLAPSYS"".""CWM$CUBEDEL"" ENABLE"
"OLAPSYS","CWM$DIMENSIONDEL","CWM$DIMENSION","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$DIMENSIONDEL"" 
  before delete on olapsys.CWM$DIMENSION for each row
  declare
  begin
     delete from olapsys.CwM2$AWDimLoad
      where Dim_IRID   = :old.irid
      and   Version_ID = 'CWM';
    delete  from olapsys.CwM2$AWCompSpecMembership
      where IRID in (select  csm.IRID
                       from  CwM2$AWCompositeSpec cs
                            ,CwM2$AWCompSpecMembership csm
                       where cs.IRID       = csm.CompSpec_IRID
                       and   cs.Version_ID = 'CWM'
                       and   csm.Dim_IRID  = :old.irid);
    delete  from olapsys.CwM2$AWCubeAggLevel
      where IRID in (select  cal.IRID
                       from  CwM2$AWCubeAgg ca
                            ,CwM2$AWCubeAggLevel cal
                       where ca.IRID       = cal.CubeAgg_IRID
                       and   ca.Version_ID = 'CWM'
                       and   cal.Dim_IRID  = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM$DIMENSIONDEL"" ENABLE"
"OLAPSYS","CWM$LEVELDEL","CWM$LEVEL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$LEVELDEL"" 
  before delete on olapsys.CwM$Level for each row
  declare
  begin
    delete  from olapsys.CwM2$AWCubeAggLevel
      where IRID in (select  cal.IRID
                       from  CwM2$AWCubeAgg ca
                            ,CwM2$AWCubeAggLevel cal
                       where ca.IRID        = cal.CubeAgg_IRID
                       and   ca.Version_ID  = 'CWM'
                       and   cal.Level_IRID = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM$LEVELDEL"" ENABLE"
"OLAPSYS","CWM$MEASUREDEL","CWM$MEASURE","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM$MEASUREDEL"" 
  before delete on olapsys.CwM$Measure for each row
  declare
  begin
    delete  from olapsys.CwM2$AWCubeLoadMeasure
      where IRID in (select  clm.IRID
                       from  CwM2$AWCubeLoad cl
                            ,CwM2$AWCubeLoadMeasure clm
                       where cl.IRID          = clm.CubeLoad_IRID
                       and   cl.Version_ID    = 'CWM'
                       and   clm.Measure_IRID = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM$MEASUREDEL"" ENABLE"
"OLAPSYS","CWM2$AWCOMPOSITESPECUPD","CWM2$AWCOMPOSITESPEC","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCOMPOSITESPECUPD"" 
  before insert or update on olapsys.CWM2$AWCompositeSpec for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCOMPOSITESPECUPD"" ENABLE"
"OLAPSYS","CWM2$AWCOMPSPECMEMBERSHIPUPD","CWM2$AWCOMPSPECMEMBERSHIP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCOMPSPECMEMBERSHIPUPD"" 
  before insert or update on olapsys.CWM2$AWCompSpecMembership for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCOMPSPECMEMBERSHIPUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBEAGGLEVELUPD","CWM2$AWCUBEAGGLEVEL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGLEVELUPD"" 
  before insert or update on olapsys.CWM2$AWCubeAggLevel for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGLEVELUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBEAGGMEASUREUPD","CWM2$AWCUBEAGGMEASURE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGMEASUREUPD"" 
  before insert or update on olapsys.CWM2$AWCubeAggMeasure for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGMEASUREUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBEAGGUPD","CWM2$AWCUBEAGG","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGUPD"" 
  before insert or update on olapsys.CWM2$AWCubeAgg for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBEAGGUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBECOMPPLANUPD","CWM2$AWCUBECOMPPLAN","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBECOMPPLANUPD"" 
  before insert or update on olapsys.CWM2$AWCubeCompPlan for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBECOMPPLANUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBELOADAGGPLANUPD","CWM2$AWCUBELOADAGGPLAN","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADAGGPLANUPD"" 
  before insert or update on olapsys.CWM2$AWCubeLoadAggPlan for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADAGGPLANUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBELOADFILTERUPD","CWM2$AWCUBELOADFILTER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADFILTERUPD"" 
  before insert or update on olapsys.CWM2$AWCubeLoadFilter for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADFILTERUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBELOADMEASUREUPD","CWM2$AWCUBELOADMEASURE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADMEASUREUPD"" 
  before insert or update on olapsys.CWM2$AWCubeLoadMeasure for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADMEASUREUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBELOADPARMVALUEUPD","CWM2$AWCUBELOADPARMVALUE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADPARMVALUEUPD"" 
  before insert or update on olapsys.CWM2$AWCubeLoadParmValue for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADPARMVALUEUPD"" ENABLE"
"OLAPSYS","CWM2$AWCUBELOADUPD","CWM2$AWCUBELOAD","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADUPD"" 
  before insert or update on olapsys.CWM2$AWCubeLoad for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWCUBELOADUPD"" ENABLE"
"OLAPSYS","CWM2$AWDIMLOADFILTERUPD","CWM2$AWDIMLOADFILTER","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADFILTERUPD"" 
  before insert or update on olapsys.CWM2$AWDimLoadFilter for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADFILTERUPD"" ENABLE"
"OLAPSYS","CWM2$AWDIMLOADPARMVALUEUPD","CWM2$AWDIMLOADPARMVALUE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADPARMVALUEUPD"" 
  before insert or update on olapsys.CWM2$AWDimLoadParmValue for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADPARMVALUEUPD"" ENABLE"
"OLAPSYS","CWM2$AWDIMLOADUPD","CWM2$AWDIMLOAD","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADUPD"" 
  before insert or update on olapsys.CWM2$AWDimLoad for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWDIMLOADUPD"" ENABLE"
"OLAPSYS","CWM2$AWVIEWCOLSUPD","CWM2$AWVIEWCOLS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWVIEWCOLSUPD"" 
  before insert or update on olapsys.CwM2$AWViewCols for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWVIEWCOLSUPD"" ENABLE"
"OLAPSYS","CWM2$AWVIEWSUPD","CWM2$AWVIEWS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AWVIEWSUPD"" 
  before insert or update on olapsys.CwM2$AWViews for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AWVIEWSUPD"" ENABLE"
"OLAPSYS","CWM2$AW_DIMENSIONMAPUPD","CWM2$AW_DIMENSIONMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AW_DIMENSIONMAPUPD"" 
  before insert or update on olapsys.CwM2$AW_DimensionMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AW_DIMENSIONMAPUPD"" ENABLE"
"OLAPSYS","CWM2$AW_MEASUREMAPUPD","CWM2$AW_MEASUREMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$AW_MEASUREMAPUPD"" 
  before insert or update on olapsys.CwM2$AW_MeasureMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$AW_MEASUREMAPUPD"" ENABLE"
"OLAPSYS","CWM2$CLASSIFICATIONVPUPD","CWM2$CLASSIFICATIONVALUEPAIR","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$CLASSIFICATIONVPUPD"" 
  before insert or update on olapsys.CwM2$ClassificationValuePair for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$CLASSIFICATIONVPUPD"" ENABLE"
"OLAPSYS","CWM2$CUBEDEL","CWM2$CUBE","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$CUBEDEL"" 
  before delete on olapsys.CwM2$Cube for each row
  declare
  begin
    delete from olapsys.CwM2$AWCubeLoad
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM2';
    delete from olapsys.CwM2$AWCompositeSpec
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM2';
    delete from olapsys.CwM2$AWCubeAgg
      where Cube_IRID  = :old.irid
      and   Version_ID = 'CWM2';
 end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$CUBEDEL"" ENABLE"
"OLAPSYS","CWM2$CUBEDIMENSIONUSEUPD","CWM2$CUBEDIMENSIONUSE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$CUBEDIMENSIONUSEUPD"" 
  before insert or update on olapsys.CwM2$CubeDimensionUse for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$CUBEDIMENSIONUSEUPD"" ENABLE"
"OLAPSYS","CWM2$CUBEUPD","CWM2$CUBE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$CUBEUPD"" 
  before insert or update on olapsys.CwM2$Cube for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$CUBEUPD"" ENABLE"
"OLAPSYS","CWM2$DIMENSIONATTRIBUTEUPD","CWM2$DIMENSIONATTRIBUTE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONATTRIBUTEUPD"" 
  before insert or update on olapsys.CwM2$DimensionAttribute for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONATTRIBUTEUPD"" ENABLE"
"OLAPSYS","CWM2$DIMENSIONDEL","CWM2$DIMENSION","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONDEL"" 
  before delete on olapsys.CwM2$Dimension for each row
  declare
  begin
    delete from olapsys.CwM2$AWDimLoad
      where Dim_IRID   = :old.irid
      and   Version_ID = 'CWM2';
    delete  from olapsys.CwM2$AWCompSpecMembership
      where IRID in (select  csm.IRID
                       from  CwM2$AWCompositeSpec cs
                            ,CwM2$AWCompSpecMembership csm
                       where cs.IRID       = csm.CompSpec_IRID
                       and   cs.Version_ID = 'CWM2'
                       and   csm.Dim_IRID  = :old.irid);
    delete  from olapsys.CwM2$AWCubeAggLevel
      where IRID in (select  cal.IRID
                       from  CwM2$AWCubeAgg ca
                            ,CwM2$AWCubeAggLevel cal
                       where ca.IRID       = cal.CubeAgg_IRID
                       and   ca.Version_ID = 'CWM2'
                       and   cal.Dim_IRID  = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONDEL"" ENABLE"
"OLAPSYS","CWM2$DIMENSIONUPD","CWM2$DIMENSION","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONUPD"" 
  before insert or update on olapsys.CwM2$Dimension for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$DIMENSIONUPD"" ENABLE"
"OLAPSYS","CWM2$DIMHIERLVLMAPUPD","CWM2$DIMHIERLVLMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$DIMHIERLVLMAPUPD"" 
  before insert or update on olapsys.CwM2$DimHierLvlMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$DIMHIERLVLMAPUPD"" ENABLE"
"OLAPSYS","CWM2$FACTDIMHIERMAPUPD","CWM2$FACTDIMHIERMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$FACTDIMHIERMAPUPD"" 
  before insert or update on olapsys.CwM2$FactDimHierMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$FACTDIMHIERMAPUPD"" ENABLE"
"OLAPSYS","CWM2$FACTDIMHIERTPLSDTLUPD","CWM2$FACTDIMHIERTPLSDTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$FACTDIMHIERTPLSDTLUPD"" 
  before insert or update on olapsys.CwM2$FactDimHierTplsDtl for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$FACTDIMHIERTPLSDTLUPD"" ENABLE"
"OLAPSYS","CWM2$FACTKEYDIMHIERLVLMAPUPD","CWM2$FACTKEYDIMHIERLVLMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$FACTKEYDIMHIERLVLMAPUPD"" 
  before insert or update on olapsys.CwM2$FactKeyDimHierLvlMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$FACTKEYDIMHIERLVLMAPUPD"" ENABLE"
"OLAPSYS","CWM2$FACTKEYDIMHIERMAPUPD","CWM2$FACTKEYDIMHIERMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$FACTKEYDIMHIERMAPUPD"" 
  before insert or update on olapsys.CwM2$FactKeyDimHierMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$FACTKEYDIMHIERMAPUPD"" ENABLE"
"OLAPSYS","CWM2$HIERARCHYUPD","CWM2$HIERARCHY","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$HIERARCHYUPD"" 
  before insert or update on olapsys.CwM2$Hierarchy for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$HIERARCHYUPD"" ENABLE"
"OLAPSYS","CWM2$HIERCUSTOMSORTUPD","CWM2$HIERCUSTOMSORT","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$HIERCUSTOMSORTUPD"" 
  before insert or update on olapsys.CwM2$HierCustomSort for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$HIERCUSTOMSORTUPD"" ENABLE"
"OLAPSYS","CWM2$HIERLEVELRELUPD","CWM2$HIERLEVELREL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$HIERLEVELRELUPD"" 
  before insert or update on olapsys.CwM2$HierLevelRel for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$HIERLEVELRELUPD"" ENABLE"
"OLAPSYS","CWM2$LEVELATTRIBUTEMAPUPD","CWM2$LEVELATTRIBUTEMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$LEVELATTRIBUTEMAPUPD"" 
  before insert or update on olapsys.CwM2$LevelAttributeMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$LEVELATTRIBUTEMAPUPD"" ENABLE"
"OLAPSYS","CWM2$LEVELATTRIBUTEUPD","CWM2$LEVELATTRIBUTE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$LEVELATTRIBUTEUPD"" 
  before insert or update on olapsys.CwM2$LevelAttribute for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$LEVELATTRIBUTEUPD"" ENABLE"
"OLAPSYS","CWM2$LEVELDEL","CWM2$LEVEL","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$LEVELDEL"" 
  before delete on olapsys.CwM2$Level for each row
  declare
  begin
    delete  from olapsys.CwM2$AWCubeAggLevel
      where IRID in (select  cal.IRID
                       from  CwM2$AWCubeAgg ca
                            ,CwM2$AWCubeAggLevel cal
                       where ca.IRID        = cal.CubeAgg_IRID
                       and   ca.Version_ID  = 'CWM2'
                       and   cal.Level_IRID = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$LEVELDEL"" ENABLE"
"OLAPSYS","CWM2$LEVELUPD","CWM2$LEVEL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$LEVELUPD"" 
  before insert or update on olapsys.CwM2$Level for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$LEVELUPD"" ENABLE"
"OLAPSYS","CWM2$MEASUREDEL","CWM2$MEASURE","DELETE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$MEASUREDEL"" 
  before delete on olapsys.CwM2$Measure for each row
  declare
  begin
    delete  from olapsys.CwM2$AWCubeLoadMeasure
      where IRID in (select  clm.IRID
                       from  CwM2$AWCubeLoad cl
                            ,CwM2$AWCubeLoadMeasure clm
                       where cl.IRID          = clm.CubeLoad_IRID
                       and   cl.Version_ID    = 'CWM2'
                       and   clm.Measure_IRID = :old.irid);
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$MEASUREDEL"" ENABLE"
"OLAPSYS","CWM2$MEASURETABLEMAPUPD","CWM2$MEASURETABLEMAP","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$MEASURETABLEMAPUPD"" 
  before insert or update on olapsys.CwM2$MeasureTableMap for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$MEASURETABLEMAPUPD"" ENABLE"
"OLAPSYS","CWM2$MEASUREUPD","CWM2$MEASURE","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$MEASUREUPD"" 
  before insert or update on olapsys.CwM2$Measure for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$MEASUREUPD"" ENABLE"
"OLAPSYS","CWM2$STOREDDIMLVLTPLSDTLUPD","CWM2$STOREDDIMLVLTPLSDTL","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$STOREDDIMLVLTPLSDTLUPD"" 
  before insert or update on olapsys.CwM2$StoredDimLvlTplsDtl for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$STOREDDIMLVLTPLSDTLUPD"" ENABLE"
"OLAPSYS","CWM2$STOREDDIMLVLTPLSUPD","CWM2$STOREDDIMLVLTPLS","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""OLAPSYS"".""CWM2$STOREDDIMLVLTPLSUPD"" 
  before insert or update on olapsys.CwM2$StoredDimLvlTpls for each row
  declare
    v_User_Name varchar2(30);
  begin
    select USER into v_User_Name from dual;
    if inserting then
      :new.CreatedDate := SYSDATE;
      :new.UpdatedDate := null;
    else
      :new.UpdatedDate := SYSDATE;
    end if;
    :new.LastChangeUser := v_User_Name;
  end;
ALTER TRIGGER ""OLAPSYS"".""CWM2$STOREDDIMLVLTPLSUPD"" ENABLE"
"WMSYS","NO_VM_DDL","","CREATE OR ALTER OR DROP OR RENAME ","BEFORE EVENT","
  CREATE OR REPLACE TRIGGER ""WMSYS"".""NO_VM_DDL"" before alter or create or drop or rename on database
   WHEN ((sys.sysevent in ('ALTER', 'RENAME') and sys.dictionary_obj_type in ('INDEX','TABLE')) or
        (sys.sysevent = 'CREATE' and sys.dictionary_obj_type in ('INDEX', 'PROCEDURE', 'TRIGGER', 'VIEW')) or
        (sys.sysevent = 'DROP' and sys.dictionary_obj_type in ('INDEX', 'PROCEDURE', 'ROLE', 'TABLE', 'TRIGGER', 'TYPE', 'USER', 'VIEW'))) declare
  s_event varchar2(100) := sys.sysevent ;
  validStack integer ;
begin










  if (sys_context('lt_ctx', 'allowDDLOperation')='true') then
    return ;
  end if ;

  if (sys_context('lt_ctx', 'validStack') is null or sys_context('lt_ctx', 'validStack') != 'YES') then
    validStack := 0 ;
  else
    validStack := 1 ;
  end if ;

  if (s_event='CREATE') then
    execute immediate 'call wmsys.no_vm_create_proc(:1,:2,:3,:4)'
      using sys.dictionary_obj_type, sys.dictionary_obj_name, sys.dictionary_obj_owner, validStack ;
  elsif (s_event='DROP') then
    execute immediate 'call wmsys.no_vm_drop_proc(:1,:2,:3,:4)'
      using sys.dictionary_obj_type, sys.dictionary_obj_name, sys.dictionary_obj_owner, validStack ;
  elsif (s_event in ('ALTER', 'RENAME')) then
    execute immediate 'call wmsys.no_vm_alter_proc(:1,:2,:3,:4)'
      using sys.dictionary_obj_type, sys.dictionary_obj_name, sys.dictionary_obj_owner, validStack ;
  end if ;
end;
ALTER TRIGGER ""WMSYS"".""NO_VM_DDL"" DISABLE"
"WMSYS","NO_VM_DROP_A","","DROP ","AFTER EVENT","
  CREATE OR REPLACE TRIGGER ""WMSYS"".""NO_VM_DROP_A"" after drop on database  WHEN (sys.dictionary_obj_type in ('USER')) begin
  execute immediate 'call wmsys.lt_ctx_pkg.allowDDLOperation(''false'')' ;



end;
ALTER TRIGGER ""WMSYS"".""NO_VM_DROP_A"" DISABLE"
"XDB","Folder36_TAB$xd","Folder36_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""Folder36_TAB$xd"" after delete or update on ""XDB"".""Folder36_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','Folder36_TAB', :old.sys_nc_oid$, 'B8F668FF3A0A365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','Folder36_TAB', :old.sys_nc_oid$, 'B8F668FF3A0A365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""Folder36_TAB$xd"" ENABLE"
"XDB","SERVLET$xd","SERVLET","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""SERVLET$xd"" after delete or update on ""XDB"".""SERVLET"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','SERVLET', :old.sys_nc_oid$, 'B8F668FF3929365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','SERVLET', :old.sys_nc_oid$, 'B8F668FF3929365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""SERVLET$xd"" ENABLE"
"XDB","XDB$ACL$xd","XDB$ACL","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB$ACL$xd"" after delete or update on ""XDB"".""XDB$ACL"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XDB$ACL', :old.sys_nc_oid$, 'B8F668FF384A365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XDB$ACL', :old.sys_nc_oid$, 'B8F668FF384A365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XDB$ACL$xd"" ENABLE"
"XDB","XDB$CONFIG$xd","XDB$CONFIG","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB$CONFIG$xd"" after delete or update on ""XDB"".""XDB$CONFIG"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XDB$CONFIG', :old.sys_nc_oid$, 'B8F668FF3D06365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XDB$CONFIG', :old.sys_nc_oid$, 'B8F668FF3D06365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XDB$CONFIG$xd"" ENABLE"
"XDB","XDB$RESCONFIG$xd","XDB$RESCONFIG","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB$RESCONFIG$xd"" after delete or update on ""XDB"".""XDB$RESCONFIG"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XDB$RESCONFIG', :old.sys_nc_oid$, 'B8F668FF38DB365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XDB$RESCONFIG', :old.sys_nc_oid$, 'B8F668FF38DB365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XDB$RESCONFIG$xd"" ENABLE"
"XDB","XDB$STATS$xd","XDB$STATS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB$STATS$xd"" after delete or update on ""XDB"".""XDB$STATS"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XDB$STATS', :old.sys_nc_oid$, 'B8F668FF3BB8365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XDB$STATS', :old.sys_nc_oid$, 'B8F668FF3BB8365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XDB$STATS$xd"" ENABLE"
"XDB","XDBCONFIG_VALIDATE","XDB$CONFIG","INSERT OR UPDATE","BEFORE EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDBCONFIG_VALIDATE"" before insert or update
on xdb.XDB$CONFIG for each row
declare
  xdoc xmltype;
begin
  xdoc := :new.sys_nc_rowinfo$;
  xmltype.schemaValidate(xdoc);
end;
ALTER TRIGGER ""XDB"".""XDBCONFIG_VALIDATE"" ENABLE"
"XDB","XDB_PV_TRIG","PATH_VIEW","INSERT OR UPDATE OR DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB_PV_TRIG"" INSTEAD OF insert or delete or update
on xdb.path_view for each row
begin
  if inserting then
    xdb.xdb_pvtrig_pkg.pvtrig_ins(:new.res, :new.link, :new.path);

    /* check that either the REF or the BLOB columns are filled, not both */
  end if;

  if deleting then
     xdb.xdb_pvtrig_pkg.pvtrig_del(:old.res, :old.link, :old.path);

    /* check if we get the correct values from two tables in a view */
  end if;

  if updating then
     xdb.xdb_pvtrig_pkg.pvtrig_upd(:old.res,    :new.res,
                               :old.link,   :new.link,
                               :old.path,   :new.path );
  end if;
end;
ALTER TRIGGER ""XDB"".""XDB_PV_TRIG"" ENABLE"
"XDB","XDB_RV_TRIG","RESOURCE_VIEW","INSERT OR UPDATE OR DELETE","INSTEAD OF","
  CREATE OR REPLACE TRIGGER ""XDB"".""XDB_RV_TRIG"" INSTEAD OF insert or delete or update
on xdb.resource_view for each row
begin
  if inserting then
    xdb_rvtrig_pkg.rvtrig_ins(:new.res, :new.any_path);


  end if;

  if deleting then
     xdb_rvtrig_pkg.rvtrig_del(:old.res, :old.any_path);


  end if;

  if updating then
     xdb_rvtrig_pkg.rvtrig_upd(:old.res,    :new.res,
                               :old.any_path,   :new.any_path );
  end if;
end;
ALTER TRIGGER ""XDB"".""XDB_RV_TRIG"" ENABLE"
"XDB","XS$DATA_SECURITY$xd","XS$DATA_SECURITY","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XS$DATA_SECURITY$xd"" after delete or update on ""XDB"".""XS$DATA_SECURITY"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XS$DATA_SECURITY', :old.sys_nc_oid$, 'B8F668FF3E2D365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XS$DATA_SECURITY', :old.sys_nc_oid$, 'B8F668FF3E2D365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XS$DATA_SECURITY$xd"" ENABLE"
"XDB","XS$ROLESETS$xd","XS$ROLESETS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XS$ROLESETS$xd"" after delete or update on ""XDB"".""XS$ROLESETS"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XS$ROLESETS', :old.sys_nc_oid$, 'B8F668FF3EC1365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XS$ROLESETS', :old.sys_nc_oid$, 'B8F668FF3EC1365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XS$ROLESETS$xd"" ENABLE"
"XDB","XS$SECURITYCLASS$xd","XS$SECURITYCLASS","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""XS$SECURITYCLASS$xd"" after delete or update on ""XDB"".""XS$SECURITYCLASS"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','XS$SECURITYCLASS', :old.sys_nc_oid$, 'B8F668FF3EF5365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','XS$SECURITYCLASS', :old.sys_nc_oid$, 'B8F668FF3EF5365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""XS$SECURITYCLASS$xd"" ENABLE"
"XDB","aggregatePrivilege108_TAB$xd","aggregatePrivilege108_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""aggregatePrivilege108_TAB$xd"" after delete or update on ""XDB"".""aggregatePrivilege108_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','aggregatePrivilege108_TAB', :old.sys_nc_oid$, 'B8F668FF3EF6365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','aggregatePrivilege108_TAB', :old.sys_nc_oid$, 'B8F668FF3EF6365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""aggregatePrivilege108_TAB$xd"" ENABLE"
"XDB","description104_TAB$xd","description104_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""description104_TAB$xd"" after delete or update on ""XDB"".""description104_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','description104_TAB', :old.sys_nc_oid$, 'B8F668FF3EF8365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','description104_TAB', :old.sys_nc_oid$, 'B8F668FF3EF8365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""description104_TAB$xd"" ENABLE"
"XDB","description94_TAB$xd","description94_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""description94_TAB$xd"" after delete or update on ""XDB"".""description94_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','description94_TAB', :old.sys_nc_oid$, 'B8F668FF3E2E365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','description94_TAB', :old.sys_nc_oid$, 'B8F668FF3E2E365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""description94_TAB$xd"" ENABLE"
"XDB","fallback42_TAB$xd","fallback42_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""fallback42_TAB$xd"" after delete or update on ""XDB"".""fallback42_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','fallback42_TAB', :old.sys_nc_oid$, 'B8F668FF3A62365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','fallback42_TAB', :old.sys_nc_oid$, 'B8F668FF3A62365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""fallback42_TAB$xd"" ENABLE"
"XDB","fallback43_TAB$xd","fallback43_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""fallback43_TAB$xd"" after delete or update on ""XDB"".""fallback43_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','fallback43_TAB', :old.sys_nc_oid$, 'B8F668FF3A66365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','fallback43_TAB', :old.sys_nc_oid$, 'B8F668FF3A66365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""fallback43_TAB$xd"" ENABLE"
"XDB","fallback61_TAB$xd","fallback61_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""fallback61_TAB$xd"" after delete or update on ""XDB"".""fallback61_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','fallback61_TAB', :old.sys_nc_oid$, 'B8F668FF3A82365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','fallback61_TAB', :old.sys_nc_oid$, 'B8F668FF3A82365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""fallback61_TAB$xd"" ENABLE"
"XDB","fallback62_TAB$xd","fallback62_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""fallback62_TAB$xd"" after delete or update on ""XDB"".""fallback62_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','fallback62_TAB', :old.sys_nc_oid$, 'B8F668FF3A83365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','fallback62_TAB', :old.sys_nc_oid$, 'B8F668FF3A83365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""fallback62_TAB$xd"" ENABLE"
"XDB","ftp-log21_TAB$xd","ftp-log21_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""ftp-log21_TAB$xd"" after delete or update on ""XDB"".""ftp-log21_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','ftp-log21_TAB', :old.sys_nc_oid$, 'B8F668FF3981365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','ftp-log21_TAB', :old.sys_nc_oid$, 'B8F668FF3981365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""ftp-log21_TAB$xd"" ENABLE"
"XDB","http-log30_TAB$xd","http-log30_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""http-log30_TAB$xd"" after delete or update on ""XDB"".""http-log30_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','http-log30_TAB', :old.sys_nc_oid$, 'B8F668FF39C8365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','http-log30_TAB', :old.sys_nc_oid$, 'B8F668FF39C8365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""http-log30_TAB$xd"" ENABLE"
"XDB","include47_TAB$xd","include47_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""include47_TAB$xd"" after delete or update on ""XDB"".""include47_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','include47_TAB', :old.sys_nc_oid$, 'B8F668FF3A60365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','include47_TAB', :old.sys_nc_oid$, 'B8F668FF3A60365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""include47_TAB$xd"" ENABLE"
"XDB","include66_TAB$xd","include66_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""include66_TAB$xd"" after delete or update on ""XDB"".""include66_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','include66_TAB', :old.sys_nc_oid$, 'B8F668FF3A81365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','include66_TAB', :old.sys_nc_oid$, 'B8F668FF3A81365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""include66_TAB$xd"" ENABLE"
"XDB","privilege107_TAB$xd","privilege107_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""privilege107_TAB$xd"" after delete or update on ""XDB"".""privilege107_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','privilege107_TAB', :old.sys_nc_oid$, 'B8F668FF3EF7365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','privilege107_TAB', :old.sys_nc_oid$, 'B8F668FF3EF7365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""privilege107_TAB$xd"" ENABLE"
"XDB","title103_TAB$xd","title103_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""title103_TAB$xd"" after delete or update on ""XDB"".""title103_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','title103_TAB', :old.sys_nc_oid$, 'B8F668FF3EF9365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','title103_TAB', :old.sys_nc_oid$, 'B8F668FF3EF9365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""title103_TAB$xd"" ENABLE"
"XDB","title93_TAB$xd","title93_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""title93_TAB$xd"" after delete or update on ""XDB"".""title93_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','title93_TAB', :old.sys_nc_oid$, 'B8F668FF3E2F365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','title93_TAB', :old.sys_nc_oid$, 'B8F668FF3E2F365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""title93_TAB$xd"" ENABLE"
"XDB","xdb-log13_TAB$xd","xdb-log13_TAB","UPDATE OR DELETE","AFTER EACH ROW","
  CREATE OR REPLACE TRIGGER ""XDB"".""xdb-log13_TAB$xd"" after delete or update on ""XDB"".""xdb-log13_TAB"" for each row BEGIN  IF (deleting) THEN xdb.xdb_pitrig_pkg.pitrig_del('XDB','xdb-log13_TAB', :old.sys_nc_oid$, 'B8F668FF394C365AE053690AF40A6455' ); END IF;   IF (updating) THEN xdb.xdb_pitrig_pkg.pitrig_upd('XDB','xdb-log13_TAB', :old.sys_nc_oid$, 'B8F668FF394C365AE053690AF40A6455', user ); END IF; END;
ALTER TRIGGER ""XDB"".""xdb-log13_TAB$xd"" ENABLE"
